<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/16/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%20RTTI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/16/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%20RTTI/" class="post-title-link" itemprop="url">运行时类型识别 RTTI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-16 15:48:28 / 修改时间：16:25:04" itemprop="dateCreated datePublished" datetime="2024-07-16T15:48:28+08:00">2024-07-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">继承与多态</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="1、运行时类型识别-RTTI"><a href="#1、运行时类型识别-RTTI" class="headerlink" title="1、运行时类型识别 RTTI"></a>1、运行时类型识别 RTTI</h2><p>C++ 的 RTTI（Run-Time Type Information）是一种运行时类型信息机制，用于在程序运行时获取对象的类型信息。每个具有多态性的类（包括虚函数或虚基类）都会生成一个类型信息对象（Type Information Object），其中包含了有关该类的类型信息，例如类的名称、继承关系、虚函数表等。这些类型信息对象在编译时生成，并与每个类的对象关联起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407161554569.webp" alt="img"></p>
<p>RTTI 主要包括两个关键字：typeid 和 dynamic_cast。</p>
<ul>
<li>typeid 运算符，用于返回表达式的类型。  </li>
<li>dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
<p>一般来说<strong>动态类型指的是某个基类指针或引用指向一个派生类对象，且基类中有虚函数，此时会绑定对象的动态类型。</strong></p>
<h2 id="2、dynamic-cast"><a href="#2、dynamic-cast" class="headerlink" title="2、dynamic_cast"></a>2、dynamic_cast</h2><p><code>dynamic_cast</code> 可以将指向基类的指针或引用转换为指向派生类的指针或引用，同时会进行类型检查，确保类型转换的安全性。</p>
<p>基本用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)   <span class="comment">// e必须是有效的指针</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)   <span class="comment">// e必须是个左值</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)  <span class="comment">// e不能是左值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rtti/dynamic_cast.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况，Base指针指向Derive对象，可以将Base指针转为Derive指针</span></span><br><span class="line">    <span class="function">Derive <span class="title">derive</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Base *bp = &amp;derive;</span><br><span class="line">    <span class="keyword">if</span> (Derive *dp = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(bp)) &#123; <span class="comment">// 可以成功转型</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        dp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况，Base指针指向Base对象，不能将Base指针转为Derive指针</span></span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    bp = &amp;base;</span><br><span class="line">    <span class="keyword">if</span> (Derive *dp = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(bp)) &#123; <span class="comment">// 转型失败</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        dp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况，Derive指针指向Derive对象，可以将Derive指针转为Base指针</span></span><br><span class="line">    Derive *dp = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (Base *bp = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(dp)) &#123; <span class="comment">// 转型成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        bp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下代码不能运行，不能将Derive指针指向Base对象</span></span><br><span class="line">    <span class="comment">// Derive *dp = new Base(20);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ g++ dynamic_cast.cpp &amp;&amp; ./a.out</span></span><br><span class="line"><span class="comment">dynamic cast succeed~  i = 10</span></span><br><span class="line"><span class="comment">dynamic cast failed!</span></span><br><span class="line"><span class="comment">dynamic cast succeed~  i = 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>想通过 dynamic_cast 进行动态的转型，基类必须有虚函数；</li>
<li>基类指针必须指向派生类对象，才可以将其转为派生类指针；</li>
<li>指向派生类对象的派生类指针，自然可以转为基类指针； </li>
<li>不能将派生类指针指向基类对象；</li>
</ul>
<blockquote>
<p><strong>什么情况下应该用 dynamic_cast 替代虚函数？</strong></p>
<p>如果我们需要在派生类中增加新的成员函数 f，但又无法取得基类的源代码，因而无法在基类中增加相应的虚函数，这时，可以在派生类中增加非虚成员函数。但这样一来，就无法用基类指针调用函数  f。如果在程序中需要通过基类指针（如使用该继承层次的某个类中所包含的指向基类对象的指针数据成员 p）来调用 f，则必须使用  dynamic_cast 将 p 转换为指向派生类的指针，才能调用 f。</p>
<p><strong>也就是说，如果无法为基类增加虚函数，就可以使用 dynamic_cast 代替虚函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1 show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 specific function f&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_f_if_derived2</span><span class="params">(Base* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Derived2* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(p)) &#123;</span><br><span class="line">        d2-&gt;<span class="built_in">f</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not a Derived2 instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; objects;</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived1&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived2&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived1&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived2&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : objects) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">        <span class="built_in">call_f_if_derived2</span>(obj.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Derived1 show</span></span><br><span class="line"><span class="comment">Not a Derived2 instance</span></span><br><span class="line"><span class="comment">Derived2 show</span></span><br><span class="line"><span class="comment">Derived2 specific function f</span></span><br><span class="line"><span class="comment">Derived1 show</span></span><br><span class="line"><span class="comment">Not a Derived2 instance</span></span><br><span class="line"><span class="comment">Derived2 show</span></span><br><span class="line"><span class="comment">Derived2 specific function f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3、typeid-运算符"><a href="#3、typeid-运算符" class="headerlink" title="3、typeid 运算符"></a>3、typeid 运算符</h2><p><code>typeid </code>运算符用于获取表达式的实际类型信息。可以通过 <code>typeid</code> 运算符获取对象的类型信息，也可以获取类型的名称。<code>typeid</code> 运算符返回一个 <code>std::type_info</code> 对象，该对象包含有关类型的信息。可以使用 <code>std::type_info</code> 对象进行类型比较或查询类型的名称。</p>
<ul>
<li>e 可以是任意表达式或类类型；</li>
<li>typeid 返回值是<strong>对一个常量对象的引用</strong>，该对象的类型是标准库类型 type_info 或者 type_info 的公有派生类型；</li>
<li>e 如果是引用，typeid 会返回该引用所引用的对象类型；</li>
<li>typeid 作用在数组上时，返回的是数组类型，而不是指针类型；</li>
<li>运算对象不是类类型，或者不包含虚函数的类，指示的是静态类型；</li>
<li>如果是定义了一个虚函数的类型，typeid 的结果运行时才会求得。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rtti/typeid.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive *dp = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">10</span>);</span><br><span class="line">    Base *bp = dp; <span class="comment">// 两个指针都指向Derive对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(*dp)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bp和dp指向同一个类型的对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derive)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bp指向的是Derive对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ g++ rtti2.cpp &amp;&amp; ./a.out</span></span><br><span class="line"><span class="comment">bp和dp指向同一个类型的对象</span></span><br><span class="line"><span class="comment">bp指向的是Derive对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注： </p>
<ul>
<li>typeid 应该作用于对象，而不是指针本身，因此需要使用 <code>*bp</code> </li>
<li>只有当类型有虚函数的时候，编译器才会在运行时对表达式进行求值； </li>
<li>如果类型没有虚函数，typeid 返回的是静态类型，编译器无须求值也知道表达式的静态类型； </li>
<li>如果指针 p 指向的类型<strong>没有虚函数</strong>，则计算 <code>typeid(*p)</code> 的时候 <code>*p</code> 可以不是一个有效的对象； </li>
<li>如果指针 p 指向的类型<strong>有虚函数</strong>， <code>*p</code> 会在运行时求值，如果 p 是一个空指针，会抛出 bad_typeid 的异常。</li>
</ul>
<h2 id="4、应用举例"><a href="#4、应用举例" class="headerlink" title="4、应用举例"></a>4、应用举例</h2><p>现有一个基类和一个派生类，我们需要为其实现相等运算符。</p>
<p>一种考虑的方法是定义一套虚函数，然后各自在判断是否相等。这样的问题是因为虚函数中基类和派生类必须有相同的形参，如果我们想定义一个虚函数 equal，则该函数的形参必须是基类的引用。此时，equal 函数将只能使用基类的成员，而不能比较派生类独有的成员。</p>
<p>下面是解决方法，<strong>可以利用 typeid 先判断类型是否相同，然后再调用各自版本的 equal 函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base&amp;, <span class="type">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i, <span class="type">int</span> _j) : <span class="built_in">i</span>(_i), <span class="built_in">j</span>(_j) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> _i, <span class="type">int</span> _j, <span class="type">int</span> _k) : <span class="built_in">Base</span>(_i, _j), <span class="built_in">k</span>(_k) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base &amp;lhs, <span class="type">const</span> Base &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">// 如果typeid不相等返回false；否则调用equal()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">typeid</span>(lhs) == <span class="built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="built_in">equal</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derive::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive::equal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 我们清楚这两个类型是相等的，所以转换过程不会抛出异常</span></span><br><span class="line">    Derive r = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive&amp;&gt;(rhs);</span><br><span class="line">    <span class="comment">// 执行比较两个Derive对象的操作并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;i == r.i &amp;&amp; <span class="keyword">this</span>-&gt;j == r.j &amp;&amp; <span class="keyword">this</span>-&gt;k == r.k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::equal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 执行比较Base对象的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;i == rhs.i &amp;&amp; <span class="keyword">this</span>-&gt;j == rhs.j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况：两个基类指针进行判断</span></span><br><span class="line">    Base *b1 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Base *b2 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b1 == *b2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b1和b2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况：一个基类指针和一个派生类指针，都指向派生类对象</span></span><br><span class="line">    Base *b3 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    Derive *d1 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b3 == *d1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b3和d1相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b3和d1不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况：两个指针分别指向基类对象和派生类对象，他两不能直接判断</span></span><br><span class="line">    Base *b4 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Derive *d2 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b4 == *d2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b4和d2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b4和d2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># ./test</span></span><br><span class="line">Base::equal()</span><br><span class="line">b1和b2相等</span><br><span class="line">Derive::equal()</span><br><span class="line">b3和d1不相等</span><br><span class="line">b4和d2不相等</span><br></pre></td></tr></table></figure>

<p>可以看出:</p>
<ul>
<li>相同动态类型在判断的时候会调用各自版本的 equal 函数;</li>
<li>而类型不相同的 typeid 判断相等直接返回 false。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/16/2%20Linux%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/16/2%20Linux%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/" class="post-title-link" itemprop="url">进程终止</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-16 11:59:31 / 修改时间：15:49:05" itemprop="dateCreated datePublished" datetime="2024-07-16T11:59:31+08:00">2024-07-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、什么是终止函数"><a href="#1、什么是终止函数" class="headerlink" title="1、什么是终止函数"></a>1、什么是终止函数</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/07/16/2%20Linux%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2_diy_tcpip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2_diy_tcpip/" class="post-title-link" itemprop="url">项目2_diy_tcpip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 16:21:03" itemprop="dateCreated datePublished" datetime="2024-07-03T16:21:03+08:00">2024-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-22 21:27:41" itemprop="dateModified" datetime="2024-07-22T21:27:41+08:00">2024-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042007671.png" alt="image-20240704200718437"></p>
<h2 id="1、数据包收发"><a href="#1、数据包收发" class="headerlink" title="1、数据包收发"></a>1、数据包收发</h2><p>利用 pcap 往网络上收发数据包。</p>
<p>以下为测试代码，主要功能：</p>
<ul>
<li>在一个无限循环中不断捕获和修改网络数据包，然后将其发送出去，并在每次循环中打印计数器值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br><span class="line">	<span class="keyword">while</span> (pcap) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">1024</span>];  	<span class="comment">// 缓存</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span> *<span class="title">pkthdr</span>;</span>  	<span class="comment">// 存储抓取的数据包包头</span></span><br><span class="line">		<span class="type">const</span> <span class="type">uint8_t</span> *pkt_data;  		<span class="comment">// 存储抓取的数据包</span></span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;begin test: %d\n&quot;</span>, counter++);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">			buffer[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 接收数据包</span></span><br><span class="line">		<span class="keyword">if</span> (pcap_next_ex(pcap, &amp;pkthdr, &amp;pkt_data) == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> len = pkthdr-&gt;len &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : pkthdr-&gt;len;</span><br><span class="line">		plat_memcpy(buffer, pkt_data, len);</span><br><span class="line">		buffer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		buffer[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送数据包</span></span><br><span class="line">		<span class="keyword">if</span> (pcap_inject(pcap, buffer, len) == <span class="number">-1</span>) &#123;</span><br><span class="line">			plat_printf(<span class="string">&quot;pcap send: send packet failed %s \n&quot;</span>, pcap_geterr(pcap));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><code>#include &lt;stdio.h&gt;</code>：包含标准输入输出库，用于打印信息。</p>
<p><code>#include &quot;pcap/pcap.h&quot;</code>：包含 <code>pcap</code> 库的头文件，用于网络数据包捕获和发送。</p>
<p><code>#include &quot;sys_plat.h&quot;</code>：包含自定义平台相关的头文件，假设其中定义了 <code>plat_printf</code> 和 <code>plat_memcpy</code> 函数，以及网络设备相关的信息。</p>
<h3 id="打开-pcap-会话"><a href="#打开-pcap-会话" class="headerlink" title="打开 pcap 会话"></a>打开 pcap 会话</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br></pre></td></tr></table></figure>

<h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">1024</span>];  	<span class="comment">// 静态缓存</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;			<span class="comment">// 计数器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span> *<span class="title">pkthdr</span>;</span>  	<span class="comment">// 存储抓取的数据包包头</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> *pkt_data;  		<span class="comment">// 存储抓取的数据包</span></span><br></pre></td></tr></table></figure>

<h3 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h3><p>接收一个数据包，如果接收失败，继续下一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据包</span></span><br><span class="line"><span class="keyword">if</span> (pcap_next_ex(pcap, &amp;pkthdr, &amp;pkt_data) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定要拷贝的数据包长度，不能超过定义的 buffer 的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = pkthdr-&gt;len &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : pkthdr-&gt;len;</span><br></pre></td></tr></table></figure>

<p>将数据包数据拷贝到缓存 buffer 中，并在此处做简单的修改，将缓存 buffer 的前两个字节设为 1 和 2，以用于区别该数据包是接收还是发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plat_memcpy(buffer, pkt_data, len);</span><br><span class="line">buffer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">buffer[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p>发送修改后的数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据包</span></span><br><span class="line"><span class="keyword">if</span> (pcap_inject(pcap, buffer, len) == <span class="number">-1</span>) &#123;</span><br><span class="line">	plat_printf(<span class="string">&quot;pcap send: send packet failed %s \n&quot;</span>, pcap_geterr(pcap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 wireshark 中抓取相应的数据包如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042013405.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042013776.png" alt="2"></p>
<h2 id="2、多线程环境"><a href="#2、多线程环境" class="headerlink" title="2、多线程环境"></a>2、多线程环境</h2><h3 id="结合计数信号量-互斥锁实现多线程环境"><a href="#结合计数信号量-互斥锁实现多线程环境" class="headerlink" title="结合计数信号量+互斥锁实现多线程环境"></a>结合计数信号量+互斥锁实现多线程环境</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051056708.png" alt="image-20240705105613396"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> sem;</span><br><span class="line"><span class="type">static</span> <span class="type">sys_mutex_t</span> mutex;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		sys_mutex_lock(mutex);</span><br><span class="line">		count++;</span><br><span class="line">		sys_mutex_unlock(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	plat_printf(<span class="string">&quot;thread1: count = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		plat_printf(<span class="string">&quot;this is thread1: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">		sys_sleep(<span class="number">1000</span>);</span><br><span class="line">		sys_sem_notify(sem);</span><br><span class="line">		sys_sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		sys_mutex_lock(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		sys_mutex_unlock(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	plat_printf(<span class="string">&quot;thread2: count = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sys_sem_wait(sem, <span class="number">0</span>);</span><br><span class="line">		plat_printf(<span class="string">&quot;this is thread2: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	sem = sys_sem_create(<span class="number">0</span>);  <span class="comment">// 初始化信号量</span></span><br><span class="line">	mutex = sys_mutex_create();  <span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">	sys_thread_create(thread1_entry, <span class="string">&quot;1_test_thread1&quot;</span>);</span><br><span class="line">	sys_thread_create(thread2_entry, <span class="string">&quot;2_test_thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br><span class="line">	<span class="keyword">while</span> (pcap) &#123;</span><br><span class="line">		<span class="comment">// 接收数据包</span></span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送数据包</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042003498.png" alt="image-20240704200358198"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051105206.png" alt="image-20240705110539162"></p>
<h3 id="线程间的资源访问控制实例"><a href="#线程间的资源访问控制实例" class="headerlink" title="线程间的资源访问控制实例"></a>线程间的资源访问控制实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者线程 --(生产)--&gt; 数据 --(消费)--&gt; 消费者线程</span><br></pre></td></tr></table></figure>

<h4 id="（1）循环缓存"><a href="#（1）循环缓存" class="headerlink" title="（1）循环缓存"></a>（1）循环缓存</h4><p>当生产者线程的生产速率和消费者线程的消费速率不匹配时，就需要缓存来不及消耗的产品。</p>
<p>使用环形缓存区的方式来实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051948932.png" alt="image-20240705194807866"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者线程 --(生产)--&gt; [数据缓存] --(消费)--&gt; 消费者线程</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		sys_sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此处并未控制读&#x2F;写速率，可以看出先执行读数据操作，再执行写数据操作，实际上是不正确的。</li>
<li>观察读&#x2F;写的频次，可以看出写数据的速率较快，大约为读速率的两倍。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051921443.png" alt="image-20240705192122236"></p>
<h4 id="（2）控制读速率"><a href="#（2）控制读速率" class="headerlink" title="（2）控制读速率"></a>（2）控制读速率</h4><blockquote>
<p><strong>消费者线程必须在缓存中有数据的情况下才能读，否则应该等待。因此对于读速率需要进行控制。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> read_sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(read_sem, <span class="number">0</span>);</span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		sys_sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line">		sys_sem_notify(read_sem);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	read_sem = sys_sem_create(<span class="number">0</span>);</span><br><span class="line">	sys_thread_create(thread1_entry, <span class="string">&quot;1_test_thread1&quot;</span>);</span><br><span class="line">	sys_thread_create(thread2_entry, <span class="string">&quot;2_test_thread2&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051937633.png" alt="image-20240705193710559"></p>
<h4 id="（3）控制写速率"><a href="#（3）控制写速率" class="headerlink" title="（3）控制写速率"></a>（3）控制写速率</h4><p>如果设置<strong>读数据的速率大于写数据的速率</strong>，则会产生以下效果，可以发现生产者写一个数据，消费者读一个数据：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051938284.png" alt="image-20240705193854205"></p>
<blockquote>
<p><strong>此外，生产者线程必须在缓存中有空闲单元的情况下才能往里面写数据，否则应该等待。因此对于写速率也需要进行控制。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> read_sem;</span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> write_sem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(read_sem, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		</span><br><span class="line">		sys_sem_notify(write_sem);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(write_sem, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">		sys_sem_notify(read_sem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	read_sem = sys_sem_create(<span class="number">0</span>);</span><br><span class="line">	write_sem = sys_sem_create(<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述程序后，出现下列现象：</p>
<ol>
<li><p>生产者线程进行大量写操作，<strong>迅速将缓存区占满</strong>（体现为write data &#x3D; 99）;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_sem_wait(write_sem, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>程序开始运行时，write_sem 初始值为 100，即缓存区大小，因此此时生产者的写入不受限制，可以一直往缓存区中写入数据，直到缓存区占满。</p>
</li>
<li><p>当缓存区满后，写速率大幅度减慢，受到读速率的影响，此时读一个数据后再写一个数据。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051948347.png" alt="image-20240705194831290"></p>
<h2 id="3、网络编程"><a href="#3、网络编程" class="headerlink" title="3、网络编程"></a>3、网络编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端             2.启动并发起请求         4.处理相应，关闭连接</span><br><span class="line">                         |                        |</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                   |                    |                  |</span><br><span class="line">服务器端    1.启动并等待请求     3.接受请求，并发回响应       5.关闭</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端   // 服务器端</span></span><br><span class="line"></span><br><span class="line">			   socket()  </span><br><span class="line">	              |</span><br><span class="line">socket()        bind()</span><br><span class="line">   |              |</span><br><span class="line">connect() --&gt;  listen() --&gt; accept()</span><br><span class="line">   |              |</span><br><span class="line"> send()   --&gt;   recv()</span><br><span class="line">   |              |</span><br><span class="line"> recv()   &lt;--   send()</span><br><span class="line">   |              |</span><br><span class="line"> close()        close()</span><br></pre></td></tr></table></figure>

<h3 id="利用套接字设计客户端"><a href="#利用套接字设计客户端" class="headerlink" title="利用套接字设计客户端"></a>利用套接字设计客户端</h3><p>创建一个基于 TCP 协议的 echo 客户端：</p>
<ol>
<li>读取键盘输入的字符串并发送给服务器；</li>
<li>接收服务器发回来的回应，并显示在屏幕上。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">键盘  --(fgets)--&gt;              --(send)-------(recv)--&gt; </span><br><span class="line">                    TCP客户端                              TCP客户端</span><br><span class="line">屏幕  &lt;--(printf)--             --(recv)-------(send)--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="利用套接字设计服务器端"><a href="#利用套接字设计服务器端" class="headerlink" title="利用套接字设计服务器端"></a>利用套接字设计服务器端</h3><h1 id="二、整体结构设计"><a href="#二、整体结构设计" class="headerlink" title="二、整体结构设计"></a>二、整体结构设计</h1><h2 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">	- app</span><br><span class="line">		- test</span><br><span class="line">			- main.c</span><br><span class="line">    - net</span><br><span class="line">    	- net</span><br><span class="line">    		- net_err.h  <span class="comment">// net相关的变量定义</span></span><br><span class="line">    		- net.h		 <span class="comment">// tcp/ip协议栈初始化</span></span><br><span class="line">    		- exmsg.h	 <span class="comment">// 核心工作线程初始化，所有tcp/ip相关的事件都交由该线程处理</span></span><br><span class="line">    	- src</span><br><span class="line">    - plat</span><br><span class="line">    	- net_plat.c</span><br><span class="line">    	- sys_plat.c</span><br></pre></td></tr></table></figure>



<p>整个项目的核心为<strong>工作线程</strong>，对应于<code>src/net/src/exmsg.c</code>模块。这个模块是TCP&#x2F;IP核心线程通信模块，运行了一个核心线程，<strong>所有 TCP&#x2F;IP 中相关的事件都交由该线程处理</strong>。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 协议栈初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">net_err_t</span> <span class="title function_">net_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    net_plat_init();  <span class="comment">// 初始化硬件资源</span></span><br><span class="line"></span><br><span class="line">    exmsg_init();</span><br><span class="line">    <span class="keyword">return</span> NET_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么在协议栈初始化时需要先进行硬件资源初始化？是为了适应不同平台吗？</strong></p>
<p>在编写 TCP&#x2F;IP 协议栈的过程中，在协议栈初始化时首先进行硬件资源初始化是非常重要的一步，原因主要有以下几个方面：</p>
<ol>
<li>适应不同平台：不同的平台可能有不同的硬件资源和配置要求。进行硬件资源初始化可以确保协议栈能够适应不同的平台，并能够正确地与底层硬件进行交互。</li>
<li>确保硬件资源可用：协议栈的运行依赖于底层的网络硬件资源（如网卡、网络接口等）。在协议栈初始化时，首先初始化硬件资源可以确保这些资源是可用的，并且已经准备好进行数据传输。</li>
<li>设置硬件参数：硬件资源初始化过程通常包括设置硬件参数（如网卡的 MAC 地址、IP 地址、子网掩码等）。这些参数对于协议栈的正确运行至关重要，因为它们决定了如何在网络中进行数据传输。</li>
<li>注册硬件中断和回调函数：硬件资源初始化过程中通常需要注册硬件中断和回调函数，以便在数据包到达时能够及时通知协议栈进行处理。如果没有进行硬件资源初始化，协议栈将无法及时响应网络事件。</li>
<li>分配和管理资源：硬件资源初始化过程可能涉及到分配和管理一些必要的资源，如内存缓冲区、DMA 通道等。这些资源对于协议栈的高效运行也是至关重要的。</li>
<li>错误处理：在硬件资源初始化阶段，可以检测和处理可能的硬件错误。如果硬件资源不可用或者初始化失败，可以在这个阶段进行相应的错误处理，避免后续协议栈运行时出现难以调试的问题。</li>
</ol>
</blockquote>
<h2 id="2、网络结构"><a href="#2、网络结构" class="headerlink" title="2、网络结构"></a>2、网络结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407061739436.png" alt="整体结构设计" style="zoom: 33%;" />

<h2 id="3、协议分层"><a href="#3、协议分层" class="headerlink" title="3、协议分层"></a>3、协议分层</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407061739339.png" alt="软件层级结构"></p>
<h1 id="三、调试信息输出模块"><a href="#三、调试信息输出模块" class="headerlink" title="三、调试信息输出模块"></a>三、调试信息输出模块</h1><p>这个项目的调试信息输出模块主要用于在开发和调试过程中输出各种调试信息，包括错误、警告和一般信息。它包含了一些宏定义、函数和常量，用于控制调试信息的输出格式和级别。下面是对该模块的详细总结：</p>
<h2 id="1、dbg-c"><a href="#1、dbg-c" class="headerlink" title="1、dbg.c"></a>1、dbg.c</h2><ol>
<li><p><strong>调试信息显示样式设置</strong>：通过 ANSI 转义序列设置不同等级的显示样式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_RESET       <span class="string">&quot;\033[0m&quot;</span>       <span class="comment">// 复位显示</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_ERROR       <span class="string">&quot;\033[31m&quot;</span>      <span class="comment">// 红色显示</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_WARNING     <span class="string">&quot;\033[33m&quot;</span>      <span class="comment">// 黄色显示</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出级别</strong>：定义了不同的调试信息输出级别，每个级别对应不同的数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_NONE           0         <span class="comment">// 不开启任何输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_ERROR          1         <span class="comment">// 只开启错误信息输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_WARNING        2         <span class="comment">// 开启错误和警告信息输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_INFO           3         <span class="comment">// 开启错误、警告、一般信息输出</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出函数</strong></p>
<ul>
<li><p><code>dbg_print</code>：根据不同的级别输出调试信息，包括文件名、函数名、行号和具体的调试信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dbg_print</span><span class="params">(<span class="type">int</span> m_level, <span class="type">int</span> s_level, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* func, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dump_mac</code>：输出MAC地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dump_mac</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * msg, <span class="type">const</span> <span class="type">uint8_t</span> * mac)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dump_ip_buf</code>：输出IP地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dump_ip_buf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">const</span> <span class="type">uint8_t</span>* ip)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>调试输出宏</strong>：提供了便捷的宏用于不同级别的调试信息输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_info(module, fmt, ...)  dbg_print(module, DBG_LEVEL_INFO, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_error(module, fmt, ...)  dbg_print(module, DBG_LEVEL_ERROR, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_warning(module, fmt, ...) dbg_print(module, DBG_LEVEL_WARNING, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>断言宏</strong>：提供断言宏用于在调试过程中验证表达式的正确性，如果表达式为假，则输出错误信息并进入无限循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_assert(expr, msg)   &#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) &#123;\</span></span><br><span class="line"><span class="meta">        dbg_print(DBG_LEVEL_ERROR, DBG_LEVEL_ERROR, __FILE__, __FUNCTION__, __LINE__, <span class="string">&quot;assert failed:&quot;</span>#expr<span class="string">&quot;,&quot;</span>msg); \</span></span><br><span class="line"><span class="meta">        while(1);   \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出开关</strong>：定义了不同模块的调试信息输出级别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_MBLOCK           DBG_LEVEL_ERROR         <span class="comment">// 内存块管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_QUEUE            DBG_LEVEL_ERROR         <span class="comment">// 定长存储块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_MSG              DBG_LEVEL_ERROR         <span class="comment">// 消息通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_BUF              DBG_LEVEL_ERROR         <span class="comment">// 数据包管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_PLAT             DBG_LEVEL_ERROR         <span class="comment">// 系统平台</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_INIT             DBG_LEVEL_ERROR         <span class="comment">// 初始化模块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_NETIF            DBG_LEVEL_ERROR         <span class="comment">// 网络接口层</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ETHER            DBG_LEVEL_ERROR         <span class="comment">// 以太网协议层</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TOOLS            DBG_LEVEL_ERROR         <span class="comment">// 工具集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TIMER            DBG_LEVEL_ERROR         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ARP              DBG_LEVEL_ERROR         <span class="comment">// ARP协议</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_IP               DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ICMP             DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_SOCKET           DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_RAW              DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_UDP              DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_DNS              DBG_LEVEL_ERROR         <span class="comment">// DNS调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TCP              DBG_LEVEL_INFO          <span class="comment">// 调试开关</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体实现分析"><a href="#具体实现分析" class="headerlink" title="具体实现分析"></a>具体实现分析</h3><h4 id="dbg-print-函数"><a href="#dbg-print-函数" class="headerlink" title="dbg_print 函数"></a><code>dbg_print</code> 函数</h4><p>该函数根据日志等级输出调试信息，具体实现如下：</p>
<ol>
<li><p>定义日志等级标题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* title[] = &#123;</span><br><span class="line">    [DBG_LEVEL_ERROR] = DBG_STYLE_ERROR<span class="string">&quot;error&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_WARNING] = DBG_STYLE_WARNING<span class="string">&quot;warning&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_INFO] = <span class="string">&quot;info&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_NONE] = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否输出日志信息：仅当主日志等级 <code>m_level</code> 大于等于子日志等级 <code>s_level</code> 时，才输出日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_level &gt;= s_level) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取文件名：通过遍历字符串，从路径中提取文件名部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * end = file + plat_strlen(file);</span><br><span class="line"><span class="keyword">while</span> (end &gt;= file) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*end == <span class="string">&#x27;\\&#x27;</span>) || (*end == <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出日志头部信息：输出日志级别、文件名、函数名和行号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plat_printf(<span class="string">&quot;%s(%s-%s-%d):&quot;</span>, title[s_level], end, func, line);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出具体日志信息：使用可变参数列表处理格式化字符串，输出具体日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">va_list args;</span><br><span class="line"></span><br><span class="line">va_start(args, fmt);</span><br><span class="line">plat_vsprintf(str_buf, fmt, args);</span><br><span class="line">plat_printf(<span class="string">&quot;%s\n&quot;</span>DBG_STYLE_RESET, str_buf);</span><br><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设在代码的某处使用这些宏和函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dbg_info(DBG_TCP, <span class="string">&quot;TCP connection established&quot;</span>);</span><br><span class="line">dbg_warning(DBG_TCP, <span class="string">&quot;TCP connection may be slow&quot;</span>);</span><br><span class="line">dbg_error(DBG_TCP, <span class="string">&quot;TCP connection failed&quot;</span>);</span><br><span class="line">dbg_assert(ptr != <span class="literal">NULL</span>, <span class="string">&quot;Pointer should not be NULL&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_INFO</code> 时，会输出 “TCP connection established” 信息。</li>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_WARNING</code> 时，会输出 “TCP connection may be slow” 警告。</li>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_ERROR</code> 时，会输出 “TCP connection failed” 错误。</li>
<li>如果 <code>ptr</code> 为 <code>NULL</code>，则输出断言失败信息并进入无限循环。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该调试信息输出模块通过定义不同的日志等级和使用可变参数处理，提供了灵活且易用的调试信息输出功能。通过宏定义，开发者可以方便地在代码中插入调试信息输出，帮助快速定位问题，提高开发效率。</p>
<h1 id="四、定长内存块管理"><a href="#四、定长内存块管理" class="headerlink" title="四、定长内存块管理"></a>四、定长内存块管理</h1><h2 id="1、协议栈中的存储管理"><a href="#1、协议栈中的存储管理" class="headerlink" title="1、协议栈中的存储管理"></a>1、协议栈中的存储管理</h2><p>当应用程序需要请求工作线程去做某事时，需要先申请一个消息结构，即一个内存块，并将这个内存块的指针插入消息队列中。工作线程在接收到这个指针后执行相应的操作，完成后释放该内存块。</p>
<p>将数据包拆分成大小一致的数据块，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091442502.png" alt="image-20240709144204250" style="zoom: 67%;" />

<p>本协议栈在设计时采用<strong>固定长度</strong>的存储分配，考虑以下两点：</p>
<p>1、在某些系统上，内核并没有提供动态内存分配函数；– 考虑可移植性。</p>
<p>2、减少动态分配造成的内存碎片问题。</p>
<p>在初始化时，将数组中各个数组元素构建成一个<strong>空闲链表</strong>，当需要内存时，从中取出一个内存块用于分配，并且进行<strong>加锁</strong>处理，以适用于多线程场景。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091805403.png" alt="定长存储分配" style="zoom: 67%;" />

<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091701626.png" alt="image-20240709170116444"></p>
<p>实现了一个存储块管理器（<code>mblock</code>），用于管理内存块的分配和释放。通过使用链表和锁机制，实现了多线程环境下的安全内存管理。下面是对文件的详细分析和总结：</p>
<h2 id="2、mblock-c"><a href="#2、mblock-c" class="headerlink" title="2、mblock.c"></a>2、mblock.c</h2><p>定长内存块管理器（Fixed-size Memory Block Manager）通过将一个连续的内存区域分割成固定大小的块，然后使用链表管理这些块，实现了高效的内存分配和释放。以下是该模块的详细分析：</p>
<h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mblock_t</span> &#123;</span></span><br><span class="line">    <span class="type">nlist_t</span> free_list;      <span class="comment">// 空闲块链表</span></span><br><span class="line">    <span class="type">void</span> *start;            <span class="comment">// 内存块起始地址（未使用）</span></span><br><span class="line">    <span class="type">nlocker_t</span> locker;       <span class="comment">// 锁，用于多线程同步</span></span><br><span class="line">    <span class="type">sys_sem_t</span> alloc_sem;    <span class="comment">// 分配信号量，用于控制分配时的等待</span></span><br><span class="line">&#125; <span class="type">mblock_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>free_list</code>: 空闲块链表，用于存储空闲内存块。</li>
<li><code>start</code>: 内存块起始地址，目前未使用。</li>
<li><code>locker</code>: 互斥锁 <code>nlocker_t</code>，用于保护对 <code>free_list</code> 的访问，确保线程安全性。</li>
<li><code>alloc_sem</code>: 分配信号量 <code>sys_sem_t</code>，用于控制在没有空闲块时的等待。</li>
</ul>
<h3 id="初始化函数-mblock-init"><a href="#初始化函数-mblock-init" class="headerlink" title="初始化函数 mblock_init"></a>初始化函数 <code>mblock_init</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">mblock_init</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">void</span> *mem, <span class="type">int</span> blk_size, <span class="type">int</span> cnt, <span class="type">nlocker_type_t</span> locker_type)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于初始化定长内存块管理器：</p>
<ol>
<li>将传入的内存区域 <code>mem</code> 按照 <code>blk_size</code> 划分为 <code>cnt</code> 个固定大小的内存块，并将这些块使用链表 <code>free_list</code> 连接起来。</li>
<li>初始化互斥锁 <code>locker</code>，用于保护对 <code>free_list</code> 的并发访问。</li>
<li>如果 <code>locker_type</code> 表示需要多线程支持，就创建分配信号量 <code>alloc_sem</code>，用于在没有空闲块时的等待。</li>
</ol>
<h3 id="分配函数-mblock-alloc"><a href="#分配函数-mblock-alloc" class="headerlink" title="分配函数 mblock_alloc"></a>分配函数 <code>mblock_alloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mblock_alloc</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">int</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于从管理的内存块中分配一个空闲块：</p>
<ol>
<li>如果 <code>ms &lt; 0</code> 或者管理器未使用锁（即 <code>locker.type == NLOCKER_NONE</code>），则直接查询空闲块数量。</li>
<li>如果有等待信号量，使用 <code>sys_sem_wait</code> 等待空闲块的释放。</li>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，从链表头部取出一个空闲块。</li>
<li>返回分配的空闲块地址。</li>
</ol>
<h3 id="空闲块数量查询函数-mblock-free-cnt"><a href="#空闲块数量查询函数-mblock-free-cnt" class="headerlink" title="空闲块数量查询函数 mblock_free_cnt"></a>空闲块数量查询函数 <code>mblock_free_cnt</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mblock_free_cnt</span><span class="params">(<span class="type">mblock_t</span> *mblock)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于获取当前空闲块的数量：</p>
<ol>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，获取链表中当前空闲块的数量。</li>
<li>返回空闲块数量。</li>
</ol>
<h3 id="释放函数-mblock-free"><a href="#释放函数-mblock-free" class="headerlink" title="释放函数 mblock_free"></a>释放函数 <code>mblock_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_free</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">void</span> *block)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于释放先前分配的空闲块：</p>
<ol>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，将要释放的空闲块插入到链表的尾部。</li>
<li>如果存在等待信号量，使用 <code>sys_sem_notify</code> 通知等待的线程有新的空闲块可用。</li>
</ol>
<h3 id="销毁函数-mblock-destroy"><a href="#销毁函数-mblock-destroy" class="headerlink" title="销毁函数 mblock_destroy"></a>销毁函数 <code>mblock_destroy</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_destroy</span><span class="params">(<span class="type">mblock_t</span> *mblock)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于销毁内存块管理器：</p>
<ol>
<li>如果存在分配信号量 <code>alloc_sem</code>，释放该信号量。</li>
<li>销毁互斥锁 <code>locker</code>。</li>
<li>注意：该函数不会释放内存块本身，需要调用者负责管理 <code>mem</code> 的释放。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>定长内存块管理器通过互斥锁和信号量保证了在多线程环境下的安全操作，有效地管理和利用固定大小的内存块，避免了内存碎片和资源竞争问题。每个操作都经过严格的同步控制，确保了对内存块的分配和释放的正确性和高效性。</p>
<h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">mblock_t</span> blist;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">100</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *temp[<span class="number">10</span>];</span><br><span class="line">	mblock_init(&amp;blist, buffer, <span class="number">100</span>, <span class="number">10</span>, NLOCKER_THREAD);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		temp[i] = mblock_alloc(&amp;blist, <span class="number">0</span>);</span><br><span class="line">        plat_printf(<span class="string">&quot;block: %p, free_count: %d\n&quot;</span>, temp[i], mblock_free_cnt(&amp;blist));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		mblock_free(&amp;blist, temp[i]);</span><br><span class="line">		plat_printf(<span class="string">&quot;after free, free_count: %d\n&quot;</span>, mblock_free_cnt(&amp;blist));</span><br><span class="line">	&#125;</span><br><span class="line">	mblock_destroy(&amp;blist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091756328.png" alt="image-20240709175656172"></p>
<h1 id="五、定长消息队列的实现"><a href="#五、定长消息队列的实现" class="headerlink" title="五、定长消息队列的实现"></a>五、定长消息队列的实现</h1><h2 id="1、协议栈中涉及定长消息队列的部分"><a href="#1、协议栈中涉及定长消息队列的部分" class="headerlink" title="1、协议栈中涉及定长消息队列的部分"></a>1、协议栈中涉及定长消息队列的部分</h2><p>消息队列主要用在两个地方：</p>
<ol>
<li>工作线程，接收来自应用程序或网卡的消息；</li>
<li>网卡部分，涉及输入队列和输出队列，放置需要发送的数据包。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111015126.png" alt="image-20240711101556780" style="zoom: 50%;" />

<h2 id="2、fixq-c"><a href="#2、fixq-c" class="headerlink" title="2、fixq.c"></a>2、fixq.c</h2><p>定长消息队列的实现在多线程环境中非常关键，它能有效地管理有限的资源，避免资源耗尽和竞争条件。让我们来分析一下定长消息队列的具体实现：</p>
<h3 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fixq_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">// 消息队列空闲单元长度</span></span><br><span class="line">    <span class="type">int</span> in, out;            <span class="comment">// 写入/读取时的索引位置</span></span><br><span class="line">    <span class="type">int</span> cnt;                <span class="comment">// 消息队列的当前消息个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> **buf;             <span class="comment">// 消息结构数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">nlocker_t</span> locker;       <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sys_sem_t</span> recv_sem;     <span class="comment">// 读信号量</span></span><br><span class="line">    <span class="type">sys_sem_t</span> send_sem;     <span class="comment">// 写信号量</span></span><br><span class="line">&#125; <span class="type">fixq_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>: 消息队列的大小，即可以容纳的消息数量。</li>
<li><code>in</code>, <code>out</code>: 写入和读取消息的索引位置，循环使用以节约空间。</li>
<li><code>cnt</code>: 当前消息队列中的消息个数。</li>
<li><code>buf</code>: 指向存储消息的数组。</li>
<li><code>locker</code>: 用于保护消息队列的互斥锁。</li>
<li><code>recv_sem</code>, <code>send_sem</code>: 分别用于控制读和写的信号量。</li>
</ul>
<h3 id="初始化函数-fixq-init"><a href="#初始化函数-fixq-init" class="headerlink" title="初始化函数 fixq_init"></a>初始化函数 <code>fixq_init</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">fixq_init</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">void</span> **buf, <span class="type">int</span> size, <span class="type">nlocker_type_t</span> type)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于初始化定长消息队列：</p>
<ol>
<li>初始化互斥锁 <code>locker</code>，确保在多线程环境下对队列操作的原子性和互斥性。</li>
<li>创建两个信号量 <code>recv_sem</code> 和 <code>send_sem</code>，用于控制读和写操作的同步，确保队列空间和消息的正确使用。</li>
<li>将外部传入的消息缓冲区 <code>buf</code> 和队列大小 <code>size</code> 赋值给消息队列结构体。</li>
</ol>
<h3 id="发送函数-fixq-send"><a href="#发送函数-fixq-send" class="headerlink" title="发送函数 fixq_send"></a>发送函数 <code>fixq_send</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">fixq_send</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">void</span> *msg, <span class="type">int</span> tmo)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于向消息队列中发送消息 <code>msg</code>：</p>
<ol>
<li>首先通过互斥锁 <code>locker</code> 确保对队列操作的互斥性。</li>
<li>判断消息队列是否已满，如果满且超时参数 <code>tmo</code> 小于 0，则返回 <code>NET_ERR_FULL</code> 表示队列已满且不等待。</li>
<li>使用写信号量 <code>send_sem</code> 等待有空闲单元可以写入。</li>
<li>通过互斥锁再次确认队列未满，将消息写入队列，并更新索引和计数器。</li>
<li>发送完毕后，通过读信号量 <code>recv_sem</code> 通知其他线程有新消息可读取。</li>
</ol>
<h3 id="接收函数-fixq-recv"><a href="#接收函数-fixq-recv" class="headerlink" title="接收函数 fixq_recv"></a>接收函数 <code>fixq_recv</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">fixq_recv</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">int</span> tmo)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于从消息队列中接收消息：</p>
<ol>
<li>首先通过互斥锁 <code>locker</code> 确保对队列操作的互斥性。</li>
<li>如果队列为空且超时参数 <code>tmo</code> 小于 0，则立即返回 <code>NULL</code> 表示超时或队列为空。</li>
<li>使用读信号量 <code>recv_sem</code> 等待有消息可读。</li>
<li>通过互斥锁再次确认队列非空，从队列中读取消息，并更新索引和计数器。</li>
<li>接收完毕后，通过写信号量 <code>send_sem</code> 通知其他线程有空闲空间可以写入新消息。</li>
</ol>
<h3 id="销毁函数-fixq-destroy"><a href="#销毁函数-fixq-destroy" class="headerlink" title="销毁函数 fixq_destroy"></a>销毁函数 <code>fixq_destroy</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fixq_destroy</span><span class="params">(<span class="type">fixq_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于销毁消息队列：</p>
<ol>
<li>销毁互斥锁 <code>locker</code>。</li>
<li>释放读信号量 <code>recv_sem</code> 和写信号量 <code>send_sem</code>。</li>
<li>不会释放消息缓冲区 <code>buf</code>，因为它是外部传入的，由外部管理。</li>
</ol>
<h3 id="计数函数-fixq-count"><a href="#计数函数-fixq-count" class="headerlink" title="计数函数 fixq_count"></a>计数函数 <code>fixq_count</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fixq_count</span><span class="params">(<span class="type">fixq_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于获取当前消息队列中的消息个数：</p>
<ol>
<li>使用互斥锁 <code>locker</code> 锁定，获取 <code>cnt</code> 计数器的值。</li>
<li>返回当前消息个数。</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>定长消息队列通过互斥锁和信号量确保了多线程环境下对队列操作的安全性和同步性，避免了竞争条件和资源冲突。每个操作函数都在操作前后使用互斥锁进行保护，并利用信号量进行同步控制，保证了队列的正确操作顺序和状态。</p>
<blockquote>
<p>定长消息队列依赖定长内存块来管理消息的存储。每当需要<strong>发送一个消息</strong>时，消息队列会向内存块管理器申请一个空闲的内存块来存储该消息。当<strong>消息处理完毕后</strong>，消息队列会将该内存块释放回内存块管理器，以便再次利用。</p>
</blockquote>
<h1 id="六、网络数据包结构设计"><a href="#六、网络数据包结构设计" class="headerlink" title="六、网络数据包结构设计"></a>六、网络数据包结构设计</h1><h2 id="1、网络数据包的具体设计"><a href="#1、网络数据包的具体设计" class="headerlink" title="1、网络数据包的具体设计"></a>1、网络数据包的具体设计</h2><p>当协议栈连接网络后，将接收到来自网络的各种不同大小的数据包，应用程序也会发送各种不同大小的数据包，长度从几字节到几十 KB 不等。若全部采用定长的数据包来存储，较为死板；而如果采用动态分配的方式，则会产生大量的内部碎片。因此借鉴 FAT32 文件系统的文件管理方式，采用<strong>链式存储</strong>的方式管理数据包。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111625628.png" alt="image-20240711162533261"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="添加包头和移除包头"><a href="#添加包头和移除包头" class="headerlink" title="添加包头和移除包头"></a>添加包头和移除包头</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111628778.png" alt="image-20240711162806417"></p>
<h4 id="对数据包中的任意位置进行读写"><a href="#对数据包中的任意位置进行读写" class="headerlink" title="对数据包中的任意位置进行读写"></a>对数据包中的任意位置进行读写</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111628400.png" alt="image-20240711162830179" style="zoom:50%;" />

<h4 id="调整大小、合并数据包"><a href="#调整大小、合并数据包" class="headerlink" title="调整大小、合并数据包"></a>调整大小、合并数据包</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111629556.png" alt="image-20240711162910344" style="zoom: 33%;" />

<h3 id="数据包整体框图"><a href="#数据包整体框图" class="headerlink" title="数据包整体框图"></a>数据包整体框图</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121512637.png" alt="数据包"></p>
<p>尾插法方式分配块列表：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121521391.png" alt="image-20240712152100299"></p>
<p>头插法方式分配块列表：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121601312.png" alt="image-20240712160144214"></p>
<h2 id="2、基本操作1：添加包头和移除包头"><a href="#2、基本操作1：添加包头和移除包头" class="headerlink" title="2、基本操作1：添加包头和移除包头"></a>2、基本操作1：添加包头和移除包头</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407112011374.png" alt="image-20240711201125051"></p>
<p>针对这两种不同的建立快链表的方式，选择<strong>头插法</strong>建立链表。这样做<strong>可以给包头预留空间，方便以后直接添加包头</strong>。这样做就不必频繁分配包头的空间，可以直接利用头部的未用空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407112014885.png" alt="image-20240711201455593"></p>
<p>为了便于后续访问，需要保证包头的数据在一片连续的内存空间里。有两种添加包头的方式如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121633164.png" alt="image-20240712163322897" style="zoom: 50%;" />

<p>有两种移除包头的方式如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407152042855.png" alt="image-20240715204230597" style="zoom:50%;" />

<h3 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pktbuf_test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pktbuf_t</span> *buf = pktbuf_alloc(<span class="number">2000</span>);</span><br><span class="line">    pktbuf_free(buf);</span><br><span class="line"></span><br><span class="line">    buf = pktbuf_alloc(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">        pktbuf_add_header(buf, <span class="number">33</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">        pktbuf_remove_header(buf, <span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 16 次分配结束，最后的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121700168.png" alt="image-20240712170041116"></p>
<p>再经过 16 次移除操作后，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407152054734.png" alt="image-20240715205416671"></p>
<h2 id="3、基本操作2：调整大小、合并数据包"><a href="#3、基本操作2：调整大小、合并数据包" class="headerlink" title="3、基本操作2：调整大小、合并数据包"></a>3、基本操作2：调整大小、合并数据包</h2><h3 id="3-1-扩大包"><a href="#3-1-扩大包" class="headerlink" title="3.1 扩大包"></a>3.1 扩大包</h3><p>当需要扩大包的大小时，只需要在尾部增加空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162021536.png" alt="image-20240716202102118" style="zoom:50%;" />

<p>测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf = pktbuf_alloc(<span class="number">8</span>);</span><br><span class="line">pktbuf_resize(buf, <span class="number">32</span>);</span><br><span class="line">pktbuf_resize(buf, <span class="number">288</span>);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162025444.png" alt="image-20240716202558358"></p>
<h3 id="3-2-缩小包"><a href="#3-2-缩小包" class="headerlink" title="3.2 缩小包"></a>3.2 缩小包</h3><p>当需要缩小包的大小时，只需要在尾部缩减空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162026756.png" alt="image-20240716202655517" style="zoom:50%;" />

<p>测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pktbuf_resize(buf, <span class="number">288</span>);</span><br><span class="line">pktbuf_resize(buf, <span class="number">32</span>);</span><br><span class="line">pktbuf_resize(buf, <span class="number">8</span>);</span><br><span class="line">pktbuf_resize(buf, <span class="number">0</span>);</span><br><span class="line">pktbuf_free(buf);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162103952.png" alt="image-20240716210341806"></p>
<h3 id="3-3-合并数据包"><a href="#3-3-合并数据包" class="headerlink" title="3.3 合并数据包"></a>3.3 合并数据包</h3><p>在做 IP 数据分片的重组时，需要将多个小的数据包合并成一个大的数据包。</p>
<p><strong>此处仅做简单的拼接，而不考虑内部的内存连续性。</strong>举例说明：下图中仅将数据区 3 所在的数据块直接和前面的数据块拼接起来，而不考虑这二者之间的数据可以进行重写，以实现内存上的连续分布。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162108092.png" alt="image-20240716210807765" style="zoom:50%;" />

<p>测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf = pktbuf_alloc(<span class="number">689</span>);</span><br><span class="line"><span class="type">pktbuf_t</span> *sbuf = pktbuf_alloc(<span class="number">892</span>);</span><br><span class="line">pktbuf_join(buf, sbuf);</span><br><span class="line">pktbuf_free(buf);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162115524.png" alt="image-20240716211522364"></p>
<h3 id="3-4-调整包头的连续性"><a href="#3-4-调整包头的连续性" class="headerlink" title="3.4 调整包头的连续性"></a>3.4 调整包头的连续性</h3><p>在接收数据的过程中，可能会遇到包头非连续的情况，此时需要进行调整，以便程序解析包头信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162138521.png" alt="image-20240716213842272" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整包头连续性</span></span><br><span class="line">buf = pktbuf_alloc(<span class="number">32</span>);</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">4</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">16</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">54</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">32</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">38</span>));</span><br><span class="line"></span><br><span class="line">pktbuf_set_cont(buf, <span class="number">44</span>);</span><br><span class="line">pktbuf_set_cont(buf, <span class="number">60</span>);</span><br><span class="line">pktbuf_set_cont(buf, <span class="number">128</span>);</span><br><span class="line">pktbuf_set_cont(buf, <span class="number">135</span>);</span><br><span class="line">pktbuf_free(buf);</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">check buf 000000000040F660: size 32</span><br><span class="line">0: Head Free: 96 b, Used: 32 b, Tail Free: 0 b, </span><br><span class="line">check buf 000000000040F690: size 4</span><br><span class="line">0: Head Free: 124 b, Used: 4 b, Tail Free: 0 b, </span><br><span class="line">info(pktbuf.c-pktbuf_join-477):<span class="built_in">join</span> result:</span><br><span class="line">check buf 000000000040F660: size 36</span><br><span class="line">0: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F6C0: size 16</span><br><span class="line">0: Head Free: 112 b, Used: 16 b, Tail Free: 0 b, </span><br><span class="line">info(pktbuf.c-pktbuf_join-477):<span class="built_in">join</span> result:</span><br><span class="line">check buf 000000000040F660: size 52</span><br><span class="line">0: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F6F0: size 54</span><br><span class="line">0: Head Free: 74 b, Used: 54 b, Tail Free: 0 b, </span><br><span class="line">info(pktbuf.c-pktbuf_join-477):<span class="built_in">join</span> result:</span><br><span class="line">check buf 000000000040F660: size 106</span><br><span class="line">0: Head Free: 74 b, Used: 54 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F720: size 32</span><br><span class="line">0: Head Free: 96 b, Used: 32 b, Tail Free: 0 b, </span><br><span class="line">info(pktbuf.c-pktbuf_join-477):<span class="built_in">join</span> result:</span><br><span class="line">check buf 000000000040F660: size 138</span><br><span class="line">0: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 74 b, Used: 54 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">4: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F750: size 38</span><br><span class="line">0: Head Free: 90 b, Used: 38 b, Tail Free: 0 b, </span><br><span class="line">info(pktbuf.c-pktbuf_join-477):<span class="built_in">join</span> result:</span><br><span class="line">check buf 000000000040F660: size 176</span><br><span class="line">0: Head Free: 90 b, Used: 38 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 74 b, Used: 54 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">4: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">5: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F660: size 176</span><br><span class="line">0: Head Free: 0 b, Used: 44 b, Tail Free: 84 b,</span><br><span class="line">1: Head Free: 102 b, Used: 26 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 74 b, Used: 54 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">4: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">5: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F660: size 176</span><br><span class="line">0: Head Free: 0 b, Used: 60 b, Tail Free: 68 b,</span><br><span class="line">1: Head Free: 118 b, Used: 10 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 74 b, Used: 54 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 112 b, Used: 16 b, Tail Free: 0 b,</span><br><span class="line">4: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">5: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">check buf 000000000040F660: size 176</span><br><span class="line">0: Head Free: 0 b, Used: 128 b, Tail Free: 0 b,</span><br><span class="line">1: Head Free: 116 b, Used: 12 b, Tail Free: 0 b,</span><br><span class="line">2: Head Free: 124 b, Used: 4 b, Tail Free: 0 b,</span><br><span class="line">3: Head Free: 96 b, Used: 32 b, Tail Free: 0 b,</span><br><span class="line">error(pktbuf.c-pktbuf_set_cont-495):size too big &gt; 128</span><br></pre></td></tr></table></figure>

<h2 id="4、基本操作3：对数据包中的任意位置进行读写"><a href="#4、基本操作3：对数据包中的任意位置进行读写" class="headerlink" title="4、基本操作3：对数据包中的任意位置进行读写"></a>4、基本操作3：对数据包中的任意位置进行读写</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162152133.png" alt="image-20240716215221062"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407162154262.png" alt="image-20240716215426161"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写相关测试</span></span><br><span class="line">buf = pktbuf_alloc(<span class="number">32</span>);</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">4</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">16</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">54</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">32</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">38</span>));</span><br><span class="line">pktbuf_join(buf, pktbuf_alloc(<span class="number">512</span>));</span><br><span class="line"></span><br><span class="line">pktbuf_reset_acc(buf);</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> temp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    temp[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">pktbuf_write(buf, (<span class="type">uint8_t</span> *)temp, pktbuf_total(buf));</span><br><span class="line"><span class="comment">// pktbuf_write(buf, (uint8_t *)temp, pktbuf_total(buf));</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> read_temp[<span class="number">1000</span>];</span><br><span class="line">plat_memset(read_temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_temp));</span><br><span class="line"></span><br><span class="line">pktbuf_reset_acc(buf);  <span class="comment">// 调整pos指针</span></span><br><span class="line">pktbuf_read(buf, (<span class="type">uint8_t</span> *)read_temp, pktbuf_total(buf));</span><br><span class="line"><span class="keyword">if</span> (plat_memcmp(temp, read_temp, pktbuf_total(buf)) != <span class="number">0</span>) &#123;</span><br><span class="line">    plat_printf(<span class="string">&quot;not equal&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位读写，不超过1个块</span></span><br><span class="line">plat_memset(read_temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_temp));</span><br><span class="line">pktbuf_seek(buf, <span class="number">18</span> * <span class="number">2</span>);</span><br><span class="line">pktbuf_read(buf, (<span class="type">uint8_t</span>*)read_temp, <span class="number">56</span>);</span><br><span class="line"><span class="keyword">if</span> (plat_memcmp(temp + <span class="number">18</span>, read_temp, <span class="number">56</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not equal.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位跨一个块的读写测试, 从170开始读，读56</span></span><br><span class="line">plat_memset(read_temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_temp));</span><br><span class="line">pktbuf_seek(buf, <span class="number">85</span> * <span class="number">2</span>);</span><br><span class="line">pktbuf_read(buf, (<span class="type">uint8_t</span>*)read_temp, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">if</span> (plat_memcmp(temp + <span class="number">85</span>, read_temp, <span class="number">256</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not equal.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据的复制</span></span><br><span class="line"><span class="type">pktbuf_t</span>* dest = pktbuf_alloc(<span class="number">1024</span>);</span><br><span class="line">pktbuf_seek(buf, <span class="number">200</span>);  <span class="comment">// 从200处开始读</span></span><br><span class="line">pktbuf_seek(dest, <span class="number">600</span>);  <span class="comment">// 从600处开始写</span></span><br><span class="line">pktbuf_copy(dest, buf, <span class="number">122</span>);  <span class="comment">// 复制122个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定位到600处开始读</span></span><br><span class="line">plat_memset(read_temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_temp));</span><br><span class="line">pktbuf_seek(dest, <span class="number">600</span>);  <span class="comment">// 重新回到600的位置</span></span><br><span class="line">pktbuf_read(dest, (<span class="type">uint8_t</span>*)read_temp, <span class="number">122</span>);  <span class="comment">// 读122个字节</span></span><br><span class="line"><span class="keyword">if</span> (plat_memcmp(temp + <span class="number">100</span>, read_temp, <span class="number">122</span>) != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// temp+100，实际定位到200字节偏移处</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not equal.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充测试</span></span><br><span class="line">pktbuf_seek(dest, <span class="number">0</span>);</span><br><span class="line">pktbuf_fill(dest, <span class="number">53</span>, pktbuf_total(dest));</span><br><span class="line"></span><br><span class="line">plat_memset(read_temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_temp));</span><br><span class="line">pktbuf_seek(dest, <span class="number">0</span>);</span><br><span class="line">pktbuf_read(dest, (<span class="type">uint8_t</span>*)read_temp, pktbuf_total(dest));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pktbuf_total(dest); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uint8_t</span> *)read_temp)[i] != <span class="number">53</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not equal.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pktbuf_free(dest);</span><br><span class="line">pktbuf_free(buf);  <span class="comment">// 可以进去调试，在退出函数前看下所有块是否全部释放完毕</span></span><br></pre></td></tr></table></figure>

<h2 id="5、pktbuf-c"><a href="#5、pktbuf-c" class="headerlink" title="5、pktbuf.c"></a>5、pktbuf.c</h2><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><ul>
<li><strong>pktblk_t</strong>: 表示一个数据块，包括数据指针和大小等信息。</li>
<li><strong>pktbuf_t</strong>: 表示一个数据包，由多个数据块组成，包含数据包的总大小和当前操作的位置等信息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据块</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pktblk_t</span> &#123;</span></span><br><span class="line">    <span class="type">nlist_node_t</span> node;                  <span class="comment">// 指向下一个数据块</span></span><br><span class="line">    <span class="type">int</span> size;                           <span class="comment">// 数据块大小</span></span><br><span class="line">    <span class="type">uint8_t</span> *data;                      <span class="comment">// 当前读写位置</span></span><br><span class="line">    <span class="type">uint8_t</span> payload[PKTBUF_BLK_SIZE];   <span class="comment">// 数据缓冲区</span></span><br><span class="line">&#125;<span class="type">pktblk_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pktbuf_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> total_size;         <span class="comment">// 所有数据块中的总数据大小</span></span><br><span class="line">    <span class="type">nlist_t</span> blk_list;       <span class="comment">// 数据块链</span></span><br><span class="line">    <span class="type">nlist_node_t</span> node;      <span class="comment">// 指向下一个数据包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写相关</span></span><br><span class="line">    <span class="type">int</span> ref;                <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> pos;                <span class="comment">// 当前位置总的偏移量</span></span><br><span class="line">    <span class="type">pktblk_t</span> *curr_blk;     <span class="comment">// 当前指向的数据块</span></span><br><span class="line">    <span class="type">uint8_t</span> *blk_offset;    <span class="comment">// 在当前数据块中的偏移量</span></span><br><span class="line">&#125;<span class="type">pktbuf_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化函数 <code>pktbuf_init()</code> 主要用于初始化内存块和数据包缓冲区的空闲列表，并初始化锁。它调用 <code>mblock_init</code> 函数对空闲块列表和空闲包列表进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">pktbuf_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dbg_info(DBG_BUF, <span class="string">&quot;init pktbuf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nlocker_init(&amp;locker, NLOCKER_THREAD);</span><br><span class="line">    mblock_init(&amp;block_list, block_buffer, <span class="keyword">sizeof</span>(<span class="type">pktblk_t</span>), PKTBUF_BLK_CNT, NLOCKER_THREAD);</span><br><span class="line">    mblock_init(&amp;pktbuf_list, pktbuf_buffer, <span class="keyword">sizeof</span>(<span class="type">pktbuf_t</span>), PKTBUF_BUF_CNT, NLOCKER_THREAD);</span><br><span class="line"></span><br><span class="line">    dbg_info(DBG_BUF, <span class="string">&quot;init done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NET_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据块管理"><a href="#数据块管理" class="headerlink" title="数据块管理"></a>数据块管理</h3><h4 id="分配数据块"><a href="#分配数据块" class="headerlink" title="分配数据块"></a>分配数据块</h4><p>分配数据块的函数 <code>pktblk_alloc()</code>，从空闲块列表中获取一个数据块，并初始化其数据指针和大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pktblk_alloc() -&gt; <span class="type">pktblk_t</span>* blk = mblock_alloc(&amp;block_list, <span class="number">-1</span>);</span><br><span class="line">			   -&gt; 设置 blk 初始值</span><br></pre></td></tr></table></figure>

<h4 id="释放数据块"><a href="#释放数据块" class="headerlink" title="释放数据块"></a>释放数据块</h4><p>释放数据块的函数 <code>pktblk_free()</code>，将数据块放回空闲块列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pktblk_free() -&gt; mblock_free(&amp;block_list, blk);</span><br></pre></td></tr></table></figure>

<h3 id="数据包管理"><a href="#数据包管理" class="headerlink" title="数据包管理"></a>数据包管理</h3><h4 id="分配数据包"><a href="#分配数据包" class="headerlink" title="分配数据包"></a>分配数据包</h4><p>分配数据块的函数 <code>pktblk_alloc()</code>，从空闲块列表中获取一个数据块，并初始化其数据指针和大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pktbuf_alloc() -&gt; <span class="type">pktbuf_t</span>* buf = mblock_alloc(&amp;pktbuf_list, <span class="number">-1</span>);</span><br><span class="line">			   -&gt; 设置 buf 初始值</span><br><span class="line">               -&gt; pktblk_alloc_list() -&gt; pktbuf_insert_blk_list()</span><br></pre></td></tr></table></figure>

<h4 id="释放数据包"><a href="#释放数据包" class="headerlink" title="释放数据包"></a>释放数据包</h4><p>释放数据块的函数 <code>pktbuf_free()</code>，将数据块放回空闲块列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pktbuf_free() -&gt; pktblk_list_free() -&gt; pktblk_free</span><br><span class="line">    	      -&gt; mblock_free(&amp;pktbuf_list, buf);</span><br></pre></td></tr></table></figure>

<h3 id="包头操作"><a href="#包头操作" class="headerlink" title="包头操作"></a>包头操作</h3><h4 id="添加包头"><a href="#添加包头" class="headerlink" title="添加包头"></a>添加包头</h4><p>函数 <code>pktbuf_add_header(pktbuf_t *buf, int size, int cont)</code> 用于在数据包的头部添加指定大小的包头，支持连续和非连续的添加方式。</p>
<h4 id="移除包头"><a href="#移除包头" class="headerlink" title="移除包头"></a>移除包头</h4><p>函数 <code>pktbuf_remove_header(pktbuf_t *buf, int size)</code> 用于移除数据包头部的指定大小的数据。</p>
<h3 id="数据包大小调整"><a href="#数据包大小调整" class="headerlink" title="数据包大小调整"></a>数据包大小调整</h3><p>函数 <code>pktbuf_resize(pktbuf_t *buf, int to_size)</code> 用于调整数据包的大小。</p>
<h3 id="数据包合并"><a href="#数据包合并" class="headerlink" title="数据包合并"></a>数据包合并</h3><p>函数 <code>pktbuf_join(pktbuf_t *dst, pktbuf_t *src)</code> 用于将源数据包 <code>src</code> 合并到目标数据包 <code>dst</code> 中。</p>
<h3 id="内存块检查"><a href="#内存块检查" class="headerlink" title="内存块检查"></a>内存块检查</h3><p>函数 <code>display_check_buf(pktbuf_t *buf)</code> 用于检查数据包内存块是否正确，主要用于调试。</p>
<h1 id="七、网络接口层"><a href="#七、网络接口层" class="headerlink" title="七、网络接口层"></a>七、网络接口层</h1><p>作用：</p>
<ol>
<li>将 IP 模块传来的数据包发送出去；</li>
<li>接收网络数据包并交给 IP 模块处理。</li>
</ol>
<p>在实际应用中，计算机硬件上往往存在多个网络接口，因此协议栈需要同时支持多个网络接口，支持不同类型的链路层通信。本课程主要涉及<strong>基于有线的以太网链路通信</strong>。同时，在计算机内部还存在着一种虚拟接口：<strong>环回接口</strong>，用于计算机内部程序之间的通信。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407191955839.png" alt="image-20240719195522461"></p>
<p>网络接口的一些<strong>基础特性</strong>：</p>
<ol>
<li>名称</li>
<li>接口类型</li>
<li>硬件地址</li>
<li>IP 地址</li>
<li>掩码</li>
<li>网关</li>
<li>MTU</li>
<li>状态统计</li>
</ol>
<h2 id="1、添加环回接口"><a href="#1、添加环回接口" class="headerlink" title="1、添加环回接口"></a>1、添加环回接口</h2><ul>
<li>为网络接口添加设置 ip 地址的接口；</li>
<li>为环回接口设置 127.0.0.1&#x2F;255.0.0.0</li>
</ul>
<h2 id="2、netif-c"><a href="#2、netif-c" class="headerlink" title="2、netif.c"></a>2、netif.c</h2><h2 id="3、ipaddr-c"><a href="#3、ipaddr-c" class="headerlink" title="3、ipaddr.c"></a>3、ipaddr.c</h2><h2 id="4、loop-c"><a href="#4、loop-c" class="headerlink" title="4、loop.c"></a>4、loop.c</h2><h1 id="八、以太网协议"><a href="#八、以太网协议" class="headerlink" title="八、以太网协议"></a>八、以太网协议</h1><blockquote>
<p>在协议栈中增加对以太网协议的支持，通过网卡收发数据包。</p>
</blockquote>
<h2 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h2><p>以太网协议的主要功能：</p>
<ol>
<li>发送上层传来的 IP 数据包到相邻计算机；</li>
<li>网卡接收数据包，提取出的 IP 数据包上传到上层。</li>
</ol>
<p>以太帧有很多类型，不同类型有不同的格式和 MTU 值，最常见的是 <code>Ethernet ||</code>，<strong>这也是本项目采用的帧类型</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407221537789.png" alt="image-20240722153727212"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407221538672.png" alt="image-20240722153809346"></p>
<h2 id="2、设计步骤"><a href="#2、设计步骤" class="headerlink" title="2、设计步骤"></a>2、设计步骤</h2><ol>
<li>在已经添加环回接口的基础上，使用 <code>pcap</code> 接口添加以太网接口到协议栈中。</li>
<li>在以太网接收线程中接收数据包并写入 <code>pktbuf</code> 中，然后发消息给工作线程。</li>
<li>将从以太网接收到的数据包做简单处理后，通过网络接口发送出去，以测试基本的数据收发流程。</li>
<li>工作线程在收到链接层的数据包之后，需要决定如何处理。不同的链路层有不同的处理方式吗，工作线程需要根据不同协议灵活处理。</li>
<li>在收到链路上的以太网包后，协议栈只需要对包进行简单的检查，移动以太网包头，然后提交给 IP&#x2F;ARP 协议进行处理。为减少工作线程接收到的消息数据，只有在消息队列为空时收到数据后，才给工作线程发消息。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407222013348.png" alt="image-20240722201315837"></p>
<h2 id="3、各种测试"><a href="#3、各种测试" class="headerlink" title="3、各种测试"></a>3、各种测试</h2><p>在虚拟机中执行 <code>ping 192.168.74.255</code>，在 wireshark 中可以看到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407221723084.png" alt="image-20240722172303650"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">info(net.c-net_init-17):init net...</span><br><span class="line">info(net_plat.c-net_plat_init-6):init plat...</span><br><span class="line">info(net_plat.c-net_plat_init-8):init <span class="keyword">done</span>.</span><br><span class="line">info(exmsg.c-exmsg_init-28):exmsg init</span><br><span class="line">info(exmsg.c-exmsg_init-44):init <span class="keyword">done</span></span><br><span class="line">info(pktbuf.c-pktbuf_init-114):init pktbuf</span><br><span class="line">info(pktbuf.c-pktbuf_init-120):init <span class="keyword">done</span></span><br><span class="line">info(netif.c-netif_init-78):init netif</span><br><span class="line">info(netif.c-netif_init-87):init <span class="keyword">done</span>.</span><br><span class="line">info(loop.c-loop_init-52):init loop</span><br><span class="line">netif list:</span><br><span class="line">loop: opened  loop  mtu=0</span><br><span class="line">        mac:00-00-00-00-00-00</span><br><span class="line">  ip:0.0.0.0  netmask:0.0.0.0  gateway:0.0.0.0</span><br><span class="line">netif list:</span><br><span class="line">loop: active  loop  mtu=0</span><br><span class="line">        mac:00-00-00-00-00-00</span><br><span class="line">  ip:127.0.0.1  netmask:255.0.0.0  gateway:0.0.0.0</span><br><span class="line">check buf 0000000000415480: size 100</span><br><span class="line">0: Head Free: 28 b, Used: 100 b, Tail Free: 0 b,</span><br><span class="line">info(loop.c-loop_init-74):init <span class="keyword">done</span></span><br><span class="line">netif list:</span><br><span class="line">loop:recv thread is running...</span><br><span class="line"> active  loop  mtu=0 </span><br><span class="line">        mac:00-00-00-00-00-00</span><br><span class="line">  ip:127.0.0.1  netmask:255.0.0.0  gateway:0.0.0.0</span><br><span class="line">netif 0: opened  ether  mtu=1500</span><br><span class="line">        mac:00-50-56-c0-00-11</span><br><span class="line">  ip:0.0.0.0  netmask:0.0.0.0  gateway:xmit thread is running...</span><br><span class="line">check buf 00000000004154C8: size 74</span><br><span class="line">0: Head Free: 54 b, Used: 74 b, 0.0.0.0</span><br><span class="line">netif list:</span><br><span class="line">loop: active  loop Tail Free: 0 b,</span><br><span class="line"> mtu=0 </span><br><span class="line">check buf 0000000000415510: size 74</span><br><span class="line">0: Head Free: 54 b, Used: 74 b, Tail Free: 0 b,</span><br><span class="line">        mac:00-00-00-00-00-00</span><br><span class="line">  ip:127.0.0.1  netmask:255.0.0.0  gateway:0.0.0.0</span><br><span class="line">netif 0: active  ether  mtu=1500</span><br><span class="line">        mac:00-50-56-c0-00-11</span><br><span class="line">  ip:192.168.74.2  netmask:255.255.255.0  gateway:192.168.74.1</span><br><span class="line">info(net.c-net_start-38):net is running.</span><br><span class="line">info(exmsg.c-work_thread-93):exmsg is running...</span><br><span class="line"></span><br><span class="line">info(exmsg.c-work_thread-103):recieve a msg(00000000004104A0): 0</span><br><span class="line">info(exmsg.c-do_netif_in-81):recv a packet</span><br><span class="line">info(netif.c-netif_get_in-308):netif loop in_q empty</span><br><span class="line">info(exmsg.c-work_thread-103):recieve a msg(00000000004104B0): 0</span><br><span class="line">info(exmsg.c-do_netif_in-81):recv a packet</span><br><span class="line">info(exmsg.c-do_netif_in-81):recv a packet</span><br><span class="line">info(netif.c-netif_get_in-308):netif netif 0 in_q empty</span><br><span class="line">info(exmsg.c-work_thread-103):recieve a msg(00000000004104C0): 0</span><br><span class="line">info(netif.c-netif_get_in-308):netif netif 0 in_q empty</span><br><span class="line">check buf 0000000000415558: size 74</span><br><span class="line">0: Head Free: 54 b, Used: 74 b, Tail Free: 0 b, </span><br><span class="line">info(exmsg.c-work_thread-103):recieve a msg(00000000004104D0): 0</span><br><span class="line">info(exmsg.c-do_netif_in-81):recv a packet</span><br><span class="line">info(netif.c-netif_get_in-308):netif netif 0 in_q empty</span><br><span class="line">check buf 00000000004155A0: size 74</span><br><span class="line">0: Head Free: 54 b, Used: 74 b, Tail Free: 0 b, </span><br><span class="line">info(exmsg.c-work_thread-103):recieve a msg(00000000004104E0): 0</span><br><span class="line">info(exmsg.c-do_netif_in-81):recv a packet</span><br><span class="line">info(netif.c-netif_get_in-308):netif netif 0 in_q empty</span><br></pre></td></tr></table></figure>



<p>注册链表层处理类型：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407222043515.png" alt="image-20240722204345297"></p>
<p>大小端字节序转换：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407222118707.png" alt="image-20240722211804431"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3_C++%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3_C++%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">项目2_C++高性能服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-03 11:16:57 / 修改时间：16:21:51" itemprop="dateCreated datePublished" datetime="2024-07-03T11:16:57+08:00">2024-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>108</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Centos7</p>
<p>GCC 9.1</p>
<p>cmake</p>
<h2 id="项目路径"><a href="#项目路径" class="headerlink" title="项目路径"></a>项目路径</h2><p>bin – 二进制文件</p>
<p>build – 中间文件路径</p>
<p>cmake – cmake函数文件夹</p>
<p>CMakeLists.txt – cmake的定义文件</p>
<p>lib – 库的输出路径</p>
<p>Makefile</p>
<p>sylar – 源代码路径</p>
<p>tests – 测试代码</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="1）Log4J"><a href="#1）Log4J" class="headerlink" title="1）Log4J"></a>1）Log4J</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger(定义日志类别)</span><br><span class="line">    |</span><br><span class="line">    |--------- Formatter(日志格式)</span><br><span class="line">    |</span><br><span class="line">Appender(日志输出地方)</span><br></pre></td></tr></table></figure>



<h2 id="协程库封装"><a href="#协程库封装" class="headerlink" title="协程库封装"></a>协程库封装</h2><h2 id="socket-函数库"><a href="#socket-函数库" class="headerlink" title="socket 函数库"></a>socket 函数库</h2><h2 id="http-协议开发"><a href="#http-协议开发" class="headerlink" title="http 协议开发"></a>http 协议开发</h2><h2 id="分布式协议库"><a href="#分布式协议库" class="headerlink" title="分布式协议库"></a>分布式协议库</h2><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/" class="post-title-link" itemprop="url">项目1_diyx86os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 11:16:42" itemprop="dateCreated datePublished" datetime="2024-07-03T11:16:42+08:00">2024-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-04 16:09:38" itemprop="dateModified" datetime="2024-07-04T16:09:38+08:00">2024-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:24</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、源码测试过程报错"><a href="#一、源码测试过程报错" class="headerlink" title="一、源码测试过程报错"></a>一、源码测试过程报错</h1><p>1、出现报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[build] x86_64-elf-objdump: Dwarf Error: found dwarf version <span class="string">&#x27;7424&#x27;</span>, this reader only handles version 2, 3 and 4 information.</span><br></pre></td></tr></table></figure>

<p>工具链相关错误，可忽略。</p>
<p>2、测试过程中的编译时遇到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</span><br></pre></td></tr></table></figure>

<p>解决：取消勾选“压缩或加密属性”</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png" alt="image-20240508153049493" style="zoom: 67%;" />

<p>3、dd命令不存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;dd if=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 &#x27;dd&#x27; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</span><br></pre></td></tr></table></figure>

<p>在Git的安装路径下找到dd.exe文件，并将对应的bin目录添加到系统变量中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png" alt="image-20240508164113684"></p>
<p>4、调试成功时，终端显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk1.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk1.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk2.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk2.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK1_NAME=disk1.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=disk1.vhd bs=512 conv=notrunc count=1 </span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.009362 s, 54.7 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=loader.bin of=disk1.vhd bs=512 conv=notrunc seek=1 </span><br><span class="line">24+0 records <span class="keyword">in</span></span><br><span class="line">24+0 records out</span><br><span class="line">12288 bytes (12 kB, 12 KiB) copied, 0.0077902 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 </span><br><span class="line">98+1 records <span class="keyword">in</span></span><br><span class="line">98+1 records out</span><br><span class="line">50452 bytes (50 kB, 49 KiB) copied, 0.0353497 s, 1.4 MB/s</span><br><span class="line">83+1 records <span class="keyword">in</span></span><br><span class="line">83+1 records out</span><br><span class="line">42968 bytes (43 kB, 42 KiB) copied, 0.0838259 s, 513 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK2_NAME=disk2.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> TARGET_PATH=k</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> attach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> partition 1  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> assign letter=k  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">  100 百分比已完成</span><br><span class="line"></span><br><span class="line">DiskPart 已成功连接虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">分区 1 现在是所选分区。</span><br><span class="line"></span><br><span class="line">DiskPart 成功地分配了驱动器号或装载点。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;attach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;copy /Y *.elf k:\</span><br><span class="line">init.elf</span><br><span class="line">kernel.elf</span><br><span class="line">loop.elf</span><br><span class="line">shell.elf</span><br><span class="line">snake.elf</span><br><span class="line">已复制         5 个文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> detach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DiskPart 已成功分离虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;detach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt  </span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br><span class="line"> *  正在执行任务: D:\PostGraduate\cppex\diyx86os\start\<span class="built_in">test</span>/script/qemu-debug-win.bat </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、引导程序：接管控制权"><a href="#二、引导程序：接管控制权" class="headerlink" title="二、引导程序：接管控制权"></a>二、引导程序：接管控制权</h1><h2 id="2-1-计算机启动流程简介"><a href="#2-1-计算机启动流程简介" class="headerlink" title="2.1 计算机启动流程简介"></a>2.1 计算机启动流程简介</h2><p>从上电到运行计算机经历了什么？</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png" alt="image-20240508165407603"></p>
<p><code>BIOS</code>：基本输入输出系统。固化在flash芯片上。</p>
<p><strong>BIOS程序由硬件自己控制，本项目编写自己的引导代码和操作系统代码。</strong></p>
<p><code>disk1</code>是<code>qemu</code>的启动硬盘，<code>qemu</code>启动时会从磁盘最开始取<code>512</code>字节。</p>
<p><code>BIOS</code>在加载引导代码时，会根据用户的配置选择从磁盘加载还是从软盘加载，整个课程处理从磁盘加载的情况。</p>
<h2 id="2-2-接管计算机运行控制权"><a href="#2-2-接管计算机运行控制权" class="headerlink" title="2.2 接管计算机运行控制权"></a>2.2 接管计算机运行控制权</h2><p>硬盘的分类：</p>
<ul>
<li><p>机械硬盘：包含电机。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png" alt="image-20240508195742085"></p>
</li>
<li><p>固态硬盘：容量小但速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png" alt="image-20240508195937467"></p>
</li>
</ul>
<p>启动时，<code>BIOS</code>会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。即只需要将程序放在第<code>0</code>号扇区，就会自动被加载到内存中运行。完成从<code>BIOS</code>程序到引导程序的跳转过程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png" alt="image-20240508201149042"></p>
<p>在<code>vscode</code>中以十六进制编辑器模式打开<code>disk1.vhd</code>，在<code>000001F0</code>处（即第<code>0</code>号扇区的最后两个字节）可看到<code>1FE:0x55</code>, <code>1FF:0xAA</code>，即为上图所示的两个引导标志所在位置。只有这两个引导标志正确时，<code>BIOS</code>才会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png" alt="image-20240508200825616"></p>
<p>此时，若将<code>55/AA</code>进行改动，并重新启动<code>qemu</code>，操作系统将无法被正常启动，会显示如下结果：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png" alt="image-20240508200958280" style="zoom:67%;" />

<p><strong>为简化，本项目不考虑引导过程中一个磁盘包含多个分区的情况。</strong></p>
<h2 id="2-3-创建可引导的启动程序"><a href="#2-3-创建可引导的启动程序" class="headerlink" title="2.3 创建可引导的启动程序"></a>2.3 创建可引导的启动程序</h2><h3 id="1-整体的项目逻辑"><a href="#1-整体的项目逻辑" class="headerlink" title="1. 整体的项目逻辑"></a>1. 整体的项目逻辑</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-.vscode</span><br><span class="line">	- launch.json	// GDB调试相关信息</span><br><span class="line">	- settings.json</span><br><span class="line">	- tasks.json	// 定义[终端-运行任务]中的相关任务</span><br><span class="line">	</span><br><span class="line">// 定义了[终端-运行任务]中相关任务的命令脚本</span><br><span class="line">- script	</span><br><span class="line"></span><br><span class="line">// 包含若干个子工程</span><br><span class="line">- <span class="built_in">source</span>			</span><br><span class="line">    - applib		// 系统调用库</span><br><span class="line">    - boot			// 引导程序</span><br><span class="line">    - <span class="built_in">comm</span></span><br><span class="line">    - init			// 初始进程</span><br><span class="line">    - kernel		// 操作系统内核</span><br><span class="line">    	- cpu			// 存放cpu相关</span><br><span class="line">    	- include		// 存放头文件</span><br><span class="line">    	- init			// 相关初始化</span><br><span class="line">    - loader		// 加载程序</span><br><span class="line">    - loop			// 应用程序</span><br><span class="line">    - shell			// 命令行应用</span><br><span class="line">    </span><br><span class="line">- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-整体的开发工作流程："><a href="#2-整体的开发工作流程：" class="headerlink" title="2. 整体的开发工作流程："></a>2. 整体的开发工作流程：</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png" alt="image-20240508203408507" style="zoom:150%;" />

<h2 id="2-4-初始化引导程序"><a href="#2-4-初始化引导程序" class="headerlink" title="2.4 初始化引导程序"></a>2.4 初始化引导程序</h2><p><strong>主要任务：对boot程序进行简单初始化。</strong></p>
<h3 id="1-什么是引导程序？"><a href="#1-什么是引导程序？" class="headerlink" title="1. 什么是引导程序？"></a>1. 什么是引导程序？</h3><ul>
<li><p>主要用于为操作系统运行初始化运行环境，并加载操作系统运行。</p>
</li>
<li><p><strong>本项目中的引导程序涉及以下三个工作</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png" alt="image-20240508205916747"></p>
</li>
</ul>
<p>由于BIOS只加载磁盘的第0扇区（512字节）到内存中，对于上述功能来说这个代码大小是不够的，因此需要考虑采用扩展程序的办法。</p>
<p>有以下两种方式，<strong>本项目采用方式二</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png" alt="image-20240508210246804"></p>
<h3 id="2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"><a href="#2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。" class="headerlink" title="2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"></a>2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</h3><p>实模式包含以下特点：</p>
<ul>
<li>16位代码</li>
<li>无保护机制</li>
<li>无分页机制</li>
<li>仅使用1MB内存</li>
</ul>
<h3 id="3-x86与编程相关的主要内核寄存器"><a href="#3-x86与编程相关的主要内核寄存器" class="headerlink" title="3. x86与编程相关的主要内核寄存器"></a>3. x86与编程相关的主要内核寄存器</h3><p>   <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png" alt="image-20240508210729628"></p>
<ul>
<li><p>CS&#x2F;DS&#x2F;SS&#x2F;ES&#x2F;FS&#x2F;GS为段寄存器</p>
<ul>
<li><p>当访问特定内存地址时，需要采用<code>段:偏移</code>的形式，即实际地址为<code>段值&lt;&lt;4+偏移</code>。</p>
</li>
<li><p>例如：访问<code>0x7c00</code>，需要使用<code>0x7c0:0</code>，或<code>0:0x7c00</code></p>
</li>
<li><p>注意：初始化段寄存器时无需显示初始化<code>CS</code>。</p>
<blockquote>
<p>在 x86 架构中，CS（Code Segment）寄存器是用于存放代码段的选择子，在实模式下，CS 寄存器的初始化通常由处理器自动完成。</p>
<p>在启动阶段，处理器会将 CS 寄存器设置为默认值，通常为 0xFFFF，这意味着 CS 段选择子为 0xFFFF，代码段的起始地址是 0xFFFF0。这个默认的值使得处理器能够正常从 BIOS 的 ROM 中加载启动代码，并执行第一条指令。因此，在启动阶段，通常不需要显式地设置 CS 寄存器。</p>
<p>相反，通过设置 DS、SS、ES、FS、GS 等段寄存器为 0，可以将默认的段地址 0 应用于数据段、栈段和其他段。这样，CPU 将能够正确访问位于物理地址 0 处的引导程序代码，并且在实模式下，所有的段都共享同一个地址空间，因此 CS 寄存器的设置可以由 CPU 自动处理。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png" alt="image-20240508211028354"></p>
</li>
</ul>
<h3 id="4-实模式下的内存映射（8086）"><a href="#4-实模式下的内存映射（8086）" class="headerlink" title="4. 实模式下的内存映射（8086）"></a>4. 实模式下的内存映射（8086）</h3><ul>
<li><p>其中灰色为可用区域。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png" alt="image-20240508211243702" style="zoom:50%;" /></li>
</ul>
<h2 id="2-5-使用BIOS中断显示字符"><a href="#2-5-使用BIOS中断显示字符" class="headerlink" title="2.5 使用BIOS中断显示字符"></a>2.5 使用BIOS中断显示字符</h2><h3 id="1-如何显示字符？"><a href="#1-如何显示字符？" class="headerlink" title="1. 如何显示字符？"></a>1. 如何显示字符？</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png" alt="image-20240509090652672" style="zoom: 80%;" />

<p>BIOS提供了一组服务，可以方便地帮助我们操纵硬件，避免与硬件细节打交道。</p>
<ul>
<li>当调用<code>INT</code>软中断时，<code>CPU</code>会转到中断向量表处（<code>0x00000000~0x000003FF</code>），从中取出相应的地址位置，取出<code>BIOS</code>程序的入口地址，从而转到<code>BIOS</code>程序中运行。</li>
<li>参数通过寄存器传递。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png" alt="image-20240509090809536" />

<ul>
<li>本项目采用<code>INT 10, AH=0xE</code>显示字符<ul>
<li>该<code>BIOS</code>中断的作用是：显示字符，同时光标前移，其中（寄存器）<code>AL=字符</code>、<code>BL=前景色</code>、<code>BH=页码</code>。</li>
<li>具体来说<ul>
<li><code>BH</code>为目前的显示页。若在图形模式，<code>BH</code>需设置为0；</li>
<li>假如在图形模式下，也可设定<code>BL</code>来表示文字的颜色，文字模式下的<code>BL</code>则无此功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、BIOS-INT-10中断功能"><a href="#2、BIOS-INT-10中断功能" class="headerlink" title="2、BIOS INT 10中断功能"></a>2、BIOS INT 10中断功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28256699/article/details/121103977">BIOS INT 10中断功能详解</a></p>
<h2 id="2-6-使用BIOS中断读取磁盘"><a href="#2-6-使用BIOS中断读取磁盘" class="headerlink" title="2.6 使用BIOS中断读取磁盘"></a>2.6 使用BIOS中断读取磁盘</h2><h3 id="1-怎样完成从Boot加载loader的过程？"><a href="#1-怎样完成从Boot加载loader的过程？" class="headerlink" title="1. 怎样完成从Boot加载loader的过程？"></a>1. 怎样完成从Boot加载loader的过程？</h3><p><code>BIOS</code>提供了磁盘读取的接口，便于从磁盘上读取<code>loader</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png" alt="image-20240509092600575"></p>
<p><strong>本项目的设计是在磁盘的第<code>0</code>号扇区（即<code>Boot</code>程序后）紧挨着放置<code>loader</code>程序。在加载时，考虑将其加载到<code>0x8000</code>处。</strong></p>
<ul>
<li>从磁盘上的第<code>1</code>号扇区开始，读取指定数量的扇区；</li>
<li>将其加载到内存中的指定地址处（<code>0x8000</code>）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png" alt="image-20240509093110267"></p>
<h3 id="2-INT-13磁盘读取"><a href="#2-INT-13磁盘读取" class="headerlink" title="2. INT 13磁盘读取"></a>2. INT 13磁盘读取</h3><p>（1）BIOS提供了磁盘操作的服务中断，其具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口参数								</span></span><br><span class="line">    AH = <span class="number">02</span>H							   						</span><br><span class="line">    AL = 扇区数								 </span><br><span class="line">    CH = 柱面									  </span><br><span class="line">    CL = 扇区								     </span><br><span class="line">    DH = 磁头								 </span><br><span class="line">    DL = 驱动器</span><br><span class="line">      - <span class="number">00</span>H~<span class="number">7F</span>H  ：软盘</span><br><span class="line">      - <span class="number">80</span>H~<span class="number">0F</span>FH ：硬盘</span><br><span class="line">    ES:BX = 缓冲区地址（即要加载到的内存中的地址）</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 出口参数</span></span><br><span class="line">- 若传输成功，	</span><br><span class="line">	CF = <span class="number">0</span></span><br><span class="line">	AH = <span class="number">00</span>H</span><br><span class="line">	AL = 传输的扇区数</span><br><span class="line">- 若传输失败，AH = 状态码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cx=ch:cl</code>（<code>ch</code>占高<code>8</code>位，<code>cl</code>占低<code>8</code>位）。<ul>
<li>因此<code>mov $0x2, %cx</code>相当于直接一步到位，将<code>ch</code>设置为<code>0</code>，<code>cl</code>设置为<code>2</code>。</li>
<li>注意<code>cl</code>为<code>2</code>是因为：<strong>在本项目采用的读取方法下，BIOS认为磁盘的编号是从1开始的。</strong></li>
</ul>
</li>
<li><code>mov $64, %al</code><ul>
<li><code>al</code>为读取的扇区数量，必须小于<code>128</code>，暂设置成<code>32KB</code></li>
<li>因为一个扇区大小是<code>512B</code>，即<code>0.5KB</code>。因此若要暂设成<code>32KB</code>，即相当于<code>64</code>个扇区。</li>
</ul>
</li>
</ul>
<p>（2）运行完成后，将会把磁盘<code>1</code>中的相关内容加载到内存的<code>0x8000</code>处：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png" alt="image-20240509101626325"></p>
<h2 id="2-7-初始化引导程序"><a href="#2-7-初始化引导程序" class="headerlink" title="2.7 初始化引导程序"></a>2.7 初始化引导程序</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png" alt="image-20240509102201895"></p>
<h3 id="1、如何生成loader并写入磁盘映像？"><a href="#1、如何生成loader并写入磁盘映像？" class="headerlink" title="1、如何生成loader并写入磁盘映像？"></a>1、如何生成loader并写入磁盘映像？</h3><h3 id="2、怎样从boot跳转到loader执行？"><a href="#2、怎样从boot跳转到loader执行？" class="headerlink" title="2、怎样从boot跳转到loader执行？"></a>2、怎样从boot跳转到loader执行？</h3><h1 id="三、加载器loader的实现"><a href="#三、加载器loader的实现" class="headerlink" title="三、加载器loader的实现"></a>三、加载器loader的实现</h1><h2 id="3-1-利用内联汇编显示字符串"><a href="#3-1-利用内联汇编显示字符串" class="headerlink" title="3.1 利用内联汇编显示字符串"></a>3.1 利用内联汇编显示字符串</h2><p>用于显示loader加载过程，从而提示加载到哪一步时出现问题。</p>
<h3 id="1、内联汇编理论"><a href="#1、内联汇编理论" class="headerlink" title="1、内联汇编理论"></a>1、内联汇编理论</h3><ul>
<li><p><strong>概述</strong></p>
<p>在开发操作系统过程中，有时必须使用某些特殊的指令（如<code>int/outb/hlt</code>等），而<code>C</code>编译器无法自动使用这些指令。因此，如果要使用这些指令，有两种方式：</p>
<ul>
<li>在汇编文件中为该指令的使用<strong>创建汇编函数（子程序）</strong>，然后在C代码中以函数调用的方式去使用；</li>
<li>使用<strong>内联汇编</strong>，即在C代码中嵌入汇编程序。</li>
</ul>
<p>在大多数情况下，使用内联汇编会更加简单、易用。因此，以下将简要介绍本项目中所用的相关的GCC内联汇编的写法。</p>
</li>
<li><p><strong>基本格式</strong></p>
<p>基本格式如下，以<code>asm</code>关键字开头，包含<code>3</code>个可选的配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(汇编语句</span><br><span class="line"> :输出操作数(可选)</span><br><span class="line"> :输入操作数(可选)</span><br><span class="line"> :被破坏的寄存器列表(可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面举个例子，其功能为将<code>a</code>的值赋值给<code>b</code>，具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %1,%%eax; movl %%eax, %0;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=r&quot;</span>(b)	<span class="comment">/* 输出 */</span></span><br><span class="line">	:<span class="string">&quot;r&quot;</span>(a)		<span class="comment">/* 输入 */</span></span><br><span class="line">	:<span class="string">&quot;%eax&quot;</span>		<span class="comment">/* 破坏寄存器 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其效果等价于<code>movl a, %%eax; movl %%eax, b</code>，即：将<code>a</code>的值先给<code>eax</code>寄存器，再将<code>eax</code>寄存器的值给到<code>b</code>，最终实现<code>b=a</code>的效果。</p>
</li>
<li><p><strong>具体格式说明</strong></p>
<ul>
<li><p>只有一条汇编语句</p>
<p>在内联汇编中，可以只有汇编语句，即没有输出、输入操作数，没有被破坏的寄存器列表。例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;hlt&quot;</span>);  <span class="comment">// 让CPU暂停运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多条汇编语句</p>
<p>当有多条汇编语句时，需要写在同一字符串中，不同语句之间用<code>;</code>或者<code>\n\t</code>分隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti; hlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\thlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\t&quot;</span>		<span class="comment">// 同上。C语言中多个连续的字符串，会被认为是同一字符串</span></span><br><span class="line">    <span class="string">&quot;hlt&quot;</span>);			<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>有输出操作数</strong></p>
<p>当汇编语句中有些数据需要存储到<code>C</code>语言中的某些变量中时，则可以使用输出操作数。例如，下面的代码是将<code>c</code>变量的值通过<code>mov $3, c</code>设置成<code>3</code>。其中<code>%[out]</code>为定义的一个输出约束，其名称应与<code>:</code>后的<code>out</code>相同，<code>&quot;=r&quot;(c)</code>指定了<code>c</code>变量映射到某个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;mov $3, %[out]&quot;</span>:[out]<span class="string">&quot;=r&quot;</span>(c));</span><br></pre></td></tr></table></figure>

<p>通过上述方式，即实现了类似<code>mov $3,c</code>的效果。</p>
<p>其中<code>=r</code>还可以设置成其它，如下表所示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">任意寄存器</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">%eax,%ax,%al</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">%ebx,%bx,%bl</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">%ecx,%cx,%cl</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">%edx,%dx,%d</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">%esi,%si</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">%edi,%di</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有输入操作数</strong></p>
<p>当需要从<code>C</code>语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中，<code>mov%[ch], %%al</code>用于将<code>c</code>变量中的字符写到<code>al</code>中。因此，在输入操作数中使用了<code>[ch]&quot;r&quot;(c)</code>，即<code>c</code>变量映射到某个寄存器上（见上文中输出操作数的类似设置）。最终的效果为：<code>mov$0xe,%%ah、mov%[c],%%al</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $Ox10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免优化</p>
<p>在某些情况下，<code>GCC</code>编译器会对内联汇编中的汇编语句进行优化处理，最终导致生成语句和预期的不同，影响程序的执行结果。为了避免这些问题，可以强制要求<code>GCC</code>不对其进行优化，即原样的生成。要达到这点，可以使用<code>__asm__ __volatile_</code>替代原来的<code>asm</code>。</p>
</li>
<li><p>参考资料</p>
<p>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a><br>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly">https://wiki.osdev.org/Inline_Assembly</a><br>内联汇编示例：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly/Examples">https://wiki.osdev.org/Inline_Assembly/Examples</a></p>
</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_msg</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = *msg++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 利用内联汇编显示字符串</span></span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span></span><br><span class="line">            ::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loader_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    show_msg(<span class="string">&quot;....loading....\n\r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png" alt="image-20240509194129987"></p>
<h2 id="3-2-检测内存容量"><a href="#3-2-检测内存容量" class="headerlink" title="3.2 检测内存容量"></a>3.2 检测内存容量</h2><p>对<code>loader</code>做一些功能扩展。</p>
<h3 id="1、内存检测方法理论"><a href="#1、内存检测方法理论" class="headerlink" title="1、内存检测方法理论"></a>1、内存检测方法理论</h3><p>内存检测方法：<code>INT 0x15, EAX = 0xE820</code></p>
<p>没有找到专门介绍内存检测方法的官方文档，只在<code>osdev</code>网站上（见下文参考资料）中找到相关的检测方法。具体来看，其中有简单也有复杂的方法，有的只在某些机器上可用。最推荐的一种方法如下（摘自osdev）：</p>
<blockquote>
<p><strong>第一次调用时，ES: DI存储保存读取的信息的存储位置：</strong><br>清除<code>EBX</code>，设置为<code>0</code><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>设置成	<code>0xE820</code><br><code>ECX</code>设置成	<code>24</code><br>执行		   	 <code>INT 0x15</code><br>返回结果      <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>，<code>EBX</code>被设置成某个数值用于下次调用，<code>CL</code>&#x3D;实际读取的字节数</p>
<p><strong>后续调用：</strong><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>重设为	<code>0xE820</code><br><code>ECX</code>重设为	<code>24</code><br>执行				  <code>INT 0x15</code><br>返回结果	   <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>。如果<code>EBX=0</code>，则表明读取完毕，否则当前条目有效。</p>
</blockquote>
<p>参考资料——内存检测方法：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Detecting_Memory_(x86)">https://wiki.osdev.org/Detecting_Memory_(x86)</a></p>
<h3 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h3><p>首先需要自定义一个结构体来保存boot获取到的硬件信息，以便后期传递给操作系统使用。定义在comm中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png" alt="image-20240509203459102"></p>
<p>当<code>for</code>循环执行完毕后，<code>boot_info</code>内部的信息如下，共分配两块内存区域：</p>
<ul>
<li>第1块，<code>0-640KB</code>左右，在<code>1MB</code>以内；</li>
<li>第2块，<code>1MB-128MB</code>左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png" alt="image-20240509204234901"></p>
<p>可以结合<code>qemu</code>的配置脚本来看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@REM 适用于windows</span><br><span class="line">start qemu-system-i386  -m 128M -s -S  -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>启动时内存大小分配即为<code>128M</code>，即<code>-m 128M</code>。</p>
<h2 id="3-3-切换至保护模式"><a href="#3-3-切换至保护模式" class="headerlink" title="3.3 切换至保护模式"></a>3.3 切换至保护模式</h2><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png" alt="image-20240509211140943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png" alt="image-20240509211151568"></p>
<h3 id="2、编程细节"><a href="#2、编程细节" class="headerlink" title="2、编程细节"></a>2、编程细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">gdt.start15_0 = start &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cli</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 禁用中断</span></span><br><span class="line">cli();</span><br></pre></td></tr></table></figure>

<p><code>cli()</code>会影响<code>eflags</code>寄存器：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png" width="300"/>
</center>

<p><strong>（2）打开<code>A20</code>地址线</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/93877845">一步步编写操作系统 26 打开A20地址线</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 打开A20地址线</span></span><br><span class="line"><span class="type">uint8_t</span> v = inb(<span class="number">0x92</span>);</span><br><span class="line">outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">// 0x00000010</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）加载<code>GDT</code>表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9a00</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载GDT表</span></span><br><span class="line">lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br></pre></td></tr></table></figure>

<p>在<code>qemu</code>的<code>[view-&gt;compatmonitor()]</code>中输入<code>info registers</code>，可以看到<code>GDT</code>的信息变化：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png" alt="image-20240510101651071"></p>
<p><code>GDT</code>表写入后，<code>GDT=00009358 00000017</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png" alt="image-20240510145235174"></p>
<p>加载的<code>GDT</code>表项与所给出的表项一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png" alt="image-20240510145356743"></p>
<p><strong>（4）开启保护模式使能位</strong></p>
<p>开启保护位时，需设置<code>CR0</code>寄存器的<code>PE</code>位为<code>1</code>。由于<code>CR0</code>无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到<code>CR0</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开启保护模式使能位</span></span><br><span class="line"><span class="type">uint32_t</span> cr0 = read_cr0();</span><br><span class="line">write_cr0(cr0 | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>（5）远跳转</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 远跳转，跳转到32位指令的入口处</span></span><br><span class="line">far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);  <span class="comment">// 这个8和保护模式的硬件细节，以及GDT表有关</span></span><br></pre></td></tr></table></figure>

<p>当跳转到<code>protect_mode_entry</code>后，可以看到段寄存器<code>CS</code>项变为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 00000000 0000ffff 00cf9a00 DPL=0 CS32</span><br></pre></td></tr></table></figure>

<p>即进入<code>32</code>位代码模式。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png" alt="image-20240510145523144"></p>
<p>将剩余的寄存器也修改到32位模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protect_mode_entry:</span><br><span class="line">	mov $<span class="number">16</span>, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %ss</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png" alt="image-20240510150001767"></p>
<h2 id="3-4-使用LBA读取磁盘"><a href="#3-4-使用LBA读取磁盘" class="headerlink" title="3.4 使用LBA读取磁盘"></a>3.4 使用LBA读取磁盘</h2><p>参考资料：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode">硬盘访问模式及相关寄存器</a></p>
<p>虽然<code>BIOS</code>提供了磁盘读取的接口，方便从磁盘上读取<code>loader</code>，但在进入保护模式后，<code>BIOS</code>功能无法使用，<strong>读取磁盘需要使用到<code>LBA</code>模式</strong>。因此必须自己设计磁盘读取的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png" alt="image-20240510151038444"></p>
<p>具体来讲，本项目采用<code>LBA48</code>模式。<code>LBA48</code>模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，序号从<code>0</code>开始，其访问序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F6,0x40|(slavebit&lt;&lt;4))  	// 选择硬盘:主盘或从盘</span><br><span class="line"></span><br><span class="line">outb(0x1F2,sectorcount high byte)	// 将扇区数量的高8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第4、5、6个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA4)							 </span><br><span class="line">outb(0x1F4,LBA5)</span><br><span class="line">outb(0x1F5,LBA6)</span><br><span class="line"></span><br><span class="line">outb (0x1F2,sectorcount low byte)	// 将扇区数量的低8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第1、2、3个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA1)</span><br><span class="line">outb(0x1F4,LBA2)</span><br><span class="line">outb(0x1F5,LBA3)</span><br><span class="line"></span><br><span class="line">Send the &quot;READ SECTORS EXT&quot; command (0x24) to port 0x1F7: </span><br><span class="line">outb(0x1F7,0x24)	// 告诉硬盘要读取扇区的数据</span><br></pre></td></tr></table></figure>

<p>各寄存器说明如下:</p>
<table>
<thead>
<tr>
<th>寄存器偏移</th>
<th>读写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>R&#x2F;W</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>错误寄存器</td>
</tr>
<tr>
<td>1</td>
<td>W</td>
<td>特性寄存器</td>
</tr>
<tr>
<td>2</td>
<td>R&#x2F;W</td>
<td>扇区数量寄存器</td>
</tr>
<tr>
<td>3</td>
<td>R&#x2F;W</td>
<td>Sector Number Register (LBAlo)</td>
</tr>
<tr>
<td>4</td>
<td>R&#x2F;W</td>
<td>Cylinder Low Register &#x2F;(LBAmid)</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>Cylinder High Register &#x2F;(LBAhi)</td>
</tr>
<tr>
<td>6</td>
<td>R&#x2F;W</td>
<td>Drive &#x2F; Head Register</td>
</tr>
<tr>
<td>7</td>
<td>R</td>
<td>状态寄存器</td>
</tr>
<tr>
<td>7</td>
<td>W</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>0x1F6</code>寄存器（<code>Drive/Head</code>）对应的位如下：</li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td></td>
<td>在, bits 24 to 27 of the block number.</td>
</tr>
<tr>
<td>4</td>
<td>DRV</td>
<td>驱动器号（驱动器号：主盘和从盘。当只有一块硬盘时，默认第一块硬盘上放在主盘上。）</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>LBA</td>
<td>LBA模式下设置为1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Status Register(I/O base + 7)</code></li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>1</td>
<td>IDX</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>CORR</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DRQ</td>
<td>就绪，可以写数据或读取数据</td>
</tr>
<tr>
<td>4</td>
<td>SRV</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>DF</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>RDY</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BSY</td>
<td>忙</td>
</tr>
</tbody></table>
<p>由于<code>loader</code>占用的大小较大，约几十<code>kb</code>的样子。由于不确定具体大小，因此尽量将内核往后放，放在第<code>100</code>个扇区的位置，并且将内核的大小为<code>500</code>，即<code>250kb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static void read_disk (uint32_t sector, uint32_t sector_count, uint8_t *buf);</span></span><br><span class="line">read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-创建内核工程"><a href="#3-5-创建内核工程" class="headerlink" title="3.5 创建内核工程"></a>3.5 创建内核工程</h2><p>创建内核工程，并将工程写到磁盘上第<code>1MB</code>位置处，<code>loader</code>加载后将跳转过去。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png" alt="image-20240510162243231"></p>
<p>新建<code>kernel</code>文件夹，并在内部新建<code>CMakeLists.txt</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">project(kernel LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的链接器</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-m elf_i386  -Ttext=0x100000&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_LINK_EXECUTABLE <span class="string">&quot;<span class="variable">$&#123;LINKER_TOOL&#125;</span> &lt;OBJECTS&gt; <span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -o <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的汇编、C文件加入工程</span></span><br><span class="line"><span class="comment"># 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x8000时能在开头处</span></span><br><span class="line">file(GLOB_RECURSE C_LIST <span class="string">&quot;*.c&quot;</span> <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="comment"># 将GLOB改为GLOB_RECURSE，因为kernel目录下包含init等子目录，需要进行递归</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> init/start.S <span class="variable">$&#123;C_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bin文件生成，写入到image目录下</span></span><br><span class="line">add_custom_command(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJCOPY_TOOL&#125;</span> -O binary <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../../image/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJDUMP_TOOL&#125;</span> -x -d -S -m i386 <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_dis.txt</span><br><span class="line">                   <span class="comment"># i8086改为i386，即从16位模式改为32位模式</span></span><br><span class="line">                   COMMAND <span class="variable">$&#123;READELF_TOOL&#125;</span> -a <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-向内核传递启动信息"><a href="#3-6-向内核传递启动信息" class="headerlink" title="3.6 向内核传递启动信息"></a>3.6 向内核传递启动信息</h2><h3 id="1、如何实现从loader到kernel的信息传输？"><a href="#1、如何实现从loader到kernel的信息传输？" class="headerlink" title="1、如何实现从loader到kernel的信息传输？"></a>1、如何实现从loader到kernel的信息传输？</h3><p>信息的传递流程为：<code>boot_info-&gt;loader-&gt;kernel</code>。现在的问题就是如何实现从<code>loader</code>到<code>kernel</code>的传输？</p>
<ul>
<li><p>方式一：将<code>boot_info</code>写到某个固定的地址，再由<code>kernel</code>自行去取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png" alt="image-20240510195254050"></p>
</li>
<li><p>方式二：将内核的入口地址处视为存放着一个接受启动信息参数的函数，使用函数调用：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png" alt="image-20240510195449809"></p>
<blockquote>
<p><code>(void(*)(boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code></p>
<p>这个表达式是一个函数指针的类型转换，用于将一个特定地址处的函数映射到一个特定类型的函数指针。调用这个函数指针，并将 <code>boot_info</code> 作为参数传递给该函数。</p>
<ol>
<li><code>(SYS_KERNEL_LOAD_ADDR)</code>：<ul>
<li>这部分表示一个地址，即内核加载的地址 <code>SYS_KERNEL_LOAD_ADDR</code>。</li>
</ul>
</li>
<li><code>(void (*)(boot_info_t *))</code>：<ul>
<li>这部分是一个函数指针类型的转换。</li>
<li><code>void (*)(boot_info_t *)</code> 表示一个函数指针，指向一个接受 <code>boot_info_t *</code> 类型参数并返回 <code>void</code> 类型的函数。</li>
</ul>
</li>
<li><code>(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code>：<ul>
<li>这部分将 <code>boot_info</code> 的地址作为参数传递给地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数，并且将返回的结果转换为 <code>(void (*)(boot_info_t *))</code> 类型的函数指针。</li>
</ul>
</li>
</ol>
<p>综合起来，整个表达式的作用是将位于地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数转换为一个接受 <code>boot_info_t *</code> 类型参数的函数指针，并且调用这个函数，将 <code>boot_info</code> 作为参数传递给它。</p>
</blockquote>
</li>
</ul>
<h3 id="2、x86栈的基本结构"><a href="#2、x86栈的基本结构" class="headerlink" title="2、x86栈的基本结构"></a>2、x86栈的基本结构</h3><p>保护模式下，栈单元大小为<code>32</code>位&#x2F;<code>4</code>字节。（在<code>32</code>位系统中）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png" alt="image-20240510202728422"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png" alt="image-20240510202743173"></p>
<h3 id="3、实现细节"><a href="#3、实现细节" class="headerlink" title="3、实现细节"></a>3、实现细节</h3><p>（1）总体程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .extern kernel_init</span><br><span class="line">    .global _start</span><br><span class="line">    # void start (boot_info_t *boot_info)</span><br><span class="line">_start:</span><br><span class="line">    /*</span><br><span class="line">        将boot_info压入栈中，并传递给kernel_init</span><br><span class="line">        boot_info则来自_start被调用时，((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);也会压栈</span><br><span class="line">            ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);</span><br><span class="line">            84d8:	83 ec 0c             	sub    $0xc,%sp</span><br><span class="line">            84db:	68 40 95             	push   $0x9540</span><br><span class="line">            84de:	00 00                	add    %al,(%bx,%si)</span><br><span class="line">            84e0:	b8 00 00             	mov    $0x0,%ax</span><br><span class="line">            84e3:	10 00                	adc    %al,(%bx,%si)</span><br><span class="line">            84e5:	ff d0                	call   *%ax</span><br><span class="line">            84e7:	83 c4 10             	add    $0x10,%sp</span><br><span class="line">        也即是说_start实际上是被调函数，参考讲义中的test函数的逻辑来操作</span><br><span class="line">    */</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp, %ebp</span><br><span class="line">    mov 0x8(%ebp), %eax</span><br><span class="line">    /*</span><br><span class="line">        通过ebp+偏移来取得boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址</span><br><span class="line">            - ebp当前指向位置（esp当前指向位置）</span><br><span class="line">        所以为0x8(%ebp)</span><br><span class="line">    */  </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        由于最终是原地跳转，不会回到loader中，因此也可以不考虑ebp恢复的情况，此时上述三行可用一行来实现：</span><br><span class="line">            mov 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">        当不考虑ebp时，esp+4即可取到boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址（esp当前指向位置）</span><br><span class="line">        所以为4(%esp)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    # kernel_init (boot_info)</span><br><span class="line">    push %eax  </span><br><span class="line">    call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line"></span><br><span class="line">    jmp .</span><br></pre></td></tr></table></figure>

<p>（2）具体执行</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png" alt="image-20240510204938049"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png" alt="image-20240510205045871"></p>
<p>而在<code>./build/source/loader/loder_elf.txt</code>的符号表中，可以看到<code>boot_info</code>的地址即为<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png" alt="image-20240510205246084"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %eax  </span><br><span class="line">call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line">jmp .</span><br></pre></td></tr></table></figure>

<p>当进入<code>kernel_init</code>函数后，可以看到传入的<code>boot_info</code>的地址也是<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png" alt="image-20240510205443276"></p>
<h2 id="3-7-代码-数据段与链接脚本"><a href="#3-7-代码-数据段与链接脚本" class="headerlink" title="3.7 代码&#x2F;数据段与链接脚本"></a>3.7 代码&#x2F;数据段与链接脚本</h2><h3 id="1、链接的理论基础"><a href="#1、链接的理论基础" class="headerlink" title="1、链接的理论基础"></a>1、链接的理论基础</h3><blockquote>
<p>可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png" alt="image-20240510205719578"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png" alt="image-20240510210839581"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png" alt="image-20240510210855757"></p>
<p>举例如下：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png" width="300"/>
</center>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png" alt="image-20240510211122344"></p>
<h3 id="2、自定义链接脚本"><a href="#2、自定义链接脚本" class="headerlink" title="2、自定义链接脚本"></a>2、自定义链接脚本</h3><p>上述所讲为编译器默认配置。可自定义链接脚本，定义工程中相应的代码或数据放在哪些位置。</p>
<p>编写<code>kernel.lds</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x20000;  // 控制.text section的起始地址，后续的section也可以进行相应的设置</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)  // 通配符： *</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改对应的<code>[kernel/CMakeLists.txt]</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds&quot;)</span><br></pre></td></tr></table></figure>

<p>也就是说链接脚本控制了各个<code>section</code>具体的存放位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png" alt="image-20240510213841287"></p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">GCC LD官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Linker_Scripts">linker脚本(较易阅读)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bravegnu.org/gnu-eprog/linker.html">ARM Linker链接脚本</a></p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/">ld脚本编写</a></p>
</blockquote>
<h2 id="3-8-加载内核映像文件"><a href="#3-8-加载内核映像文件" class="headerlink" title="3.8 加载内核映像文件"></a>3.8 加载内核映像文件</h2><h3 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png" alt="image-20240511201413000"></p>
<p>若在<code>#12</code>行设置<code>. = 200000</code>，则会导致在<code>.rodata</code>和<code>.data</code>中间出现较大的空闲空间，导致最终的文件大小大于<code>1MB</code>，这个大小过大了。且如果采用二进制映像文件，操作系统是无法得知各个<code>section</code>在内存中分布的具体位置的。</p>
<p>为了更好地组织程序和数据，一般需要专用的文件格式，如<code>PE</code>格式或者<code>ELF</code>格式。<code>ELF</code>用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。</p>
<blockquote>
<p>ELF文件的详细细节可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png" alt="image-20240511202122375"></p>
<ul>
<li><p>可执行代码段和数据段从<code>p_offset</code>的位置拷贝到内存的<code>p_paddr</code>中，拷贝的大小为<code>p_filesz</code>。</p>
</li>
<li><p>在<code>ELF</code>文件格式中，<code>.data</code> 和 <code>.bss</code> 区域通常用来存储程序的已初始化和未初始化数据。在加载可执行文件时，操作系统会负责为这些区域分配内存，并将它们初始化为零。</p>
<p>因此，在生成<code>ELF</code>可执行文件时，不需要将 <code>.data</code> 和 <code>.bss</code> 区域的实际数据写入文件中。相反，只需在文件中标记出这些区域的大小，并在加载时告知操作系统需要为它们分配多大的内存空间，并将其初始化为零。</p>
</li>
<li><p><code>p_memsz = p_filesz + 清零区域</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png" alt="image-20240511210512520"></p>
<h3 id="2、代码实现细节"><a href="#2、代码实现细节" class="headerlink" title="2、代码实现细节"></a>2、代码实现细节</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bin文件生成，写入到image目录下</span><br><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   # 修改前</span><br><span class="line">                   # COMMAND $&#123;OBJCOPY_TOOL&#125; -O binary $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">                   # 修改后：-O binary =&gt; -S</span><br><span class="line">                   COMMAND $&#123;OBJCOPY_TOOL&#125; -S $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">				   COMMAND $&#123;OBJDUMP_TOOL&#125; -x -d -S -m i386 $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_dis.txt</span><br><span class="line">                   COMMAND $&#123;READELF_TOOL&#125; -a $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后，新的存储规划如下：</p>
<ul>
<li>将<code>kernel</code>，即内核工程放在<code>64KB/0x10000</code>的位置；</li>
<li>也就是说，<code>0x100000</code>处只是存放一个临时的<code>ELF</code>文件，实际的内容会被加载到<code>0x10000</code>处执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png" alt="image-20240511203046852"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span><span class="params">(<span class="type">uint8_t</span> *file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">// 检查是否为有效文件（粗略检查）</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br><span class="line">        <span class="comment">// 判断该段是需要被加载到内存中的可执行代码或数据段</span></span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将可执行代码或数据段从文件中拷贝到内存中</span></span><br><span class="line">        <span class="type">uint8_t</span> *src = file_buffer + phdr-&gt;p_offset;</span><br><span class="line">        <span class="type">uint8_t</span> *dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对.data和.bss做进一步处理</span></span><br><span class="line">        dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png" width="300"/>    
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png" width="300"/>
</center>



<h1 id="四、中断与异常处理"><a href="#四、中断与异常处理" class="headerlink" title="四、中断与异常处理"></a>四、中断与异常处理</h1><h2 id="4-1-创建GDT表及其表项"><a href="#4-1-创建GDT表及其表项" class="headerlink" title="4.1 创建GDT表及其表项"></a>4.1 创建GDT表及其表项</h2><h3 id="1、理论基础-2"><a href="#1、理论基础-2" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><code>x86</code>系统架构（<code>IA32</code>模式）</p>
<ul>
<li><p>分段存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png" alt="image-20240512140427535"></p>
</li>
<li><p>分页存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png" alt="image-20240512140446313"></p>
</li>
</ul>
<p><strong>在进入保护模式以后，所有有关内存访问的操作都需要经过<code>GDT</code>表</strong>，表中的每项称为<strong>段描述符</strong>（<code>Segment descriptor</code>）。</p>
<p>每一项是一个结构体，<code>64</code>位结构，包含<code>base addr/基地址</code>、<code>limit/界限</code>以及<code>属性值</code></p>
<ul>
<li><code>limit</code>分为<code>2</code>块，<code>limit 15:00</code>和<code>limit 19:16</code></li>
<li><code>base addr</code>分为<code>3</code>块，<code>base 15:00</code>、<code>base 23:16</code>和<code>base 31:24</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png" alt="image-20240512140536089"></p>
<h3 id="2、代码细节"><a href="#2、代码细节" class="headerlink" title="2、代码细节"></a>2、代码细节</h3><ul>
<li><p><code>GDT</code>结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>GDT</code>表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">segment_desc_t</span> gdt_table[GDT_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    selector：从gdt表中选择某个表项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span> <span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> *desc = gdt_table + selector / <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>);</span><br><span class="line"></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;                   <span class="comment">// limit低16位</span></span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;                     <span class="comment">// base低16位</span></span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移16位后取低8位</span></span><br><span class="line">    desc-&gt;attr = attr | (((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);   <span class="comment">// 将limit的高4位存储到attr字段 </span></span><br><span class="line">    desc-&gt;base31_24 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移24位后取低8位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空gdt表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; ++i) &#123;</span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理论上，处理器可以访问寻址处理任意地址的字节，但实际上为了保证计算机读取数据的高效性，<code>CPU</code>通过地址总线来访问内存。以32位处理器为例，一般来说寻址步长为32位(4个字节)，也就是每次从内存读取4个字节。为了提高存取效率，一般来说编译器会自动将一个数据尽量放在一个步长之内，避免跨步长存储，称为内存对齐。<br>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。可通过预编译命令<code>#pragma pack(n)</code>，<code>n=1,2,4,8,16</code>来改变这一系数，其中的n就是你要指定的“对齐系数”。</p>
</blockquote>
<h2 id="4-2-保护模式下的内存管理简介"><a href="#4-2-保护模式下的内存管理简介" class="headerlink" title="4.2 保护模式下的内存管理简介"></a>4.2 保护模式下的内存管理简介</h2><h3 id="1、理论基础-3"><a href="#1、理论基础-3" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>参考<code>325384-sdm-vol-3abcd.pdf</code>的<code>Ch3 Protected-Mode Memory Management</code></p>
</blockquote>
<ul>
<li><p>分段存储和分页存储及其异同</p>
<ul>
<li>分页存储</li>
</ul>
<p>  将程序的逻辑地址空间划分为固定大小的页(<code>page</code>)，而物理内存划分为同样大小的页框(<code>page frame</code>)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<ul>
<li>分段存储</li>
</ul>
<p>  在分段存储管理中，将程序的地址空间划分为若干个段(<code>segment</code>)，这样每个进程有一个二维的地址空间。每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续。</p>
<ul>
<li><p>分页和分段的相同点</p>
<ul>
<li><p>分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。</p>
</li>
</ul>
</li>
<li><p>分页和分段的区别</p>
<ul>
<li><p>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。</p>
</li>
<li><p>分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
</li>
<li><p>段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png" alt="image-20240512155014746"></p>
</li>
<li><p>下图是一种比较复杂的设计，一般不采用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png" alt="image-20240512155154382"></p>
</li>
<li><p>为简单起见，可采用平坦模型，分为基础平坦模式和带保护的平坦模式。</p>
</li>
<li><p><strong>本项目采用基础平坦模式。</strong></p>
<ul>
<li><code>CS</code>指向代码段；剩余寄存器指向数据段；</li>
<li>两个段的起始地址均为<code>0</code>，大小为<code>4GB</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png" alt="image-20240512155513883"></p>
</li>
<li><p>从逻辑地址转换到线性地址</p>
<ul>
<li>举例，对于逻辑地址<code>0x8:0x1234</code>：<ul>
<li><code>0x8</code>对应<code>GDT</code>的表项<code>1</code>；</li>
<li><code>GDT</code>的表项<code>1</code>中基地址为<code>0x10000</code>，因此线性地址为<code>0x11234</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png" alt="image-20240512155843842"></p>
</li>
<li><p>对于上文所述的<code>0x8</code>，观察选择子的结构可以得知，低<code>3</code>位用于其他用途，剩余位用于判断索引<code>index</code>。因此<code>0x8 = (b)00001000</code>，因此对应表项1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png" alt="image-20240512160330889" style="zoom:50%;" /></li>
</ul>
<h3 id="2、内存访问的整体流程"><a href="#2、内存访问的整体流程" class="headerlink" title="2、内存访问的整体流程"></a>2、内存访问的整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png" alt="image-20240512160353942"></p>
<h2 id="4-3-重新加载GDT表"><a href="#4-3-重新加载GDT表" class="headerlink" title="4.3 重新加载GDT表"></a>4.3 重新加载GDT表</h2><p>在<code>loader_16.c</code>中曾经自定义了一个简单的<code>GDT</code>表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDT表（临时用，后面内容会替换成自己的）</span></span><br><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以下不足：</p>
<p>1）表项过小，在后期涉及到多进程以及中断管理时需要加入新的配置项；</p>
<p>2）当前这个表存储所在的内存区域为<code>loader</code>，即数据区，在后面可能会被覆盖。</p>
<p>因此，在<code>kernel</code>工程中设计了一个包含<code>256</code>个表项的新<code>GDT</code>表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_TABLE_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、实现细节"><a href="#2、实现细节" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png" alt="image-20240512165607190"></p>
<p>重新加载<code>GDT</code>表后：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png" alt="image-20240512165730560"></p>
<p>对于<code>CS</code>项：</p>
<ul>
<li><code>0008</code>：选择子</li>
<li>后面的数字则是具体的表项，包括<code>limit</code>、<code>base</code>和<code>attr</code>等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png" alt="image-20240512170129300"></p>
<h2 id="4-4-触发异常与异常简介"><a href="#4-4-触发异常与异常简介" class="headerlink" title="4.4 触发异常与异常简介"></a>4.4 触发异常与异常简介</h2><h3 id="1、理论基础-4"><a href="#1、理论基础-4" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在程序运行过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。</p>
<ul>
<li>异常<ul>
<li>由于CPU内部事件所引起的中断，如程序出错（非法指令、地址越界以及除0异常等）</li>
<li>通常由于执行了现行指令所引起</li>
</ul>
</li>
<li>中断<ul>
<li>由于外部设备事件所引起的中断，如通常的磁盘中断以及打印机中断等</li>
<li>通常与现行指令无关，由外部事件引起</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png" alt="image-20240512203148228"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png" alt="image-20240512203209841"></p>
<h2 id="4-5-添加中断门描述符"><a href="#4-5-添加中断门描述符" class="headerlink" title="4.5 添加中断门描述符"></a>4.5 添加中断门描述符</h2><h3 id="1、理论基础-5"><a href="#1、理论基础-5" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>进入保护模式后，中断向量表需要重新配置。</p>
<p><code>IA-32</code>中断向量表：<code>IDTR</code>寄存器指向的<code>IDT/Interrupt Descriptor Table</code>表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png" alt="image-20240512203547782"></p>
<ul>
<li><code>IDTR</code>寄存器，由<code>Base Address</code>和<code>Limit</code>组成。<ul>
<li>基地址：保存<code>IDT</code>表的起始位置</li>
<li><code>Limit</code>：指定<code>IDT</code>表的大小</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png" alt="image-20240512203508876"></p>
<ul>
<li><p><code>IDT</code>表项的具体格式</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png" alt="image-20240512203943834"></p>
<ul>
<li><p><code>Interrupt Gate</code>：本项目主要采用该格式。</p>
<ul>
<li><p>包含选择子、偏移量以及一些其他的标志位。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png" alt="image-20240512204443158" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDT表项/Interrupt Gate中断门表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gate_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> offset15_0;</span><br><span class="line">    <span class="type">uint16_t</span> selector;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint16_t</span> offset31_16;</span><br><span class="line">&#125;<span class="type">gate_desc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置IDT表项/中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gate_desc_set</span> <span class="params">(<span class="type">gate_desc_t</span> *desc, <span class="type">uint16_t</span> selector, <span class="type">uint32_t</span> offset, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    desc-&gt;offset15_0 = offset &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;selector = selector;</span><br><span class="line">    desc-&gt;attr = attr;</span><br><span class="line">    desc-&gt;offset31_16 = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行初始化后可以看到<code>IDT</code>的值被设置为<code>idt_table</code>的首地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png" alt="image-20240512210927867"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png" alt="image-20240512210916635"></p>
<h2 id="4-6-捕获除0异常"><a href="#4-6-捕获除0异常" class="headerlink" title="4.6 捕获除0异常"></a>4.6 捕获除0异常</h2><h3 id="1、为所有异常配置缺省的处理程序"><a href="#1、为所有异常配置缺省的处理程序" class="headerlink" title="1、为所有异常配置缺省的处理程序"></a>1、为所有异常配置缺省的处理程序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png" alt="image-20240512211301703"></p>
<p>设置缺省处理程序时，由于基地址为<code>0</code>，只需将处理程序的起始地址赋值给<code>offset</code>，然后将<code>IDT</code>的选择子设置为代码段的选择子即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png" alt="image-20240512212443637"></p>
<p>注意：中断处理程序只能用汇编来写，而不能用C语言来写！</p>
<blockquote>
<p>中断处理程序需要使用 <code>iret</code> 指令来正确地恢复被中断的程序的执行状态。<code>iret</code> 指令用于从中断处理程序返回到被中断的程序，并恢复被中断程序的执行现场，包括栈指针、标志寄存器和程序计数器等。</p>
<p>在 x86 架构中，<code>iret</code> 指令不能在 C 函数中直接使用，因为 C 函数的结尾通常是 <code>ret</code> 指令，这个指令只能用于从函数返回，而不能正确地恢复中断处理程序的执行状态。</p>
<p>因此，为了正确处理中断，特别是在中断处理程序中使用 <code>iret</code> 指令，需要使用汇编语言编写中断处理程序。只有在汇编语言中，可以直接使用 <code>iret</code> 指令来正确地返回到被中断的程序。</p>
</blockquote>
<h3 id="2、除0异常发生"><a href="#2、除0异常发生" class="headerlink" title="2、除0异常发生"></a>2、除0异常发生</h3><p>当发生除<code>0</code>异常时，首先会跳转到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>接下按<code>F11</code>单步调试，然后又会回到除<code>0</code>指令（<code>int a = 3 / 0</code>）上，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png" alt="image-20240512214929396"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png" alt="image-20240512215020824"></p>
<p>再次处理发现仍旧无法解决，因此又会回到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>这样就会陷入死循环。因此在用户端程序遇到异常时一般需要将程序杀掉，但在操作系统中则无法处理，因此一般采用死机的处理。</p>
<p>详述“死机”的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unkown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    do_default_handle(<span class="string">&quot;unkown exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发现除<code>0</code>异常时：</p>
<p>-&gt; <code>exception_handle_unkown</code></p>
<p>-&gt; <code>do_handler_unkown</code></p>
<p>-&gt; <code>do_default_handle</code></p>
<p>-&gt; 进入死循环，即死机</p>
<h3 id="3、预先保存寄存器状态"><a href="#3、预先保存寄存器状态" class="headerlink" title="3、预先保存寄存器状态"></a>3、预先保存寄存器状态</h3><p>此外，在跳转到中断处理程序开始处理中断之前，需要先保存当前寄存器的状态，以防止后续对寄存器进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png" alt="image-20240512223603745"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    # 寄存器压栈</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line"></span><br><span class="line">    call do_handler_unkown</span><br><span class="line"></span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<p>注意：此处不必压栈<code>ss</code>和<code>esp</code>寄存器，原因如下：</p>
<blockquote>
<ol>
<li><strong>特权级不变</strong>： 在x86保护模式下，当从一个特权级（例如内核模式，特权级0）中断或异常到同一特权级时，不会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。仅当从低特权级（如用户模式，特权级3）切换到高特权级（如内核模式，特权级0）时，才会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。</li>
<li><strong>特权级切换</strong>： 如果特权级发生变化，例如从用户模式（特权级3）切换到内核模式（特权级0），CPU 会自动将 <code>ss</code> 和 <code>esp</code> 压入堆栈。为了处理这种情况，你需要一个包含 <code>ss</code> 的扩展结构体。</li>
</ol>
</blockquote>
<h2 id="4-7-解析异常栈信息"><a href="#4-7-解析异常栈信息" class="headerlink" title="4.7 解析异常栈信息"></a>4.7 解析异常栈信息</h2><h3 id="1、理论基础-6"><a href="#1、理论基础-6" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>在发生异常而跳转到异常处理程序时，希望能够知道究竟是哪里触发了异常。此时就需要查看异常栈的相关信息。</p>
</blockquote>
<p>对于下图：当异常发生后，会将<code>EFLAGS/CS/EIP/Error Code</code>压入栈中</p>
<ul>
<li><code>EFLAGS</code>保存了状态一些相关状态</li>
<li><code>EIP</code>指示了异常发生时是哪条指令触发了异常，会将对应的地址压入<code>EIP</code>中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png" alt="image-20240513102222754"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650880105">x86—EFLAGS寄存器详解【转载】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Reverse-xiaoyu/p/11397584.html">EFLAGS寄存器（标志寄存器）</a></p>
</blockquote>
<p>在调试控制台查看<code>esp:0x12e28</code>开始栈的相关信息，但这样做比较繁琐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png" alt="image-20240513102619780"></p>
<p>在进入异常处理时，用<code>pusha</code>指令主动保存了一部分：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png" alt="image-20240513103220789"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png" alt="image-20240513103300450"></p>
<p>此外，通过<code>push</code>指令压入其他寄存器：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png" alt="image-20240513103415308"></p>
<p><strong>因此，这些要获取的栈中的寄存器信息则类似于向缺省处理函数传递的参数。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png" alt="image-20240513103626832"></p>
<p>但如果按上图中那样去写，会显得过于繁琐。因此可以将其封装为结构体，从而转换为压入这个结构体的地址（作为一个指针）。</p>
<p>根据上图，当前<code>ESP</code>指向<code>GS</code>寄存器，在将<code>ES</code>到<code>EFLAGS</code>包装为结构体后，将结构体的指针压入栈中，此时这个指针指向<code>GS</code>的地址；而执行压栈操作后，<code>ESP</code>指向该指针。</p>
<ul>
<li><p>即——<code>ESP-&gt;指针-&gt;GS</code></p>
</li>
<li><p>语法为：<code>push %esp</code></p>
<blockquote>
<p>在x86汇编语言中，<code>push %esp</code> 指令用于将栈指针 <code>%esp</code> 的当前值压入栈顶。</p>
<p>1）将 <code>%esp</code> 寄存器中的当前值（即栈指针指向的地址）减去 4；</p>
<p>2）将其指向的内存位置（即原栈顶）的值复制到减去 4 后的新栈顶地址中；</p>
<p>3）然后更新 <code>%esp</code> 寄存器的值，使其指向新的栈顶地址。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png" alt="image-20240513103940064"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    push %esp  </span><br><span class="line">    # 由于将GS到EFLAGS这个整体作为一个结构体，此时当前esp指向GS寄存器的下一位，因此在压入栈时只需要将GS的地址压入</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    add $(1*4), %esp  # 出栈</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png" alt="image-20240513110407067"></p>
<p>对比下图，可以看到获取到的栈信息和<code>Segs</code>中的相关寄存器（左）相同，且<code>eip</code>寄存器保存的即为除<code>0</code>指令（右）所对应的地址。</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png" width="300"/>    
</center>

<h2 id="4-8-利用宏重用异常处理代码"><a href="#4-8-利用宏重用异常处理代码" class="headerlink" title="4.8 利用宏重用异常处理代码"></a>4.8 利用宏重用异常处理代码</h2><h3 id="1、宏重用相关"><a href="#1、宏重用相关" class="headerlink" title="1、宏重用相关"></a>1、宏重用相关</h3><p>下表展示了22种异常&#x2F;中断的类型。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png" alt="image-20240513112516959"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png" alt="image-20240513112528641"></p>
<p>如果要对这22种异常&#x2F;中断各自编写一段汇编代码，就会使得代码过于冗杂，因为仅仅只有函数名称和内部调用C函数的区别，处理的逻辑是一致的。因此考虑采用<strong>宏重用</strong>的方式。</p>
<p>注意此处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_\name:</span><br><span class="line">    # 错误码入栈</span><br><span class="line">    .if \with_err_code == 0</span><br><span class="line">        push $0  # 压入0表示没有错误码</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    # 类型编号和错误码出栈</span><br><span class="line">    add $(2*4), %esp</span><br><span class="line"></span><br><span class="line">    iret </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误想法：对于有错误码的异常类型，会自动将错误码入栈，因此最后出栈时不需要考虑它，只需要<code>add $(1*4), %esp</code>；只有对于需要手动压入错误码的异常，才需要<code>add $(2*4), %esp</code>进行手动出栈。</p>
<p>这种想法的错误在于：<code>iret</code>指令在执行时会忽略<code>Error Code</code>，也就是说不管这个异常有没有自动入栈错误码，都需要我们手动去出栈。</p>
</blockquote>
<p>设定好宏后，测试并查看对应的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">   1002b:	6a 00                	push   $0x0</span><br><span class="line">   1002d:	6a ff                	push   $0xffffffff</span><br><span class="line">   1002f:	60                   	pusha  </span><br><span class="line">   10030:	1e                   	push   %ds</span><br><span class="line">   10031:	06                   	push   %es</span><br><span class="line">   10032:	0f a0                	push   %fs</span><br><span class="line">   10034:	0f a8                	push   %gs</span><br><span class="line">   10036:	54                   	push   %esp</span><br><span class="line">   10037:	e8 c4 01 00 00       	call   10200 &lt;do_handler_unknown&gt;</span><br><span class="line">   1003c:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1003f:	0f a9                	pop    %gs</span><br><span class="line">   10041:	0f a1                	pop    %fs</span><br><span class="line">   10043:	07                   	pop    %es</span><br><span class="line">   10044:	1f                   	pop    %ds</span><br><span class="line">   10045:	61                   	popa   </span><br><span class="line">   10046:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10049:	cf                   	iret   </span><br><span class="line">  </span><br><span class="line">0001004a &lt;exception_handler_divider&gt;:</span><br><span class="line">   1004a:	6a 00                	push   $0x0</span><br><span class="line">   1004c:	6a 00                	push   $0x0</span><br><span class="line">   1004e:	60                   	pusha  </span><br><span class="line">   1004f:	1e                   	push   %ds</span><br><span class="line">   10050:	06                   	push   %es</span><br><span class="line">   10051:	0f a0                	push   %fs</span><br><span class="line">   10053:	0f a8                	push   %gs</span><br><span class="line">   10055:	54                   	push   %esp</span><br><span class="line">   10056:	e8 bb 01 00 00       	call   10216 &lt;do_handler_divider&gt;</span><br><span class="line">   1005b:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1005e:	0f a9                	pop    %gs</span><br><span class="line">   10060:	0f a1                	pop    %fs</span><br><span class="line">   10062:	07                   	pop    %es</span><br><span class="line">   10063:	1f                   	pop    %ds</span><br><span class="line">   10064:	61                   	popa   </span><br><span class="line">   10065:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10068:	cf                   	iret   </span><br></pre></td></tr></table></figure>

<h3 id="2、向IDT表项中安装中断处理程序"><a href="#2、向IDT表项中安装中断处理程序" class="headerlink" title="2、向IDT表项中安装中断处理程序"></a>2、向IDT表项中安装中断处理程序</h3><p>接下来编写<strong>安装中断处理程序</strong>的函数，它接受两个参数：<code>irq_num</code> 表示中断号，<code>handler</code> 是一个指向中断处理函数的指针。</p>
<ul>
<li>函数首先检查给定的中断号是否超过了 IDT 表项的范围。如果超过了，就返回 <code>-1</code> 表示失败；</li>
<li>然后，函数调用 <code>gate_desc_set</code> 函数来设置 IDT 表中的表项。<code>gate_desc_set</code> 函数的目的是将中断处理函数与指定的中断号关联起来，并将相应的中断处理函数的地址写入到 IDT 表中。这样，当相应的中断发生时，CPU 就会根据 IDT 表中的设置跳转到相应的中断处理函数；</li>
<li>最后，函数返回 <code>0</code> 表示成功安装中断处理程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(</span><br><span class="line">            idt_table + i, </span><br><span class="line">            KERNEL_SELECTOR_CS,</span><br><span class="line">            (<span class="type">uint32_t</span>)exception_handler_unknown, </span><br><span class="line">            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装中断处理程序到 IDT（中断描述符表）中</span></span><br><span class="line">    irq_install(IRQ0_DE, (<span class="type">irq_handler_t</span>)exception_handler_divider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_install</span> <span class="params">(<span class="type">int</span> irq_num, <span class="type">irq_handler_t</span> handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断异常编号是否超过IDT表项的范围</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= IDT_TABLE_NR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置IDT表项</span></span><br><span class="line">    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, </span><br><span class="line">                (<span class="type">uint32_t</span>)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png" alt="image-20240513153252414"></p>
<p>按照前述方式，可对其他类型的异常进行类似的处理。</p>
<h2 id="4-9-初始化中断控制器"><a href="#4-9-初始化中断控制器" class="headerlink" title="4.9 初始化中断控制器"></a>4.9 初始化中断控制器</h2><h3 id="1、理论基础-7"><a href="#1、理论基础-7" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p> CPU如何管理系统中的中断？</p>
</blockquote>
<p>一个<code>8259</code>芯片可以接收<code>IRQ0-IRQ7</code>共<code>8</code>个信号，当接收到相应的中断信号时，在内部进行处理，并通过<code>INT</code>信号连接到<code>CPU</code>，并向<code>CPU</code>发出中断请求。</p>
<p>由于个数限制，早期的<code>x86</code>处理器级联两片<code>8259</code>，接收共<code>15</code>个中断信号，其中一块芯片的<code>IR2</code>用于和另一块芯片连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png" alt="image-20240513170754592"></p>
<p>随着多核处理器的发展，<code>8259</code>被<code>APIC</code>替代。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png" alt="image-20240513185732842"></p>
<p><code>8259A</code>的内部结构图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png" alt="image-20240513185944144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png" alt="image-20240513190140086"></p>
<p><code>8259A</code>的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png" alt="image-20240513190216562"></p>
<blockquote>
<p><strong>8259的相关参考资料</strong></p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIC">osdev关于8259的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第180页</li>
</ul>
</blockquote>
<h3 id="2、实现细节-1"><a href="#2、实现细节-1" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p>初始化两个<code>8259</code>芯片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"><span class="comment">// Interrupt Controller</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1           0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR            0x21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1           0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR            0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ALWAYS_1   (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ICW4       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW4_8086       (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PIC_START       0x20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"><span class="comment">/* Interrupt Controller Initialization */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pic</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对两个8259芯片进行初始化</span></span><br><span class="line">    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC0_ICW2, IRQ_PIC_START);</span><br><span class="line">    outb(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    outb(PIC0_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC1_ICW2, IRQ_PIC_START + <span class="number">8</span>);</span><br><span class="line">    outb(PIC1_ICW3, <span class="number">2</span>);</span><br><span class="line">    outb(PIC1_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">    outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">    outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" alt="image-20240513192023489"></p>
<p>该寄存器的相应位为1时，会屏蔽对应的中断，使得CPU不予相应。当对芯片刚完成初始化时，还未配置相应的中断处理程序，因此需要将这个寄存器先设置为全1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-10-中断的打开与关闭"><a href="#4-10-中断的打开与关闭" class="headerlink" title="4.10 中断的打开与关闭"></a>4.10 中断的打开与关闭</h2><p>中断的打开与关闭受制于两个配置：</p>
<ol>
<li><code>EFLAGS</code>的<code>IF</code>标志位；</li>
<li><code>8259</code>的<code>IMR</code>寄存器。</li>
</ol>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png" width="400"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" width="400"/>    
</center>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) | (<span class="number">1</span> &lt;&lt; irq_num);</span><br></pre></td></tr></table></figure>

<p><strong>分别做了什么操作？</strong></p>
<p>这两行代码分别对 PIC0 的中断屏蔽寄存器（PIC0_IMR）进行了修改操作：</p>
<ol>
<li><code>uint8_t mask = inb(PIC0_IMR) &amp; ~(1 &lt;&lt; irq_num);</code><ul>
<li>这行代码首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 0，其它位为 1 的屏蔽码。</li>
<li>最后，通过 <code>&amp;</code> 操作符，将读取的值与生成的屏蔽码进行按位与操作，将指定的中断号 <code>irq_num</code> 对应的位清零。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
<li><code>uint8_t mask = inb(PIC0_IMR) | (1 &lt;&lt; irq_num);</code><ul>
<li>这行代码也是首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 1，其它位为 0 的屏蔽码。</li>
<li>最后，通过 <code>|</code> 操作符，将读取的值与生成的屏蔽码进行按位或操作，将指定的中断号 <code>irq_num</code> 对应的位设置为 1。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
</ol>
<p>这两行代码的目的是对指定的中断号 <code>irq_num</code> 进行屏蔽或解除屏蔽操作，以控制该中断是否被响应。</p>
<h2 id="4-11-启动定时器并打开中断"><a href="#4-11-启动定时器并打开中断" class="headerlink" title="4.11 启动定时器并打开中断"></a>4.11 启动定时器并打开中断</h2><blockquote>
<p>参考资料</p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Programmable_Interval_Timer">osdev关于8253的文档</a></li>
<li><a target="_blank" rel="noopener" href="http://www.osdever.net/bkerndev/Docs/pit.htm">关于8253配置的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第316页</li>
</ul>
</blockquote>
<p>示例：外部中断的产生，以及如何跳转到对应的中断处理程序中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png" alt="image-20240513201126601"></p>
<ul>
<li><p>8253芯片是一个可编程的计时器&#x2F;计数器芯片，它有三个独立的计时器&#x2F;计数器通道（定时器0、定时器1和定时器2）。</p>
<ol>
<li><strong>定时器0</strong>：主要用于系统时钟中断，即产生系统时钟滴答，用于操作系统的时钟中断。这是确保操作系统能够定期执行任务调度和其他定时任务的关键。</li>
<li><strong>定时器1</strong>：通常用于动态内存刷新，但在现代系统中，这一功能已经被集成到内存控制器中，定时器1基本上已经不再使用。</li>
<li><strong>定时器2</strong>：常用于扬声器的声音发生。在大多数系统中，如果没有特别的需求，也不需要初始化定时器2。</li>
</ol>
</li>
<li><p>定时器0的初始化原因</p>
<ul>
<li><p>系统时钟中断：操作系统依赖于系统时钟中断来管理时间和任务调度。通过定时器0，操作系统可以产生定时中断（通常是每秒多次），以进行以下任务：</p>
<ul>
<li><p><strong>任务调度</strong>：定时中断使得操作系统能够在多任务环境中切换任务。</p>
</li>
<li><p><strong>系统时间更新</strong>：维护系统的时间和日期。</p>
</li>
<li><p><strong>超时处理</strong>：处理某些操作的超时功能。</p>
</li>
</ul>
</li>
<li><p>通常的配置方式：初始化定时器0时，设置它为重复模式（模式3，即方波模式），并指定合适的计数值，以产生所需频率的中断。例如，如果需要每秒产生100个中断（100Hz），则可以根据时钟频率和目标频率计算合适的计数值。</p>
</li>
</ul>
</li>
<li><p>初始化定时器0的步骤</p>
<p><strong>本项目中，只需要一个可以周期性产生中断的定时器，无需考虑各种硬件方面的东西。</strong>因此，只需要将定时器设置成自动周期性触发中断即可，而模式<code>3</code>可以方便的实现此功能，因此选用的模式<code>3</code>其它模式较为复杂，有的需要和硬件配合，有的需要在中断中重新配置定时器，所以没有使用这些模式。</p>
</li>
</ul>
<p><code>8253</code>端口地址与说明</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405140922412.png" alt="image-20240514092203861"></p>
<blockquote>
<p>（注：无论是手册上还是各种资料上关于工作模式都讲得过细，特别是有些资料还讲了一些<code>8253</code>硬件输出信号的问题。这些与我们的操作系统设计没什么关系，不用看，直接跳过即可。)</p>
</blockquote>
<ul>
<li><p>定时器工作原理</p>
<p>8253&#x2F;8254定时器芯片的工作原理是基于一个固定频率的晶体振荡器（例如1193182 Hz）。该芯片有三个独立的计数器，每个计数器都有一个初始计数值，从这个值开始<strong>倒计时</strong>。倒计时完成后，计数器会溢出，触发一个中断或者在输出引脚上产生一个信号。</p>
</li>
<li><p>初始计数值的作用</p>
<ul>
<li>控制中断频率</li>
</ul>
<ul>
<li><p>通过设置不同的初始计数值，可以控制定时器的中断频率。初始计数值越大，倒计时的时间越长，生成中断的频率就越低。反之，初始计数值越小，倒计时的时间越短，生成中断的频率就越高。</p>
</li>
<li><p>具体来说，计数器的倒计时周期是晶体振荡器周期和初始计数值的乘积。假设晶体振荡器频率为<code>1193182 Hz</code>，初始计数值为计数器倒计时的周期数，那么<code>中断频率（Hz） = 振荡器频率（Hz） / 初始计数值</code>。</p>
</li>
</ul>
</li>
<li><p>计算初始计数值</p>
<p>假设我们想设置定时器<code>0</code>生成每秒<code>100</code>次的中断（即中断频率为<code>100 Hz</code>），我们需要计算初始计数值如下：</p>
<p><code>初始计数值=振荡器频率/中断频率=1193182/100=11931</code></p>
<p>这意味着，我们将定时器<code>0</code>的初始计数值设置为<code>11931</code>，它将在每经过<code>11931</code>个时钟周期后触发一次中断，产生<code>100 Hz</code>的中断频率。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception_handler time, 0x20, 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x20</code>：将<code>8253</code>芯片关联到<code>8259</code>的<code>IRQ0</code>端口，而<code>8259</code>的起始地址为<code>0x20</code>。</li>
</ul>
<h1 id="五、日志与printf格式化输出"><a href="#五、日志与printf格式化输出" class="headerlink" title="五、日志与printf格式化输出"></a>五、日志与printf格式化输出</h1><h2 id="5-1-创建日志打印接口"><a href="#5-1-创建日志打印接口" class="headerlink" title="5.1 创建日志打印接口"></a>5.1 创建日志打印接口</h2><p><strong>在操作系统内核中编写日志接口时，通常不使用C库自带的<code>printf</code>函数。</strong>这是由于以下几个关键原因：</p>
<ol>
<li><p><strong>依赖性和可移植性</strong></p>
<ul>
<li><p><strong>标准库依赖性</strong>：<code>printf</code>是标准C库的一部分，它依赖于操作系统提供的底层设施（如文件系统、IO设备、内存管理等）。在操作系统内核早期启动阶段，这些设施可能尚未初始化。</p>
</li>
<li><p><strong>可移植性问题</strong>：不同的标准库实现可能有所不同，在某些平台上，标准库可能并不适用于内核空间。</p>
</li>
</ul>
</li>
<li><p><strong>内核空间和用户空间的区别</strong></p>
<ul>
<li><p><strong>内核空间和用户空间</strong>：标准库函数如<code>printf</code>通常在用户空间中运行，而操作系统内核运行在特权的内核空间。内核代码需要直接访问硬件和内存管理，这些功能在用户空间的标准库中不可用。</p>
</li>
<li><p><strong>上下文切换</strong>：使用标准库函数可能会引起不必要的上下文切换和中断，这在内核模式下可能是不允许的或是效率低下的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><p><strong>内存管理</strong>：内核必须处理自己的内存分配和管理，而标准C库中的<code>printf</code>会隐含地调用一些内存管理函数，这可能与内核的内存管理机制冲突。</p>
</li>
<li><p><strong>线程安全性</strong>：<code>printf</code>在多线程环境下的行为在内核中可能不可靠，因为内核需要处理并发性和同步问题。</p>
</li>
</ul>
</li>
<li><p><strong>性能和实时性要求</strong></p>
<ul>
<li><p><strong>性能</strong>：内核态代码通常需要高效和快速地执行，标准库的<code>printf</code>包含复杂的格式解析和输出操作，这可能带来不必要的性能开销。</p>
</li>
<li><p><strong>实时性</strong>：内核中某些操作需要实时响应，而<code>printf</code>的执行时间不可预测，这可能导致内核无法满足实时性要求。</p>
</li>
</ul>
</li>
<li><p><strong>调试和错误处理</strong></p>
<ul>
<li><p><strong>错误处理</strong>：内核需要处理低级错误，而<code>printf</code>可能引入新的故障点。例如，<code>printf</code>依赖的某些资源在内核执行时不可用或已被其他部分使用。</p>
</li>
<li><p><strong>调试支持</strong>：在内核开发过程中，使用自定义的日志函数可以提供更多控制和定制，便于内核态调试和问题追踪。</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-2-实现基本的信息输出"><a href="#5-2-实现基本的信息输出" class="headerlink" title="5.2 实现基本的信息输出"></a>5.2 实现基本的信息输出</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141437793.png" alt="image-20240514143659706"></p>
<p>在以前的计算机中有一个<code>9</code>针的串行接口<code>RS-232</code>，有两根数据线，双向通信，分别用于发送和接收数据。<strong>在本项目中会用到这个接口来实现数据的发送的接收。</strong></p>
<p>虽然现在的计算机上没有这种接口了，但是<code>QEMU</code>依然支持这种接口。选择<code>[view-&gt;serial0]</code>，则会连接到串行接口，并将串行接口发出的数据显示到此处，而不是显示在显示器上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141441877.png" alt="image-20240514144102736"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/cpu_instr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM1_PORT 0x3F8     <span class="comment">// 串行接口初始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = fmt;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="5-3-实现字符串的格式化输出"><a href="#5-3-实现字符串的格式化输出" class="headerlink" title="5.3 实现字符串的格式化输出"></a>5.3 实现字符串的格式化输出</h2><h3 id="1、字符串的常规处理"><a href="#1、字符串的常规处理" class="headerlink" title="1、字符串的常规处理"></a>1、字符串的常规处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KLIB_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strcopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strncopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> v, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_memcmp</span><span class="params">(<span class="type">void</span> *d1, <span class="type">void</span> *d2, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _KLIB_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2、字符串的格式化输出"><a href="#2、字符串的格式化输出" class="headerlink" title="2、字符串的格式化输出"></a>2、字符串的格式化输出</h3><ol>
<li><p><strong>枚举类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br></pre></td></tr></table></figure>

<p>定义一个无名枚举类型，包含两个状态 <code>NORMAL</code> 和 <code>READ_FMT</code>，并将 <code>state</code> 变量初始化为 <code>NORMAL</code>。</p>
</li>
<li><p><strong>可变参数函数</strong><br>在 C 语言中，可以定义一个函数，使其接受可变数量的参数。这些函数通常使用 <code>&lt;stdarg.h&gt;</code> 中的宏来处理可变参数。下面是一些相关的宏：</p>
<ul>
<li><p><code>va_list</code>：声明一个变量，该变量用于访问可变参数列表。</p>
</li>
<li><p><code>va_start</code>：初始化一个 <code>va_list</code> 变量，使其指向第一个可变参数。</p>
</li>
<li><p><code>va_end</code>：清理 <code>va_list</code> 变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va_list args;  <span class="comment">// 声明va_list变量</span></span><br><span class="line">va_start(args, fmt);  <span class="comment">// 指向第一个可变参数</span></span><br><span class="line">va_end(args);  <span class="comment">// 释放args</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>va_arg</code>：获取可变参数列表中的下一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);</span><br><span class="line"><span class="comment">// 第一个参数是va_list变量</span></span><br><span class="line"><span class="comment">// 第二个参数是期望的参数类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    num = 12345 -&gt; 10</span></span><br><span class="line"><span class="comment">    1. 12345 % 10 = 5   12345 / 10 = 1234</span></span><br><span class="line"><span class="comment">    2. 1234  % 10 = 4   1234  / 10 = 123</span></span><br><span class="line"><span class="comment">    3. 123   % 10 = 3   123   / 10 = 12</span></span><br><span class="line"><span class="comment">    4. 12    % 10 = 2   12    / 10 = 1</span></span><br><span class="line"><span class="comment">    5. 1     % 10 = 1   1     / 10 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_itoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *num2ch = &#123;<span class="string">&quot;0123456789ASBCDEF&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> is_negative = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅处理2/8/10/16进制</span></span><br><span class="line">    <span class="keyword">if</span> ((base != <span class="number">2</span>) &amp;&amp; (base != <span class="number">8</span>) &amp;&amp; (base != <span class="number">10</span>) &amp;&amp; (base != <span class="number">16</span>)) &#123;</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若为负数，则添加负号</span></span><br><span class="line">    <span class="keyword">if</span> ((num &lt; <span class="number">0</span>) &amp;&amp; (base == <span class="number">10</span>)) &#123;</span><br><span class="line">        is_negative = <span class="number">1</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// num to string</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch = num2ch[num % base];</span><br><span class="line">        *p++ = ch;</span><br><span class="line">        num /= base;       </span><br><span class="line">    &#125;<span class="keyword">while</span> (num);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">// 若为负数，添加负号，注意放到最后以便后续进行翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转字符串</span></span><br><span class="line">    <span class="type">char</span> *start = buf;</span><br><span class="line">    <span class="type">char</span> *end = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> ch = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = ch;</span><br><span class="line"></span><br><span class="line">        end--;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_printf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Version: %s&quot;, &quot;1.0.0&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">    <span class="comment">// NORMAL：原样输出状态  READ_FMT：格式化输出状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br><span class="line">    <span class="type">char</span> *curr = buf;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                state = READ_FMT;  <span class="comment">// 当遇到&#x27;%&#x27;时需要切换到格式化输出状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *curr++ = ch;   <span class="comment">// 否则直接原样输出即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> READ_FMT:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">10</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">16</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> c = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                *curr++ = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);  <span class="comment">// 此时const char *str = &quot;1.0.0&quot;</span></span><br><span class="line">                <span class="type">int</span> len = kernel_strlen(str);</span><br><span class="line">                <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                    *curr++ = *str++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = NORMAL;  <span class="comment">// 处理完可变参数，切换回NORMAL状态</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-利用assert辅助调试"><a href="#5-4-利用assert辅助调试" class="headerlink" title="5.4 利用assert辅助调试"></a>5.4 利用assert辅助调试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RELEASE  <span class="comment">// 若未定义RELEASE版本，说明在调试状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) pannic(__FILE__, __LINE__, __func__, #expr);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pannic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、实现简单的进程切换"><a href="#六、实现简单的进程切换" class="headerlink" title="六、实现简单的进程切换"></a>六、实现简单的进程切换</h1><h2 id="6-1-添加任务状态段"><a href="#6-1-添加任务状态段" class="headerlink" title="6.1 添加任务状态段"></a>6.1 添加任务状态段</h2><p><strong>目前的代码中，中断处理程序处理中断相关的工作，主程序负责执行所有其它工作</strong>（仅考虑只有一个CPU内核的情况）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142022102.png" alt="image-20240514202203665" style="zoom: 50%;" />

<p>借助于操作系统的进程切换机制，我们可以同时运行多个程序。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142023040.png" alt="image-20240514202342715" style="zoom:50%;" />

<p>现在考虑实现这样一个任务，即利用进程切换机制，同时实现以下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init task: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init main: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、理论基础-8"><a href="#1、理论基础-8" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>操作系统为了让CPU能够同时执行多个程序，在切换到另一个程序运行前需要<strong>记录当前程序的运行状态</strong>。<br>这样当程序再次运行时，才能够恢复到之前的运行状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142039947.png" alt="image-20240514203914718" style="zoom:50%;" />

<ul>
<li><code>TSS/Task-State Segment</code>：保存当前程序的运行状态。（用<code>Task</code>表示进程的运行状态）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142038829.png" alt="image-20240514203814450"></p>
<h3 id="2、TSS定义"><a href="#2、TSS定义" class="headerlink" title="2、TSS定义"></a>2、TSS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TSS/Task-State Segment r 任务状态段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tss_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> pre_link;      <span class="comment">// 上一个任务链接</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0, ss0;     <span class="comment">// 内核模式下的栈指针和栈段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> esp1, ss1;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp2, ss2;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;           <span class="comment">// 页目录基地址寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;           <span class="comment">// 指令指针寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eflags;        <span class="comment">// 标志寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi; <span class="comment">// 通用寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> es, cs, ss, ds, fs, gs; <span class="comment">// 段寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> ldt;           <span class="comment">// 局部描述符表的段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> iomap;         <span class="comment">// I/O许可位图的基地址</span></span><br><span class="line">&#125;<span class="type">tss_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>TSS</code>如何描述任务状态？</p>
<ul>
<li><p><code>TSS</code>中各字段的分类</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142050761.png" alt="image-20240514205059174"></p>
</li>
<li><p>程序的运行状态，包含了诸多信息：</p>
<ul>
<li>当前正执行哪些代码、有哪些数据、使用了哪块区域做堆栈、当前执行指令的地址、前一指令的运行状态、运算所用的寄存器信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142057431.png" alt="image-20240514205712046"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142115267.png" alt="image-20240514211539824"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142117502.png" alt="image-20240514211733961"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142118228.png" alt="image-20240514211833645"></p>
</li>
</ul>
<h2 id="6-2-任务的简单初始化"><a href="#6-2-任务的简单初始化" class="headerlink" title="6.2 任务的简单初始化"></a>6.2 任务的简单初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *      TSS Initialization </span></span><br><span class="line"><span class="comment"> *      当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    kernel_memset(&amp;task-&gt;tss, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;tss));</span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;  <span class="comment">// 由于第一次运行，因此寄存器设置为默认的选择子</span></span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = KERNEL_SELECTOR_DS;</span><br><span class="line">    task-&gt;tss.cs = KERNEL_SELECTOR_CS;</span><br><span class="line">    task-&gt;tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-简单双任务相互切换"><a href="#6-3-简单双任务相互切换" class="headerlink" title="6.3 简单双任务相互切换"></a>6.3 简单双任务相互切换</h2><h3 id="1、理论"><a href="#1、理论" class="headerlink" title="1、理论"></a>1、理论</h3><p><code>x86</code>硬件对于任务的管理包括：</p>
<ul>
<li><code>Task Register/TR寄存器</code>：保存了<code>Task</code>相关的选择子</li>
<li><code>TSS</code>描述符：<code>GDT</code>表中的<code>TSS Desc</code>表项，每个<code>TSS</code>有自己对应的描述符</li>
<li><code>TSS</code></li>
<li>任务的代码、数据和栈空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150949978.png" alt="image-20240515094947839"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150958664.png" alt="image-20240515095802569"></p>
<h3 id="2、采用JMP进行任务切换"><a href="#2、采用JMP进行任务切换" class="headerlink" title="2、采用JMP进行任务切换"></a>2、采用JMP进行任务切换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151000598.png" alt="image-20240515100023458" style="zoom:50%;" />

<blockquote>
<p>解答一下<code>task init(&amp;first task,0,0)</code>两个参数为<code>0</code>的问题：由于<code>first task</code>在<code>kernel</code>跑起来后已经运行，因此并不需要从<code>tss</code>中加载初始化的值，所以里面的值无所谓，并且在后面切换到<code>init task</code>时会因保存状态而被改写。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// ?-&gt;看上面的引用部分，有相关解释</span></span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 远跳转实现任务切换 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span> <span class="params">(<span class="type">int</span> tss_sel)</span> &#123;</span><br><span class="line">    far_jump(tss_sel, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-另一种任务切换方式"><a href="#6-4-另一种任务切换方式" class="headerlink" title="6.4 另一种任务切换方式"></a>6.4 另一种任务切换方式</h2><h3 id="1、理论基础-9"><a href="#1、理论基础-9" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>任务切换的本质是保存前一任务的运行状态，恢复下一任务的运行状态。</p>
</blockquote>
<p>硬件实际上会帮助我们去自动保存这些状态，但是如果采用手动保存的方式，切换会更快。</p>
<p>需要保存的状态如下。<strong>可以为这些状态单独设置空间保存，也可以直接将其保存在任务自己的栈中。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151054801.png" alt="image-20240515105445584" style="zoom:50%;" />

<p>当然，对于上述状态也可以进行选择性保存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151058922.png" alt="image-20240515105836713"></p>
<p>因此，最终只需要保存少量的寄存器就可以实现任务切换：</p>
<ul>
<li>注意<code>esp</code>指示此处的栈顶位置，因此要在别处单独存放。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151454378.png" alt="image-20240515145411029" style="zoom:50%;" />

<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    *<span class="built_in">stack</span>;     <span class="comment">// 当前Task的任务栈</span></span><br><span class="line">    <span class="type">tss_t</span>       tss;        <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;    <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;init-&gt;init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;core-&gt;task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tss_init(task, entry, esp);</span></span><br><span class="line">    <span class="type">uint32_t</span> *pesp = (<span class="type">uint32_t</span> *)esp;  <span class="comment">// 取出当前栈顶指针</span></span><br><span class="line">    <span class="keyword">if</span> (pesp) &#123;  </span><br><span class="line">        <span class="comment">// 将任务入口地址入栈</span></span><br><span class="line">        *(--pesp) = entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置edi, esi, ebx, ebp</span></span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前栈指针保存到任务结构体中</span></span><br><span class="line">        task-&gt;<span class="built_in">stack</span> = pesp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      **from      指向[当前任务的栈指针]的指针</span></span><br><span class="line"><span class="comment"> *      *to         指向[新任务]的栈指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">simple_switch</span> <span class="params">(<span class="type">uint32_t</span> **from, <span class="type">uint32_t</span> *to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    <span class="comment">// switch_to_tss(to-&gt;tss_sel);</span></span><br><span class="line">    simple_switch(&amp;from-&gt;<span class="built_in">stack</span>, to-&gt;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">simple_switch:</span><br><span class="line">    # 向当前Task对应的栈压栈</span><br><span class="line">    mov 4(%esp), %eax    # 将当前任务的栈指针地址（**from）传递给eax</span><br><span class="line">    mov 8(%esp), %edx    # 将下一个任务的栈指针地址（*to）传递给edx</span><br><span class="line"></span><br><span class="line">    push %ebp            # 保存当前任务的ebp寄存器</span><br><span class="line">    push %ebx            # 保存当前任务的ebx寄存器</span><br><span class="line">    push %esi            # 保存当前任务的esi寄存器</span><br><span class="line">    push %edi            # 保存当前任务的edi寄存器</span><br><span class="line"></span><br><span class="line">    # 从另一个任务的栈中出栈</span><br><span class="line">    mov %esp, (%eax)     # 保存当前任务的esp到eax指向的内存中（保存当前任务的栈指针）</span><br><span class="line">    mov %edx, %esp       # 切换到下一个任务的栈指针（esp指向新任务的栈顶）</span><br><span class="line">    pop %edi             # 恢复下一个任务的edi寄存器</span><br><span class="line">    pop %esi             # 恢复下一个任务的esi寄存器</span><br><span class="line">    pop %ebx             # 恢复下一个任务的ebx寄存器</span><br><span class="line">    pop %ebp             # 恢复下一个任务的ebp寄存器</span><br><span class="line"></span><br><span class="line">    ret                  # 返回，切换到下一个任务的执行</span><br></pre></td></tr></table></figure>

<h1 id="七、实现链表数据结构"><a href="#七、实现链表数据结构" class="headerlink" title="七、实现链表数据结构"></a>七、实现链表数据结构</h1><h2 id="7-1-定义结点和链表"><a href="#7-1-定义结点和链表" class="headerlink" title="7.1 定义结点和链表"></a>7.1 定义结点和链表</h2><p>在进程运行过程中，可能因为多种原因需要等待，从而加入相应的等待队列中。如下图共有三个队列，其中就绪队列中的进程已经准备好了，随时可以运行，只是在等待处理器空闲。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151550561.png" alt="image-20240515155011285" style="zoom:50%;" />

<p>考虑到系统中可能有很多进程，因此采用链表结构进行管理。</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240515155549617.png" alt="image-20240515155549617" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">list_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_node_init</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    node-&gt;pre = node-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_pre</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_next</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_node_t</span> *first;</span><br><span class="line">    <span class="type">list_node_t</span> *last;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;<span class="type">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-链表的两种插入"><a href="#7-2-链表的两种插入" class="headerlink" title="7.2 链表的两种插入"></a>7.2 链表的两种插入</h2><h3 id="1、头插"><a href="#1、头插" class="headerlink" title="1、头插"></a>1、头插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151634229.png" alt="image-20240515163412939" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插</span></span><br><span class="line"><span class="comment"> * @param list 待插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    node-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整first指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first-&gt;pre = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、尾插"><a href="#2、尾插" class="headerlink" title="2、尾插"></a>2、尾插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151730245.png" alt="image-20240515173058966" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_last</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>-&gt;last;</span><br><span class="line">    node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整last指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-链表的两种删除"><a href="#7-3-链表的两种删除" class="headerlink" title="7.3 链表的两种删除"></a>7.3 链表的两种删除</h2><h3 id="1、头删"><a href="#1、头删" class="headerlink" title="1、头删"></a>1、头删</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731170.png" alt="image-20240515173113880" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头删</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @return 链表的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span>* <span class="title function_">list_remove_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// list为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取要删除的结点</span></span><br><span class="line">    <span class="type">list_node_t</span> * remove_node = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改first指向</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;first == (<span class="type">list_node_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，修改last也指向空</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若list非空，修改当前first的前驱为0</span></span><br><span class="line">        remove_node-&gt;next-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改node的pre和next为0</span></span><br><span class="line">    remove_node-&gt;next = remove_node-&gt;pre = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、删除任意结点"><a href="#2、删除任意结点" class="headerlink" title="2、删除任意结点"></a>2、删除任意结点</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731210.png" alt="image-20240515173125900" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意结点，但不检查node是否在list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span> * <span class="title function_">list_remove</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *remove_node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是头，则头往前移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;first) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是尾，则尾往回移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;last) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有前，则调整前的后继</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;pre) &#123;</span><br><span class="line">        remove_node-&gt;pre-&gt;next = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有后，则调整后的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;next) &#123;</span><br><span class="line">        remove_node-&gt;next-&gt;pre = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空node指向</span></span><br><span class="line">    remove_node-&gt;pre = remove_node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-获取结点所在的结构"><a href="#7-4-获取结点所在的结构" class="headerlink" title="7.4 获取结点所在的结构"></a>7.4 获取结点所在的结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152028459.png" alt="image-20240515202836119"></p>
<p>对下图的解释：</p>
<p>比如说对于下图的<code>node</code>，要取其地址用到了<code>&amp;(a-&gt;node)</code>，这一行代码实际上是完成了<code>a的基地址+offset(node相对于基地址的offset)</code>这个操作。</p>
<p>因此，如果要求解这一段<code>offset</code>，就可以假定在最开始有一个和<code>node</code>同类型的数据，这样<code>a的基地址</code>这一项就为<code>0</code>，所以求解到的就是<code>offset</code>的值。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152033989.png" alt="image-20240515203321728"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br><span class="line"><span class="comment">// parent_addr  --  parent的起始地址</span></span><br><span class="line"><span class="comment">// node         --  node的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) -  offset_in_parent(parent_type, node_name))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>offset_in_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：计算一个节点在其父结构体中的偏移量。</li>
<li>参数<ul>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过将一个空指针类型转换为 <code>parent_type</code> 并访问 <code>node_name</code> 成员，然后取该成员的地址。由于起始地址为0，这样计算出的地址即为偏移量。</li>
</ul>
</li>
<li><p><strong>parent_addr</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) - offset_in_parent(parent_type, node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址推导出包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过节点地址减去节点在父结构体中的偏移量来获取父结构体的地址。</li>
</ul>
</li>
<li><p><strong>list_node_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址安全地获取包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：如果节点不为 <code>NULL</code>，则调用 <code>parent_addr</code> 宏；否则返回 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_test</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_t</span> <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">list_node_t</span> nodes[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    list_init(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *node = nodes + i;</span><br><span class="line">        log_printf(<span class="string">&quot;insert first to list: %d, 0x%x&quot;</span>, i, (<span class="type">uint32_t</span>)node);</span><br><span class="line">        list_insert_first(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    log_printf(<span class="string">&quot;list: first=0x%x, last=0x%x, count=%d&quot;</span>,</span><br><span class="line">        list_first(&amp;<span class="built_in">list</span>), list_last(&amp;<span class="built_in">list</span>), list_count(&amp;<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">list_node_t</span> node;</span><br><span class="line">    &#125;v = &#123;<span class="number">0x123456</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> <span class="type">type_t</span> *)<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr = (<span class="type">uint32_t</span>)&amp;a-&gt;node;  <span class="comment">// 4                        </span></span><br><span class="line">    <span class="type">uint32_t</span> addr_p = offset_in_parent(<span class="keyword">struct</span> <span class="type">type_t</span>, node);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已知node的起始地址，利用定义的宏求解v的起始地址</span></span><br><span class="line">    <span class="type">list_node_t</span> *v_node = &amp;v.node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">p</span> =</span> list_node_parent(v_node, <span class="keyword">struct</span> <span class="type">type_t</span>, node);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;i != <span class="number">0x123456</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、进程的管理与延时"><a href="#八、进程的管理与延时" class="headerlink" title="八、进程的管理与延时"></a>八、进程的管理与延时</h1><h2 id="8-1-添加任务管理器"><a href="#8-1-添加任务管理器" class="headerlink" title="8.1 添加任务管理器"></a>8.1 添加任务管理器</h2><p>截止目前，只支持两个任务，切需要进程自己主动切换，不支持延时等功能。因此需要对功能进行拓展。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152102022.png" alt="image-20240515210203823" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_t</span> ready_list;  <span class="comment">// 就绪队列</span></span><br><span class="line">    <span class="type">list_t</span> task_list;   <span class="comment">// 所有已创建队列</span></span><br><span class="line">    <span class="type">task_t</span> first_task;  <span class="comment">// 最先创建的任务</span></span><br><span class="line">    <span class="type">task_t</span> *curr_task;  <span class="comment">// 当前正在进行的任务</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 任务管理器初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 初始任务初始化</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回first task</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>; <span class="comment">// 设置当前任务为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="number">0</span>, <span class="number">0</span>);  		<span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);          <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;task_manager.first_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-将任务加入就绪队列"><a href="#8-2-将任务加入就绪队列" class="headerlink" title="8.2 将任务加入就绪队列"></a>8.2 将任务加入就绪队列</h2><p>当任务已经初始化完成时，进入<code>created</code>状态；当加入就绪队列时，进入<code>ready</code>状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152123227.png" alt="image-20240515212313112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// uint32_t    *stack;      // 当前Task的任务栈（采用链表管理任务时不再采用stack，直接用硬件的TSS支持切换）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>                      <span class="comment">// 任务状态</span></span><br><span class="line">        TASK_CREATED,</span><br><span class="line">        TASK_RUNNING,</span><br><span class="line">        TASK_SLEEP,</span><br><span class="line">        TASK_READY,</span><br><span class="line">        TASK_WAITING,</span><br><span class="line">    &#125;state;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[TASK_NAME_SIZE];  <span class="comment">// 任务名称</span></span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> run_node;       <span class="comment">// run_node插入ready_list中，而非将整个task_t加入</span></span><br><span class="line">    <span class="type">list_node_t</span> all_node;       <span class="comment">// all_node插入task_list中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span>       tss;            <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;        <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_insert_first(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-任务主动放弃CPU"><a href="#8-3-任务主动放弃CPU" class="headerlink" title="8.3 任务主动放弃CPU"></a>8.3 任务主动放弃CPU</h2><p>为了避免某个进程长时间占用CPU，可以让进程主动释放CPU的使用权，但不应当让进程指定切换到哪个进程运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161022580.png" alt="image-20240516102215352"></p>
<p><strong>简单起见，当进程需要让出CPU时，只需要将自己移到就绪队列的尾部即可。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161024659.png" alt="image-20240516102441540" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现用到了7.4所设计的宏</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_current</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task_manager.curr_task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sched_yield</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前就绪队列是否还有其他任务</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取当前任务，并将其重新加入到就绪队列尾部</span></span><br><span class="line">        <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放CPU使用权，将进程切换到当前就绪队列的第一个任务</span></span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();</span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 解析上述代码</p>
</blockquote>
<p>根据<code>sys_sched_yield();</code>改写了整个任务切换的逻辑，不再由当前进程指定要切换到哪一个进程中，而是：</p>
<ol>
<li>当前进程放弃CPU使用权，重新移动到就绪队列的尾部；</li>
<li>从就绪队列中获取下一个要执【【行的任务<code>task_t *to = task_next_run()</code>；</li>
<li>定义[原来正在运行的任务]为[将要被切换掉的任务]<code>task_t *from = task_current()</code>；</li>
<li>将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]<code>task_manager.curr_task = to</code>；</li>
<li>修改此任务的状态为<code>TASK_RUNNING</code>；</li>
<li>执行任务切换<code>task_switch_from_to(from, to)</code>。</li>
</ol>
<h2 id="8-4-让进程按时间片运行"><a href="#8-4-让进程按时间片运行" class="headerlink" title="8.4 让进程按时间片运行"></a>8.4 让进程按时间片运行</h2><p><code>sys_sched_yield()</code>必须由进程主动调用才能放弃CPU，如果不主动调用，进程仍然长期占用CPU。为了避免进程长时间占用CPU，可以强制其运行一定时间后释放CPU。</p>
<p><strong>本项目中选择[一段时间]为<code>100ms</code>。</strong>通过<code>task_time_tick()</code>函数实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161046155.png" alt="image-20240516104613960" style="zoom:50%;" />

<p>注意：需要在<code>init.c</code>中开启全局中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    irq_enable_global();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sys_sched_yield();  注意要注释掉这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来对<code>task_init</code>进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务结点</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task-&gt;time_ticks = TASK_TIME_SLICE_DEFAULT;</span><br><span class="line">    task-&gt;slice_ticks = task-&gt;time_ticks;</span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>time.c</code>中加入任务相关的中断处理<code>task_time_tick()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_time</span> <span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    sys_tick++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向8259通知对应的中断已完成</span></span><br><span class="line">    pic_send_eoi(IRQ0_TIMER);</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task_time_tick();  <span class="comment">// 任务相关的处理</span></span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里<code>pic_send_eoi(IRQ0_TIMER);</code>和<code>task_time_tick();</code>的顺序不能错。原因如下：、</p>
<blockquote>
<p>在中断处理程序 <code>do_handler_time</code> 中，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的顺序不能交换，主要是为了保证中断的正确处理和系统的稳定运行。以下是详细解释：</p>
<ul>
<li><code>pic_send_eoi</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pic_send_eoi</span> <span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">    irq_num -= IRQ_PIC_START;  <span class="comment">// 将irq_num变为内部序号</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        outb(PIC1_OCW2, PIC_OCW2_EOI);  <span class="comment">// 向第二块8259发送eoi指令</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(PIC0_OCW2, PIC_OCW2_EOI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数向 8259 可编程中断控制器 (PIC) 发送中断结束信号 (EOI)，通知 PIC 当前中断已经处理完毕，可以接受新的中断请求。这个过程非常关键，因为它控制着中断的优先级和处理顺序。</p>
<ul>
<li><code>task_time_tick</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前任务的时间切片在运行后减少为0，说明需要对其进行任务切换</span></span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新设置时间切片</span></span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_ticks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行任务切换</span></span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数处理与任务调度相关的逻辑，例如更新当前任务的时间片，并在需要时触发任务切换。</p>
<ul>
<li>不能交换顺序的原因</li>
</ul>
<ol>
<li><strong>中断优先级控制</strong>：<ul>
<li>在中断处理程序中，优先向 PIC 发送 EOI 信号，确保 PIC 能够继续处理其他中断。这可以防止中断嵌套过多，避免中断响应延迟。</li>
</ul>
</li>
<li><strong>任务切换时的安全性</strong>：<ul>
<li><code>task_time_tick</code> 可能会触发任务切换，这意味着当前任务的上下文（CPU 寄存器状态、栈指针等）可能会被保存，并切换到另一个任务的上下文。如果在 <code>task_time_tick</code> 中执行任务切换之前没有发送 EOI 信号，可能会导致中断处理未完全结束就切换到另一个任务，造成中断处理不完整或混乱。</li>
</ul>
</li>
<li><strong>系统稳定性</strong>：<ul>
<li>及时发送 EOI 信号可以确保系统中断处理机制的稳定性，避免中断嵌套层数过多，导致系统无法及时响应其他硬件中断请求。</li>
</ul>
</li>
</ol>
<p>因此，将 <code>task_time_tick</code> 放在 <code>pic_send_eoi</code> 之后，可以确保在进行任务切换等复杂操作前，已经通知 PIC 当前中断处理完毕。这种顺序确保了中断处理的及时性和系统的稳定性。因此，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的调用顺序不能交换。</p>
</blockquote>
<p>最后的实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161536876.png" alt="image-20240516153646690"></p>
<h2 id="8-5-临界资源与临界区"><a href="#8-5-临界资源与临界区" class="headerlink" title="8.5 临界资源与临界区"></a>8.5 临界资源与临界区</h2><p>上述任务存在一些问题，即：<strong>在两个任务进行切换的时刻输出的信息是乱的。</strong>因此需要对其进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161540957.png" alt="image-20240516154041859"></p>
<h3 id="1、理论基础-10"><a href="#1、理论基础-10" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><ul>
<li><p>并发与并行</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161541337.png" alt="image-20240516154127142"></p>
<p>因此，当多个进程或任务共同访问统一资源时，有可能产生冲突。</p>
<p>如下图所示，假设<code>first_task</code>此时运行到<code>log_printf</code>函数时，正在执行串口输出，且时间较长。由于任务间按时间片方式轮流执行，因此可能输出到一半时<code>first_task</code>的时间片用完了，正好定时器中断也到了，那么此时就会将任务切换到<code>init_task</code>，会接下来打印<code>init_task</code>的信息，从而造成输出信息混乱。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161544397.png" alt="image-20240516154434937"></p>
</li>
<li><p>临界资源和临界区</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161548492.png" alt="image-20240516154831083"></p>
</li>
</ul>
<h3 id="2、互斥实现"><a href="#2、互斥实现" class="headerlink" title="2、互斥实现"></a>2、互斥实现</h3><p>解决方法1：互斥。即一次只允许一个进程在临界区中。互斥的实现方法之一是：禁用中断。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161550138.png" alt="image-20240516155039989" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">irq_state_t</span>;</span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 进入临界区保护状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span>;  <span class="comment">// 退出临界区保护状态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过关闭中断的方式实现互斥，主要需要保存进入临界区之前中断的开关状态，避免退出时意外开启中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取原中断状态</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = read_eflags();</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    irq_disable_global();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span> &#123;</span><br><span class="line">    <span class="comment">// 写回中断状态，若原中断为关闭状态，则保持；若原中断为开启状态，则恢复打开</span></span><br><span class="line">    write_eflags(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">read_eflags</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;pushf\n\tpop %%eax&quot;</span>:<span class="string">&quot;=a&quot;</span>(eflags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_eflags</span> <span class="params">(<span class="type">uint32_t</span> eflags)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;push %%eax\n\tpopf&quot;</span>::<span class="string">&quot;a&quot;</span>(eflags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时切换点会执行完整输出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161610637.png" alt="image-20240516160955146"></p>
<h2 id="8-6-让进程能够延时运行"><a href="#8-6-让进程能够延时运行" class="headerlink" title="8.6 让进程能够延时运行"></a>8.6 让进程能够延时运行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);  <span class="comment">// 需求：每隔一秒输出一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当进程需要延时运行时，应当将其从就绪队列中移出，以免占用CPU；等延时时间到达后，再将其移回就绪队列。</strong>因此，专门设计一个队列，用于放置需要延时的进程。<strong>在每个时钟节拍中断发生时，扫描延时队列，发现延时时间到，则再将进程移回就绪队列尾部。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161656774.png" alt="image-20240516165606592" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">list_t</span> sleep_list;  <span class="comment">// 睡眠队列</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> sleep_ticks;            <span class="comment">// 延时</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span>;  <span class="comment">// 任务加入睡眠队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span>;                 <span class="comment">// 任务移除睡眠队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入睡眠队列的尾部</span></span><br><span class="line"><span class="comment"> * @param ticks 要睡眠的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;sleep_ticks = ticks;</span><br><span class="line">    task-&gt;state = TASK_SLEEP;</span><br><span class="line">    list_insert_last(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除睡眠队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 实现睡眠机制，使当前任务进入睡眠状态一段时间，并切换到其他任务继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务从就绪队列移动到睡眠队列</span></span><br><span class="line">    task_set_block(task_manager.curr_task);</span><br><span class="line">    task_set_sleep(task_manager.curr_task, ms + (OS_TICKS_MS - <span class="number">1</span>) / OS_TICKS_MS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到就绪队列的下一个任务执行</span></span><br><span class="line">    task_dispatch();</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161945180.png" alt="image-20240516194523931"></p>
<h2 id="8-7-让所有进程都能延时"><a href="#8-7-让所有进程都能延时" class="headerlink" title="8.7 让所有进程都能延时"></a>8.7 让所有进程都能延时</h2><p>当所有进程都进入睡眠状态时，就绪队列为空，也就是说在<code>task_dispatch()</code>中，<code>to</code>取出的下一个任务为空，造成操作系统崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过任务队列实现任务切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();		<span class="comment">// !!!!!!!此处!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：当就绪队列为空时，运行<strong>空闲进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">task_t</span> idle_task;   <span class="comment">// 空闲进程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.sleep_list);  <span class="comment">// 初始化睡眠队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>;  <span class="comment">// 设置当前任务为0</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入就绪队列的尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除就绪队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  从就绪队列中选取下一个要运行的任务</span></span><br><span class="line"><span class="comment"> *         这里实际上需要根据run_node取到包含run_node的task的整个结构体的起始地址，</span></span><br><span class="line"><span class="comment"> *         因为对于要对task进行操作的函数来说，需要操作的是task这个整体</span></span><br><span class="line"><span class="comment"> * @return 指向该任务的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若就绪队列为空，运行空闲进程</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;task_manager.idle_task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162010349.png" alt="image-20240516201030225"></p>
<h1 id="九、进程间的同步与互斥"><a href="#九、进程间的同步与互斥" class="headerlink" title="九、进程间的同步与互斥"></a>九、进程间的同步与互斥</h1><h2 id="9-1-计数信号量及其初始化"><a href="#9-1-计数信号量及其初始化" class="headerlink" title="9.1 计数信号量及其初始化"></a>9.1 计数信号量及其初始化</h2><h3 id="1、理论基础-11"><a href="#1、理论基础-11" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在多进程运行环境中，进程之间、进程与中断之间需要协作，也可以通过信号来同步行为。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162022801.png" alt="image-20240516202243580" style="zoom:50%;" />

<p>为实现这种行为上的同步，需要提供两种操作，等信号和发信号，且在某些情况下，可能连续发多次信号，因此可以将发送的信号数记录下来。</p>
<ul>
<li>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</li>
<li>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</li>
</ul>
<blockquote>
<p><strong>可以类比停车场停车。</strong></p>
<p>等信号相当于车辆进入停车场，信号计数相当于空车位。</p>
<ul>
<li>信号计数为0相当于没有空车位，因此车辆需要等待（即进程等待）；</li>
<li>若信号计数不为0，则当前有空车位，车辆可以驶入（即进程执行），而空车位的数量要减1。</li>
</ul>
<p>发信号则相当于车辆离开停车场。</p>
<ul>
<li>若此时恰好有另一辆车要进入（待执行进程），那么这辆车可以直接进入（待执行进程被唤醒），空车位数不变（信号量不变）；</li>
<li>否则，空车位数加1（信号量加1）。</li>
</ul>
</blockquote>
<p>计数信号量：包含1）一个计数器，以及2）当计数为0时让进程排队等待的队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162035492.png" alt="image-20240516203555357" style="zoom:50%;" />

<h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><p>新建<code>ipc</code>目录。</p>
<blockquote>
<p>IPC（Inter-Process Communication，进程间通信）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sem_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">list_t</span> wait_list;</span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> init_count)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-发信号和等信号"><a href="#9-2-发信号和等信号" class="headerlink" title="9.2 发信号和等信号"></a>9.2 发信号和等信号</h2><ul>
<li><p>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 信号量不为0，进程可继续执行</span></span><br><span class="line">        sem-&gt;count--;  <span class="comment">// 信号量减1，表明当前进程获得一个信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 信号量为0，进程由就绪队列移动到等待队列</span></span><br><span class="line">        <span class="type">task_t</span> *curr =  task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;sem-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162047328.png" alt="image-20240516204721126" style="zoom: 50%;" />
</li>
<li><p>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_notify</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;sem-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 等待队列非空，有进程在等待执行</span></span><br><span class="line">        <span class="type">list_node_t</span> *node = list_remove_first(&amp;sem-&gt;wait_list);  <span class="comment">// 从等待队列中取第一个任务     </span></span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);  <span class="comment">// 获取该任务对应的task_t地址</span></span><br><span class="line">        task_set_ready(task);   <span class="comment">// 设置该任务为就绪状态</span></span><br><span class="line"></span><br><span class="line">        task_dispatch();        <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等待队列为空，信号量加1</span></span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162048307.png" alt="image-20240516204803152" style="zoom:50%;" /></li>
</ul>
<h2 id="9-3-使用计数信号量"><a href="#9-3-使用计数信号量" class="headerlink" title="9.3 使用计数信号量"></a>9.3 使用计数信号量</h2><p>实例：收到信号量打印信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162101361.png" alt="image-20240516210150112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(&amp;sub_task, task_first_take());</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_first_init();</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>);  <span class="comment">// 信号量初始化（放在开中断前，以避免定时中断切换至其它任务，而此时信号量还未初始化）</span></span><br><span class="line">    irq_enable_global();  <span class="comment">// 打开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(task_first_take(), &amp;sub_task);</span></span><br><span class="line">        <span class="comment">// 修改上面这个函数，使得进程主动释放CPU的使用权，但不指定切换到哪个进程运行，实现如下</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">        <span class="comment">// 注释掉上面这个函数，使得执行时间片切片运行的效果</span></span><br><span class="line">        sem_notify(&amp;sem);</span><br><span class="line">        sys_sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时和<code>8.7</code>相比就会先打印<code>main task</code>：<strong>因为此时<code>sub task</code>需要等到<code>main task</code>发信号，接收到信号时才会执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162110080.png" alt="image-20240516211037845"></p>
<h2 id="9-4-互斥锁及其初始化"><a href="#9-4-互斥锁及其初始化" class="headerlink" title="9.4 互斥锁及其初始化"></a>9.4 互斥锁及其初始化</h2><p>使用关闭中断的方式实现互斥，简单粗暴，容易造成中断和其它进程长时间得到运行或响应。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162120111.png" alt="image-20240516212005916" style="zoom:50%;" />

<p>类似地，可以为临界区加一把锁(互斥锁)，只有持有锁的进程才能进来，从而实现进程进入临界区的互斥。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162121845.png" alt="image-20240516212129597" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">smutex_t</span>&#123;</span> </span><br><span class="line">    <span class="type">task_t</span> *owner;      <span class="comment">// 当前持有锁的进程</span></span><br><span class="line">    <span class="type">int</span> locked_count;   <span class="comment">// 当前锁的上锁次数</span></span><br><span class="line">    <span class="type">list_t</span> wait_list;   <span class="comment">// 等待队列，存放进程</span></span><br><span class="line">&#125;<span class="type">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span>;  <span class="comment">// 互斥锁初始化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥锁初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    mutex-&gt;locked_count = <span class="number">0</span>;</span><br><span class="line">    list_init(&amp;mutex-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-互斥锁的加解锁"><a href="#9-5-互斥锁的加解锁" class="headerlink" title="9.5 互斥锁的加解锁"></a>9.5 互斥锁的加解锁</h2><ul>
<li><p>上锁：如果已经上锁，则等待；否则，该进程自己上锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 上锁 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="comment">// 判断是否已上锁</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前未上锁</span></span><br><span class="line">        mutex-&gt;locked_count++;  <span class="comment">// 上锁次数加1</span></span><br><span class="line">        mutex-&gt;owner = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="comment">// 若恰为本进程上锁，上锁次数加1</span></span><br><span class="line">        mutex-&gt;locked_count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若非本进程上锁，加入等待队列</span></span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;mutex-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();  <span class="comment">// 进程切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162128904.png" alt="image-20240516212825736" style="zoom:50%;" />
</li>
<li><p>解锁：如果有进程等待，则唤醒进程继续执行；否则，直接解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解锁，注意只有锁的上锁者才能解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若当前锁被上锁者解锁掉，首先释放掉这个锁</span></span><br><span class="line">            mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其次，若等待队列中仍然有进程等待，则等待队列中的下一个进程进行加锁操作</span></span><br><span class="line">            <span class="keyword">if</span> (list_count(&amp;mutex-&gt;wait_list)) &#123;</span><br><span class="line">                <span class="comment">// 该进程加入就绪队列</span></span><br><span class="line">                <span class="type">list_node_t</span> *node = list_remove_first(&amp;mutex-&gt;wait_list);</span><br><span class="line">                <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">                task_set_ready(task);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新加锁</span></span><br><span class="line">                mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">                mutex-&gt;owner = task;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务切换</span></span><br><span class="line">                task_dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162134988.png" alt="image-20240516213438830" style="zoom:50%;" /></li>
</ul>
<h2 id="9-6-应用互斥锁"><a href="#9-6-应用互斥锁" class="headerlink" title="9.6 应用互斥锁"></a>9.6 应用互斥锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个GDT空闲表项 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gdt_alloc_desc</span><span class="params">()</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第0项（保留使用）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">segment_desc_t</span> *desc = gdt_table + i;</span><br><span class="line">        <span class="keyword">if</span> (desc-&gt;attr == <span class="number">0</span>) &#123;</span><br><span class="line">            mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">return</span> i * <span class="keyword">sizeof</span>(<span class="type">gate_desc_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    <span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    kernel_memset(str_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_buf));</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(str_buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170816844.png" alt="image-20240517081626731"></p>
<p>可以看到，<code>main task</code>和<code>sub task</code>将轮流执行。</p>
<h1 id="十、虚拟内存管理和保护模式"><a href="#十、虚拟内存管理和保护模式" class="headerlink" title="十、虚拟内存管理和保护模式"></a>十、虚拟内存管理和保护模式</h1><h2 id="10-1-内存管理问题"><a href="#10-1-内存管理问题" class="headerlink" title="10.1 内存管理问题"></a>10.1 内存管理问题</h2><p>操作系统需要决定如何管理计算机中的整块内存。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170959500.png" alt="image-20240517095902134" style="zoom: 33%;" />

<p>内存中存在多进程时，加载进程时存在一些问题：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171004646.png" alt="image-20240517100444945" style="zoom: 33%;" />

<p>为便于内存管理，<code>x86</code>的虚拟内存管理硬件将内存看做成相同大小的页。后续实际上不是按字节分配，而是按页分配的。 </p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171006887.png" alt="image-20240517100622430" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171007176.png" alt="image-20240517100745545" style="zoom: 33%;" />

<p>进程内部维护了一张表，用于实现这种进程和页之间的转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171009559.png" alt="image-20240517100935089" style="zoom: 33%;" />

<h2 id="10-2-位图数据结构与初始化"><a href="#10-2-位图数据结构与初始化" class="headerlink" title="10.2 位图数据结构与初始化"></a>10.2 位图数据结构与初始化</h2><ul>
<li><p><strong>问题：用什么样的方法管理内存页的分配与回收？</strong></p>
<ul>
<li><p>标记哪些页被使用了，哪些页没有被使用；</p>
</li>
<li><p>采用<strong>位图方式</strong>实现，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171011883.png" alt="image-20240517101143375" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bitmap_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit_count;  <span class="comment">// 位图中的位总个数</span></span><br><span class="line">    <span class="type">uint8_t</span> *bits;  <span class="comment">// 位图字节数组</span></span><br><span class="line">&#125;<span class="type">bitmap_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/klib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算位总个数所需字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_byte_count</span><span class="params">(<span class="type">int</span> bit_count)</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑到6/8=0 &amp; 14/8=1这两种情况，需要进行向上取整</span></span><br><span class="line">    <span class="keyword">return</span> (bit_count + <span class="number">8</span> - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 位图初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">uint8_t</span> *bits, <span class="type">int</span> count, <span class="type">int</span> init_bit)</span> &#123;</span><br><span class="line">    bitmap-&gt;bits = bits;</span><br><span class="line">    bitmap-&gt;bit_count = count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes = bitmap_byte_count(bitmap-&gt;bit_count);</span><br><span class="line">    kernel_memset(bitmap-&gt;bits, init_bit ? <span class="number">0xFF</span> : <span class="number">0</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-3-位图位的分配"><a href="#10-3-位图位的分配" class="headerlink" title="10.3 位图位的分配"></a>10.3 位图位的分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取位图中某一位的状态 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_get_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// index / 8                --&gt; 获取到该位处在哪个字节数组（每个字节数组是8位）</span></span><br><span class="line">    <span class="comment">// index % 8                --&gt; 获取到该位在字节数组内部对应的下标</span></span><br><span class="line">    <span class="comment">// &amp; (1 &lt;&lt; (index % 8))     --&gt; 左移下标位，并相与，即可取得该位的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17 / 8 = 2  --&gt;  在第2个字节数组中</span></span><br><span class="line">    <span class="comment">// 17 % 8 = 1  --&gt;  第2个字节数组的第1位</span></span><br><span class="line">    <span class="keyword">return</span> bitmap-&gt;bits[index / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置位图中的某一位 </span></span><br><span class="line"><span class="comment"> * @param index 位的索引</span></span><br><span class="line"><span class="comment"> * @param count 要设置的位的总个数</span></span><br><span class="line"><span class="comment"> * @param bit   要设置的位的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index, <span class="type">int</span> count, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i &lt; count) &amp;&amp; (index &lt; bitmap-&gt;bit_count); i++, index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bit) &#123;</span><br><span class="line">            <span class="comment">// 若bit为1，则进行置1</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，进行清0</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] &amp;= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断位图中某一位是否已设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_is_set</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bitmap_get_bit(bitmap, index) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在位图中寻找值匹配的连续N个位进行分配 </span></span><br><span class="line"><span class="comment"> * @param bit   要匹配的值</span></span><br><span class="line"><span class="comment"> * @param count 要匹配的位的总个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> search_idx = <span class="number">0</span>;  <span class="comment">// 从第0位开始找</span></span><br><span class="line">    <span class="type">int</span> ok_idx = <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (search_idx &lt; bitmap-&gt;bit_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx) != bit) &#123;</span><br><span class="line">            search_idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="comment">// 找到第一个值匹配的位</span></span><br><span class="line">        ok_idx = search_idx;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; count) &amp;&amp; (search_idx &lt; bitmap-&gt;bit_count); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx++) != bit) &#123;</span><br><span class="line">                <span class="comment">// 当前位值不匹配</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= count) &#123;</span><br><span class="line">            <span class="comment">// 找到了符合条件的多个位</span></span><br><span class="line">            bitmap_set_bit(bitmap, ok_idx, count, ~bit);  <span class="comment">// bit取反</span></span><br><span class="line">            <span class="keyword">return</span> ok_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-4-创建地址分配结构"><a href="#10-4-创建地址分配结构" class="headerlink" title="10.4 创建地址分配结构"></a>10.4 创建地址分配结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171101073.png" alt="image-20240517110120785" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">addr_alloc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> start;         <span class="comment">// 位图的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> size;          <span class="comment">// 分配的存储空间[位图]的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> page_size;     <span class="comment">// 内存块大小（内存以页的方式分配，因此又称页大小）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bitmap_t</span> bitmap;    </span><br><span class="line"></span><br><span class="line">    <span class="type">mutex_t</span> mutex;          <span class="comment">// 内存分配时的互斥操作</span></span><br><span class="line">&#125;<span class="type">addr_alloc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地址分配器初始化</span></span><br><span class="line"><span class="comment"> * @param bits      位图的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param start     管理内存的起始地址</span></span><br><span class="line"><span class="comment"> * @param size      管理内存的大小</span></span><br><span class="line"><span class="comment"> * @param page_size 内存块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addr_alloc_init</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint8_t</span> *bits,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> page_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存分配，从位图中获取相应的位并分配，将对应的位由0-&gt;1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_alloc_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存释放</span></span><br><span class="line"><span class="comment"> * @param addr 释放的内存块的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_free_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint32_t</span> addr, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">addr_alloc_t</span> addr_alloc;</span><br><span class="line">    <span class="type">uint8_t</span> bits[<span class="number">9</span>];  <span class="comment">// 支持最多64个内存页的分配和释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4096:1KB  0x1000:4KB</span></span><br><span class="line">    addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);</span><br><span class="line">        log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_free_page(&amp;addr_alloc, addr, <span class="number">2</span>);</span><br><span class="line">        addr += <span class="number">8192</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png" alt="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);  <span class="comment">// 单步调试此处后，00处的[00]-&gt;[03]</span></span><br><span class="line">    log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517145000377.png" alt="image-20240517145000377"></p>
<p>64个内存块分配完毕后：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517144742533.png" alt="image-20240517144742533"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451064.png" alt="image-20240517145140955"></p>
<p>接下来对这64个内存块进行释放：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451285.png" alt="image-20240517145130117"></p>
<h2 id="10-5-规划内存空间的分配"><a href="#10-5-规划内存空间的分配" class="headerlink" title="10.5 规划内存空间的分配"></a>10.5 规划内存空间的分配</h2><p>系统内存分两大块：</p>
<ul>
<li><code>1M以内</code>给<strong>操作系统</strong>使用；</li>
<li><code>1M以上</code>给<strong>进程</strong>使用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_mem_info</span><span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;mem region: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;[%d]: 0x%x - 0x%x&quot;</span>, i,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].start,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">total_mem_size</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> mem_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        mem_size += boot_info-&gt;ram_region_cfg[i].size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="comment">// 1MB内存空间起始，在链接脚本中定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> *mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印内存初始信息</span></span><br><span class="line">    log_printf(<span class="string">&quot;mem init&quot;</span>);</span><br><span class="line">    show_mem_info(boot_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图缓存的起始地址</span></span><br><span class="line">    <span class="type">uint8_t</span> *mem_free = (<span class="type">uint8_t</span> *)&amp;mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1MB以上空间的空闲内存容量，并对齐页边界</span></span><br><span class="line">    <span class="type">uint32_t</span> mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;</span><br><span class="line">    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    log_printf(<span class="string">&quot;free memory: 0x%x, size: 0x%x&quot;</span>, MEM_EXT_START, mem_up1MB_free);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用地址分配机构对得到的内存进行管理</span></span><br><span class="line">    addr_alloc_init(&amp;paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);  <span class="comment">// 跳过位图缓存这一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mem_free应该比EBDA地址要小</span></span><br><span class="line">    ASSERT(mem_free &lt; (<span class="type">uint8_t</span> *)MEM_EBDA_START);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel.lds</code>中，取出位图缓存这一部分的起始地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x10000;</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . );     &lt;--  这一行就可以取取出.bss之后的内存起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存初始信息获取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171531929.png" alt="image-20240517153147728"></p>
<p>位图缓存的起始地址：</p>
<blockquote>
<p> 0x000129c0 + 0x4f10 &#x3D; 0x17830</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171535529.png" alt="image-20240517153526379"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171534282.png" alt="image-20240517153424161"></p>
<p><code>1MB</code>以上空间的空闲内存容量（对齐页边界）：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171532892.png" alt="image-20240517153243765"></p>
<p>两个技巧函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 ** n</span></span><br><span class="line"><span class="comment">// size = 0x1010  bound = 0x1000(4KB)</span></span><br><span class="line"><span class="comment">// size &amp; ~(bound - 1) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; ~(0x0FFF) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; 0xFFFFF000    [0x0FFF在取反时会补足为32位]</span></span><br><span class="line"><span class="comment">//  = 0x1000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">down2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留0x1010中最后的两位[10]，使其得到0x2000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">up2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (size + bound - <span class="number">1</span>) &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-6-内存分页机制"><a href="#10-6-内存分页机制" class="headerlink" title="10.6 内存分页机制"></a>10.6 内存分页机制</h2><h3 id="1、分页机制理论基础"><a href="#1、分页机制理论基础" class="headerlink" title="1、分页机制理论基础"></a>1、分页机制理论基础</h3><p>对进程而言，它看到的是多段连续的内存空间；而实际上，其可能由不同的内存页组合而成。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171545775.png" alt="image-20240517154528056" style="zoom:50%;" />

<p>在访问特定的内存地址时，虚拟存储管理部件会自动地根据转换表将其转换到物理内存中的特定位置。</p>
<blockquote>
<p>也就是说，对于一个进程来说，它掌握的是属于自己的这套“线性地址”（逻辑地址），而实际上的内存是分布在对应的“物理地址”中。当该进程想访问自己的地址上编号为“0x1000”处的内容时，会经过一个转换表，将其映射到物理地址上的“0x20000”处。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171548139.png" alt="image-20240517154849803" style="zoom:50%;" />



<p>最简单的实现方法是使用一级转换表，表中存储了进程看到的内存页对应的实际物理内存页的起始地址转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171630549.png" alt="image-20240517163012208" style="zoom:50%;" />

<blockquote>
<p>在32位地址空间中，总共可以表示<code>2^32</code>个地址，即<code>4GB</code>的内存空间。**<code>4GB</code>的地址空间需要的页表大小是<code>4MB</code>**，分析如下：</p>
<ul>
<li><strong>32位地址空间的表示</strong></li>
</ul>
<ol>
<li>32位地址：一个<code>32</code>位的地址可以表示从 <code>0x00000000</code> 到 <code>0xFFFFFFFF</code>，即<code>2^32</code>个地址。</li>
<li>4GB内存：由于<code>2^32 = 4 * 2^30</code>，这就等于<code>4GB</code>的内存空间。</li>
</ol>
<ul>
<li><strong>分页机制</strong></li>
</ul>
<p>在分页机制中，内存被划分成固定大小的页。常见的页大小是<code>4KB</code>（<code>4096</code>字节）。<code>32</code>位地址分成两部分：页目录和页内偏移。</p>
<ul>
<li><strong>页表的结构</strong></li>
</ul>
<ol>
<li>页大小：<code>4KB = 2^12</code>字节。这意味着地址的低<code>12</code>位用于页内偏移。</li>
<li>页数：剩下的<code>20</code>位（32位 - 12位）用于表示页的索引。</li>
</ol>
<ul>
<li><strong>页表计算</strong></li>
</ul>
<ol>
<li>每个页表条目（PTE, Page Table Entry）通常占<code>4</code>字节（32位）</li>
<li>一个页表可以包含<code>2^10 = 1024</code>个条目（因为页大小为4KB，4KB &#x2F; 4Byte &#x3D; 1024条目）。</li>
</ol>
<ul>
<li><strong>一级页表大小</strong>：要映射整个4GB的内存空间，需要多少页表条目和页表呢？</li>
</ul>
<ol>
<li><p>页的数量：需要映射<code>4GB / 4KB = 2^20</code>个页。</p>
</li>
<li><p>页表的数量：</p>
</li>
</ol>
<ul>
<li>每个页表可以包含<code>1024</code>个页表条目（每个条目映射一个4KB的页）。</li>
<li>因此，需要的页表数量为<code>2^20(pages) / 1024(entries) = 1024(tables)</code>个。</li>
</ul>
<ol start="3">
<li>每个页表的大小：</li>
</ol>
<ul>
<li>每个页表有1024个条目，每个条目4字节：<code>1024(entries) * 4(bytes/entry) = 4KB</code>大小。</li>
</ul>
<ol start="4">
<li>总页表大小：</li>
</ol>
<ul>
<li><p>因此，1024个页表，每个4KB，总的页表空间需求为：</p>
<p><code>1024(tables) * 4KB(per table) = 4MB</code>。</p>
</li>
</ul>
<ul>
<li><strong>结论</strong>：为了存储4GB的内存地址空间所需的一级页表大小为 <strong>4MB</strong>。这包括了1024个页表，每个页表4KB。</li>
</ul>
</blockquote>
<p>因此，经过上述计算可以得知，一级转换表占用的4MB空间太大了，所以使用二级转换表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<ul>
<li>第1级处理<code>4MB</code>的内存页的地址映射；</li>
<li>第2级处理<code>4KB</code>的内存页的地址映射。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171655736.png" alt="image-20240517165538461" style="zoom:50%;" />

<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<h3 id="2、在loader中开启分页机制"><a href="#2、在loader中开启分页机制" class="headerlink" title="2、在loader中开启分页机制"></a>2、在loader中开启分页机制</h3><p>接下来以一级页表为例进行测试，实现分页机制的打开：</p>
<p>直接进行<code>4MB</code>内存页的转换，以节省页表空间。<em>（注意采用该方式时需要打开<code>CR4</code>寄存器中的<code>PSE</code>位）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171703932.png" alt="image-20240517170308820" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171736358.png" alt="image-20240517173645182" style="zoom: 80%;" />

<p>由于虚拟存储的分页机制存在，操作系统和进程不需要过多考虑实际物理内存的有效地址范围。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171717275.png" alt="image-20240517171749065" style="zoom:50%;" />

<p>在<code>loader</code>中开始分页机制时，需要保持<code>loader</code>中线性地址和物理地址相同，才能保证<code>loader</code>正常运行。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171718785.png" alt="image-20240517171857619" style="zoom:50%;" />

<p>具体涉及到<code>CR3</code>寄存，并将设计的表结构信息传给<code>CR3</code>寄存器。</p>
<ul>
<li>低12位无效。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171722017.png" alt="image-20240517172220845" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr3</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr3, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr3</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr3&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr4</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr4, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr4</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr4&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开分页机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_page_mode</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页目录表，共1024项，且需对齐到4KB处</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> page_dir[<span class="number">1024</span>] __attribute__((aligned(<span class="number">4096</span>))) = &#123;</span><br><span class="line">        [<span class="number">0</span>] = PDE_P | PDE_W | PDE_PS</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	声明并初始化了一个对齐到4KB边界的页目录表，</span></span><br><span class="line"><span class="comment">        	并设置了第一个页目录项，指向一个4MB的大页，以便实现简单的分页机制。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR4 &amp; CR3寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> cr4 = read_cr4(); </span><br><span class="line">    write_cr4(cr4 | CR4_PSE);</span><br><span class="line">    write_cr3((<span class="type">uint32_t</span>)page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR0的最高位开启分页机制</span></span><br><span class="line">    write_cr0(read_cr0() | CR0_PG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载内核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enable_page_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行调试，可以发现只有第<code>0</code>项当前被设置了。也就是说<code>0-4MB</code>范围的线性地址已经设置好了一个表项，映射到物理地址上的<code>0-4MB</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171741544.png" alt="image-20240517174108363" style="zoom:80%;" />

<h2 id="10-7-创建内核页表"><a href="#10-7-创建内核页表" class="headerlink" title="10.7 创建内核页表"></a>10.7 创建内核页表</h2><h3 id="1、代码实现"><a href="#1、代码实现" class="headerlink" title="1、代码实现"></a>1、代码实现</h3><p>分页机制除了能实现地址转换外，还可以实现对内存页的保护。借助这种保护机制，可以实现对操作系统的代码和数据进行保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171805215.png" alt="image-20240517180548963" style="zoom:50%;" />



<p>第一级页表的每个表项指向一个二级表，而二级页表的每个表项指向一个真实的物理页。</p>
<ul>
<li><p>二级页表中的第一级页表：</p>
<ul>
<li>注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807804.png" alt="image-20240517180726661" style="zoom:80%;" />
</li>
<li><p>二级页表中的第二级页表：</p>
<ul>
<li>同样注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807062.png" alt="image-20240517180747902" style="zoom:80%;" /></li>
</ul>
<p>以下区域设置为可读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">	*(.text)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下区域设置为可读写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>



<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引，获取<code>Page Directory</code>中的对应表项；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取pde表项</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = page_dir + pde_index(vaddr);  </span><br><span class="line">    <span class="type">pte_t</span> *page_table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pde对应的Page Table是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (pde-&gt;present) &#123;</span><br><span class="line">        <span class="comment">// 若存在，直接获取page_table的物理地址</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，判断是否需要进行分配</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从物理页中分配一页内存</span></span><br><span class="line">        <span class="type">uint32_t</span> pg_paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pg_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_table + pte_index(vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 建立虚拟地址和物理地址间的映射</span></span><br><span class="line"><span class="comment"> * @param page_dir  要建立映射的页表 </span></span><br><span class="line"><span class="comment"> * @param vaddr     虚拟空间起始地址 </span></span><br><span class="line"><span class="comment"> * @param paddr     物理空间起始地址</span></span><br><span class="line"><span class="comment"> * @param count     虚拟空间中包含的页个数 </span></span><br><span class="line"><span class="comment"> * @param perm      相关属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_create_map</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> paddr, <span class="type">int</span> count, <span class="type">uint32_t</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个页表项，建立其对应的映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;create map: v-0x%x p-0x%x, perm: 0x%x&quot;</span>, vaddr, paddr, perm);</span><br><span class="line"></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(page_dir, vaddr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;create pte failed. pte == 0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;             </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建映射的时候，这条pte应当是不存在的。</span></span><br><span class="line">        <span class="comment">// 如果存在，说明可能有问题</span></span><br><span class="line">        log_printf(<span class="string">&quot;\tpte addr: 0x%x&quot;</span>, (<span class="type">uint32_t</span>)pte);</span><br><span class="line">        <span class="comment">// 找到了对应的页表项/PTE</span></span><br><span class="line">        ASSERT(pte-&gt;present == <span class="number">0</span>);  <span class="comment">// 此时的present位应为0</span></span><br><span class="line">        pte-&gt;v = paddr | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个地址</span></span><br><span class="line">        vaddr += MEM_PAGE_SIZE;</span><br><span class="line">        paddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">    kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要初始化?</li>
</ul>
<ol>
<li><strong>防止脏数据</strong>: 分配新的页表页后，该页表页中的内容可能包含先前分配但未清除的数据。初始化页表页（即清零）确保所有 PTE（页表项）都是空的，没有设置任何标志位或地址。</li>
<li><strong>安全性</strong>: 避免访问到未初始化的内存，防止潜在的安全漏洞。例如，未初始化的 PTE 可能指向随机地址，这会导致页错误或者其他意外行为。</li>
<li><strong>正确性</strong>: 页表页中的每个 PTE 都需要按照预期进行初始化。初始化保证了新分配的页表页在开始时不包含任何有效的映射，只有在后续显式设置时才包含有效映射。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182044761.png" alt="image-20240518204404435"></p>
<h3 id="2、代码调试"><a href="#2、代码调试" class="headerlink" title="2、代码调试"></a>2、代码调试</h3><p>在<code>qemu</code>中执行<code>info mem</code>为空，正确的话应该打印开启分页机制后的虚拟地址与物理地址的映射。此时为空说明分页机制已被打开，但所有的页表全为无效。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182052909.png" alt="image-20240518205244786"></p>
<p>原因分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是对新分配的表进行清空，并没有建立pde表项，并没有建立<code>pde</code>与<code>page_table</code>之间的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P;</span><br></pre></td></tr></table></figure>

<p>加上这一行后重新调试，发现最后两项存在问题。虚拟地址相同，但物理地址并没有实现页边界对齐。</p>
<p>因此需要对物理地址也进行页边界对齐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182058011.png" alt="image-20240518205852888"></p>
<p>在以下函数中进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        <span class="comment">// memory_create_map(kernel_page_dir, vstart, (uint32_t)map-&gt;pstart, page_count, map-&gt;perm);</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后出现以下结果，发现最后错误地出现了两个相同的项，导致在<code>memory_create_map()</code>中判断<code>ASSERT(pte-&gt;present == 0);</code> 时出错。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182102316.png" alt="image-20240518210246033"></p>
<p>经排查，这个错误和链接脚本的设置有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	PROVIDE(kernel_base = .);</span><br><span class="line">    . = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">	PROVIDE(s_text = .); </span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE(e_text = .); </span><br><span class="line"></span><br><span class="line">	PROVIDE(s_data = .);   &lt;==== .data未页边界对齐</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>kernel_elf.txt</code>文件中，<code>.data section</code>的起始地址并非是页边界对齐（<code>4KB</code>）的，因此会在后续产生页表项重复的情况。</p>
<p>详细来说，<code>.data</code>段的起始地址未对齐到页边界，会导致两个问题：</p>
<ol>
<li><strong>页表项重复</strong>： 当页表项映射未对齐的数据段时，一个页表项可能会覆盖两个不同的物理页。这会导致映射冲突，页表项出现重复或无效。</li>
<li><strong>访问异常</strong>： 未对齐的数据段会引起内存访问异常，因为在一个页中可能包含多个段的数据，导致不同的页表项映射到同一物理地址。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182107831.png" alt="image-20240518210723714"></p>
<p>因此，对链接脚本修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. = ALIGN(<span class="number">4096</span>);   &lt;==== 加入这一行</span><br><span class="line">PROVIDE(s_data = .); </span><br><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重新编译后，<code>.data section</code>的起始地址如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182124084.png" alt="image-20240518212455979"></p>
<p>经过上述修改，<code>info mem</code>就有输出了：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182125920.png" alt="image-20240518212541791"></p>
<h3 id="3、权限设置"><a href="#3、权限设置" class="headerlink" title="3、权限设置"></a>3、权限设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码为操作系统访问的代码，因此第<code>2</code>位权限位设置为<code>0</code>，即<code>supervisor</code>；</p>
</li>
<li><p>此外，还要设置第<code>3</code>位，确定是只读还是可读写。由于采用的结构是二级表，因此每个表都有针对自己这个表的权限设置。对于<code>PTE</code>表项来说，在上述代码中设置<code>PTE_W</code>即可确定可读写；而对于<code>PDE</code>表项来说，在此处（<code>find_pte()</code>中）设置可读写以及用户可访问：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置完权限后，<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182149317.png" alt="image-20240518214839313"></p>
<h2 id="10-8-为进程创建页表"><a href="#10-8-为进程创建页表" class="headerlink" title="10.8 为进程创建页表"></a>10.8 为进程创建页表</h2><h3 id="1、问题说明"><a href="#1、问题说明" class="headerlink" title="1、问题说明"></a>1、问题说明</h3><p>此时这个程序存在下列问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行到第<code>3</code>行的代码时，CPU会重启。进入这一行代码的内部进行调试，可以发现问题出在切换<code>TSS</code>的时刻。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Switch </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">    <span class="comment">// simple_switch(&amp;from-&gt;stack, to-&gt;stack);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远跳转</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">far_jump</span> <span class="params">(<span class="type">uint32_t</span> selector, <span class="type">uint32_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;offset, selector&#125;;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;ljmpl *(%[a])&quot;</span>::[a]<span class="string">&quot;r&quot;</span>(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为每个进程的TSS结构中均有一个<code>CR3</code>字段，以允许每个进程拥有自己的页表。进程会从这个<code>CR3</code>字段中取出页表的起始地址并加载到实际的<code>CR3</code>寄存器中，也就是说切换到进程实际的页表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182200116.png" alt="image-20240518220044967" style="zoom:80%;" />

<p>此外，需要借助保护机制来实现对操作系统的代码和数据的保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182202640.png" alt="image-20240518220254434" style="zoom:50%;" />

<p>两个进程运行起来之后，会共享<code>0x00000000~0x80000000</code>这部分的空间，也即操作系统代码。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182208681.png" alt="image-20240518220857411" style="zoom:50%;" />



<h3 id="2、代码实现-3"><a href="#2、代码实现-3" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放GDT表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_free_sel</span><span class="params">(<span class="type">int</span> sel)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    gdt_table[sel/<span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>)].attr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建进程自己的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_create_uvm</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配一页内存给Page Directory</span></span><br><span class="line">    <span class="type">pde_t</span> *page_dir = (<span class="type">pde_t</span> *)addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第一级页表进行清空</span></span><br><span class="line">    <span class="comment">// 不需要对第二级页表进行清空是因为loader_32.c中执行了清零操作</span></span><br><span class="line">    kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户进程PDE的开始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="comment">// 为了实现多个进程间共享操作进程代码，遍历从低1MB空间的所有页表（操作系统部分）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_pde_start; i++) &#123;</span><br><span class="line">        <span class="comment">// 由于多个进程间操作系统部分的映射关系是一致的，如果要为这一部分的每一项都分配一个PTE页表，会造成内存浪费</span></span><br><span class="line">        <span class="comment">// 因此此处直接使用操作系统在0x0-0x7FFFFFFF的空间内配置的PTE表即可，即实现了多个进程间的映射共享</span></span><br><span class="line">        page_dir[i].v = kernel_page_dir[i].v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)page_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>此时进行调试，会在<code>memory_create_uvm()</code>的这一步出错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br></pre></td></tr></table></figure>

<p>通过查看此时<code>QEMU</code>的内存映射关系可以得知，此时仅配置了<code>1MB</code>以下的内存关系的映射，而没有配置<code>1MB</code>以上的内存关系映射，但分配的<code>page_dir</code>的地址为<code>0x101000</code>，也就是说<code>QEMU</code>不知道该写到哪里。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451190.png" alt="image-20240519145138077"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451670.png" alt="image-20240519145108455"></p>
<p>因此需要对物理地址<code>0x101000</code>也进行一个映射，以获取其线性地址。</p>
<p>因此，对<code>kernel_map[]</code>进行改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_START       (1024 * 1024)           <span class="comment">// 扩展内存的起始地址，从1MB（实模式内存限制）开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_END         (128 * 1024 * 1024)     <span class="comment">// 扩展内存的结束地址，目前只给QEMU分配了128M内存</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END, (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十一、隔离操作系统与进程"><a href="#十一、隔离操作系统与进程" class="headerlink" title="十一、隔离操作系统与进程"></a>十一、隔离操作系统与进程</h1><h2 id="11-1-隔离操作系统与进程"><a href="#11-1-隔离操作系统与进程" class="headerlink" title="11.1 隔离操作系统与进程"></a>11.1 隔离操作系统与进程</h2><p>目前所以进程（共3个）的代码和数据全部位于操作系统中，可以适当进行分离。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191512628.png" alt="image-20240519151246404" style="zoom:50%;" />

<p>主要实现以下三步：</p>
<blockquote>
<ol>
<li>建立进程的运行空间；</li>
<li>代码拷贝至指定区域；</li>
<li>从操作系统跳转至进程运行。</li>
</ol>
</blockquote>
<h3 id="1、代码分离"><a href="#1、代码分离" class="headerlink" title="1、代码分离"></a>1、代码分离</h3><blockquote>
<p><strong>实现方式：</strong>只需要单独新建一个文件把代码放进去，就可以实现代码分离。</p>
</blockquote>
<p>（1）首先，删除前序测试使用的<code>sub_task()</code>，并且为<code>first_task()</code>新建一个单独的<code>.c</code>文件，使得其在编译时在<code>/kernel</code>中得到一个单独的文件，而不是在<code>init.c</code>中一起编译。这样在后续进行代码拷贝时就会方便很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first_task.c</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);</span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// first_task_entry.S</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.global first_task_entry</span><br><span class="line">	.extern first_task_main</span><br><span class="line">first_task_entry:</span><br><span class="line">    // 进程运行前，操作系统会为其初始化SS寄存器和CS寄存器</span><br><span class="line">	mov %ss, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br><span class="line">    // 跳转至32位的C环境运行</span><br><span class="line">	jmp first_task_main</span><br></pre></td></tr></table></figure>

<p>（2）更新<code>kernel/CMakeLists.txt</code>文件，在末尾加上<code>*.S</code>，从而完成对<code>first_task_entry.S</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE C_LIST &quot;*.c&quot; &quot;*.h&quot; &quot;*.S&quot;)</span><br></pre></td></tr></table></figure>

<p>（3）更新<code>first_task</code>的页表为自己的页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置好first_task执行的入口函数，并修改对应的task_init中的entry参数为first_start</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">first_task_entry</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明入口函数</span></span><br><span class="line">    <span class="type">uint32_t</span> first_start = (<span class="type">uint32_t</span>)first_task_entry;  <span class="comment">// 获取入口函数地址</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, first_start, <span class="number">0</span>);  <span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页表为进程自己的页表</span></span><br><span class="line">    mmu_set_page_dir(task_manager.first_task.tss.cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）实现代码跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;jmp *%[ip]&quot;</span>::[ip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化first_task，并跳转到进程代码中运行</span></span><br><span class="line">    task_first_init();</span><br><span class="line">    move_to_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）运行结果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191559496.png" alt="image-20240519155930343"></p>
<p>从上图可以看到此时<code>first_task</code>的入口地址在<code>0x11b09</code>，依旧在<code>1MB</code>以下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191556008.png" alt="image-20240519155627657"></p>
<h3 id="2、地址分离"><a href="#2、地址分离" class="headerlink" title="2、地址分离"></a>2、地址分离</h3><blockquote>
<p><strong>目标：</strong></p>
<p>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</p>
<p><strong>实现方式：</strong>在链接脚本<code>kernel.lds</code>中进行修改。</p>
</blockquote>
<ul>
<li><strong>相关理论基础：</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611562.png" alt="image-20240519161104805" style="zoom:50%;" />

<ul>
<li>物理地址为存储地址；</li>
<li>虚拟地址为运行地址。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611577.png" alt="image-20240519161116895" style="zoom: 50%;" />

<p>而在<code>kernel.lds</code>文件中，<code>. = 0x100000</code>实际上设置的是虚拟地址，也就是运行地址。这样的结果就是<code>paddr</code>和<code>vaddr</code>设置为一样的，因此在加载时kernel也会从这个地址上去加载。</p>
<p><strong>现在要做的就是：</strong></p>
<p><strong>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</strong></p>
<p><strong>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191615645.png" alt="image-20240519161519963"></p>
<p>因此，可在链接脚本中分别指定段的加载地址和运行地址。当仅指定运行地址时，加载地址与运行地址相同。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191616105.png" alt="image-20240519161650286"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data 0x2000: AT(ADDR(.text) +SIZEOF(.text))</span><br></pre></td></tr></table></figure>

<p>这一行的意思就是说：<code>.data</code>的运行地址为<code>0x2000</code>，但其存储的物理地址在（<code>AT</code>）<code>.text</code>的相邻处。</p>
<ul>
<li><strong>代码实现：</strong></li>
</ul>
<p><code>kernel_elf.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191621670.png" alt="image-20240519162150219"></p>
<p>上图中的<code>VirtualAddr</code>和<code>PhysAddr</code>一致，且分别对应<code>.text/.rodata</code>和<code>.data/.bss</code>两部分。</p>
<p>（1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>修改链接脚本<code>kernel.lds</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = 0x80000000;</span><br><span class="line">	.first_task : &#123;</span><br><span class="line">		*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">		*first_task*(.text .rodata .bss .data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>ELF</code>文件的<code>Program Header Table</code>表项会更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191631851.png" alt="image-20240519163152388"></p>
<p>（2）但此时存在一个问题</p>
<p>在<code>loader</code>加载时会扫描上图这个表，并根据每个表项的具体内容进行加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br></pre></td></tr></table></figure>

<p>也即上图中的<code>Offset</code>和<code>PhysAddr</code>两项。但由于<code>0x80000000</code>这个物理地址是不存在的，因此加载会失败。所以需要将<code>first_task</code>的物理地址修改为比<code>.data/.bss</code>的物理地址大一些的地址即可。</p>
<p>取<code>Segment 01</code>的虚拟地址即可（因为<code>00</code>和<code>01</code>段的虚拟地址与物理地址的映射是对应的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e_data = .;</span><br><span class="line"></span><br><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就完成了物理地址的修改：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191648559.png" alt="image-20240519164849109"></p>
<p>（3）此外，对于<code>mem_free_start</code>也需要进行相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>

<p>此时它在<code>kernel_elf.txt</code>中显示的物理地址为：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191651929.png" alt="image-20240519165112540"></p>
<p>这是因为加入<code>(2)</code>中的系列修改后，会改变它的地址。但这个地址实际上应该指向位图缓存的起始地址，如下图所示，也就是说应该在<code>1MB以下</code>的范围内：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<p>所以，进行如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = e_first_task); </span><br></pre></td></tr></table></figure>

<p>这样位图缓存的地址就修改正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191655562.png" alt="image-20240519165543113"></p>
<h3 id="3、代码搬运"><a href="#3、代码搬运" class="headerlink" title="3、代码搬运"></a>3、代码搬运</h3><blockquote>
<p><strong>实现方式：</strong></p>
<p>1）找到first_task在物理空间的起始和结束地址；</p>
<p>2）在虚拟空间分配相应的内存空间；</p>
<p>3）进行代码搬运。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191657728.png" alt="image-20240519165724091" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for_page_dir</span> <span class="params">(<span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前vaddr（运行地址，所以是虚拟地址）</span></span><br><span class="line">    <span class="type">uint32_t</span> curr_vaddr = vaddr;</span><br><span class="line">    <span class="comment">// 计算分配页的数量，注意页边界对齐</span></span><br><span class="line">    <span class="type">int</span> page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐页分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_count; i++) &#123;</span><br><span class="line">        <span class="comment">// 从物理内存中分配一页</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;mem alloc failed, no memory!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立物理内存和虚拟内存的映射关系</span></span><br><span class="line">        <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)page_dir, curr_vaddr, paddr, <span class="number">1</span>, perm);</span><br><span class="line">        <span class="keyword">if</span> (paddr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若建立当前映射失败，则释放当前已建立映射的页，因此addr_free_page传入vaddr</span></span><br><span class="line">            <span class="comment">// 这里不能传入paddr，因为这个paddr只是当前循环下分配的这一页的起始物理地址</span></span><br><span class="line">            log_printf(<span class="string">&quot;create memory failed, crr = %d.&quot;</span>, err);</span><br><span class="line">            addr_free_page(&amp;paddr_alloc, vaddr, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此外，可以实现虚拟和物理映射的断开，此处并未实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个虚拟地址</span></span><br><span class="line">        curr_vaddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> memory_alloc_page_for_page_dir(task_current()-&gt;tss.cr3, addr, size, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729446.png" alt="image-20240519172917244"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729964.png" alt="image-20240519172948838"></p>
<p>执行代码拷贝后，显示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W);</span><br><span class="line">kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191730041.png" alt="image-20240519173019470"></p>
<p>查看对应的反汇编，和<code>first_task_entry.S</code>中的内容一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731972.png" alt="image-20240519173119400"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731182.png" alt="image-20240519173158224" style="zoom: 80%;" />

<h2 id="11-2-调整应用的特权级"><a href="#11-2-调整应用的特权级" class="headerlink" title="11.2 调整应用的特权级"></a>11.2 调整应用的特权级</h2><h3 id="1、x86芯片的特权级定义"><a href="#1、x86芯片的特权级定义" class="headerlink" title="1、x86芯片的特权级定义"></a>1、x86芯片的特权级定义</h3><p>x86芯片支持四种特权级：</p>
<ul>
<li>第0级权限最高，用于运行操作系统；</li>
<li>第3级权限最低，用于运行应用程序；</li>
<li>其它两级用于运行操作系统服务(可选)。</li>
</ul>
<p>对于某个特权级来说：只允许访问相同或更低权限的代码或数据。通过这种特权分级的机制可以防止低特权级代码随意访问敏感数据或代码，如开关中断、写磁盘等。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191916522.png" alt="image-20240519191609991"></p>
<ol>
<li><p>数据段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>访问**数据段(<code>DS,ES,FS,GS</code>)**时，仅当<code>DPL&gt;= Max(CPL,RPL)</code>时才能访问。</p>
<p>当**访问<code>SS</code>**时，要求<code>CPL=DPL=RPL</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191919839.png" alt="image-20240519191939329"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920132.png" alt="image-20240519192009659"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920272.png" alt="image-20240519192046797"></p>
<p>对于访问权限，要求1）自身的权限要足够高；2）自己不能主动把权限放低。<strong>权限错误将产生段保护异常。</strong></p>
<p>如下图<code>CPL=0, RPL=3, DPL=2</code>这条线，就属于自己主动把权限放低了，因此也无法正确访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191931168.png" alt="image-20240519193151363"></p>
<ol start="2">
<li><p>代码段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))和<code>C</code>位，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191934137.png" alt="image-20240519193438668"></p>
<ul>
<li><p>访问非一致代码段时(<code>C=0</code>)，<code>CPL=DPL，且RPL&lt;=CPL</code>，即权限要一样。</p>
</li>
<li><p>访问一致性代码段时(<code>C=1</code>)到，要求<code>CPL&gt;=DPL，RPL不检查</code>，即访问者的权限要与被访问的代码权限相等或更低<strong>（但本项目未用到，因为不允许随便访问高权限的代码）</strong>。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191936035.png" alt="image-20240519193654339" style="zoom: 50%;" />

<h3 id="2、平坦模型如何实现保护"><a href="#2、平坦模型如何实现保护" class="headerlink" title="2、平坦模型如何实现保护"></a>2、平坦模型如何实现保护</h3><p>对于本项目来说，由于采用了平坦模型，因此分段保护做不到真正的保护，实际上都写入了<code>0x0~0xFFFFFFFF</code>的空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191938454.png" alt="image-20240519193841332" style="zoom:50%;" />

<p>因此，结合分页机制进行保护。简化处理，操作系统运行于特权级<code>0</code>，应用进程运行于特权级<code>3</code>。全部使用非一致性代码段，<code>CPL=RPL</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940126.png" alt="image-20240519194030428" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940436.png" alt="image-20240519194056411" style="zoom:50%;" />

<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> app_code_sel;   <span class="comment">// 进程的代码段选择子</span></span><br><span class="line">    <span class="type">int</span> app_data_sel;   <span class="comment">// 进程的数据段选择子</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">    data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TSS的相关字段</span></span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = data_sel;</span><br><span class="line">    task-&gt;tss.cs = code_sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设定任务数据段和代码段的特权级</span></span><br><span class="line">    <span class="type">int</span> sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_data_sel = sel;</span><br><span class="line"></span><br><span class="line">    sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_code_sel = sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进行调试，可以看到相应的段寄存器的值：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191955719.png" alt="image-20240519195526886"></p>
<p>这些值实际上的内核初始化时在<code>cpu_init()</code>中通过下面的代码设置的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设计平坦模式下的代码段与数据段</span></span><br><span class="line">    <span class="comment">// 注意第#0号表项需要保留，不能使用</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_DS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_CS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此说明此时<code>first_task</code>依旧是运行在特权级<code>0</code>的状态下。这是因为整个系统从内核加载、解析，一直到运行<code>first_task</code>时并没有对<code>TSS</code>的相关设置，只是对<code>TSS</code>进行了相应的初始化。</p>
<p>当进行第一次任务切换，由于运行了<code>sys_sleep()</code>函数，因此切换到<code>idle_task</code>时，相应的寄存器值就发生了改变。可以看到<code>CS</code>的低<code>2</code>位变成了<code>特权级3</code>，也就是说空闲任务运行在<code>特权级3</code>上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192010866.png" alt="image-20240519201046181"></p>
<p>此时若按下<code>F11</code>，会发生异常。这是因为<code>idle_task</code>相关的代码是和操作系统代码绑定在一起编译的，存储在<code>1MB以下</code>的内存区域，而根据映射关系可知，这部分的<code>U/S</code>位是设置为<code>0</code>的，也就是用户特权级无法访问，但<code>idle_task</code>又处在用户级特权，相当于这里按照权限3去执行权限0的代码，因此发生了权限错误。</p>
<blockquote>
<p>目前存在的问题：</p>
<p><code>first_task</code>运行在权限级<code>0</code>，而<code>idle_task</code>反而运行在了权限级<code>3</code>，在后续应该对其进行调换。</p>
</blockquote>
<h2 id="11-3-调整异常处理函数"><a href="#11-3-调整异常处理函数" class="headerlink" title="11.3 调整异常处理函数"></a>11.3 调整异常处理函数</h2><h3 id="1、修改TSS字段初始化"><a href="#1、修改TSS字段初始化" class="headerlink" title="1、修改TSS字段初始化"></a>1、修改TSS字段初始化</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192018702.png" alt="image-20240519201803678"></p>
<p>当存在特权级变化时，若特权级<code>3</code>的程序&#x2F;任务发生了异常，则异常处理程序（<code>DPL=0</code>）不应在发生异常的那个栈中压入，而应该单独压入另一个特级为<code>0</code>的栈中。</p>
<p>针对<code>11.2</code>中的最后提出的问题，需要对<code>tss</code>初始化中的相关字段设置进行更改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;</span><br><span class="line">task-&gt;tss.ss = data_selc;</span><br></pre></td></tr></table></figure>

<p>此时就可以成功的跳转到<code>Page Fault Exception</code>异常中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192048487.png" alt="image-20240519204839152"></p>
<h3 id="2、修改异常处理函数"><a href="#2、修改异常处理函数" class="headerlink" title="2、修改异常处理函数"></a>2、修改异常处理函数</h3><ul>
<li><p><code>do_handler_page_fault()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_page_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: Page fault.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_P) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tpage-level protection violation: 0x%x.&quot;</span>, read_cr2());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tPage doesn&#x27;t present 0x%x&quot;</span>, read_cr2());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_WR) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a read.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a write.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_US) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA supervisor-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA user-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do_handler_general_protection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_general_protection</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: General Protection.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_EXT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of an &quot;</span></span><br><span class="line">                <span class="string">&quot;event external to the program, such as an interrupt&quot;</span></span><br><span class="line">                <span class="string">&quot;or an earlier exception.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of a&quot;</span></span><br><span class="line">                    <span class="string">&quot;software interrupt (INT n, INT3, or INTO).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_IDT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index portion of the error code refers &quot;</span></span><br><span class="line">                    <span class="string">&quot;to a gate descriptor in the IDT&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index refers to a descriptor in the GDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log_printf(<span class="string">&quot;segment index: %d&quot;</span>, frame-&gt;error_code &amp; <span class="number">0xFFF8</span>);</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后打印的异常信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192103797.png" alt="image-20240519210348190"></p>
<h2 id="11-4-修改空闲任务的特权级"><a href="#11-4-修改空闲任务的特权级" class="headerlink" title="11.4 修改空闲任务的特权级"></a>11.4 修改空闲任务的特权级</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192104590.png" alt="image-20240519210438905"  />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TASK_FLAGS_SYSTEM) &#123;</span><br><span class="line">        <span class="comment">// 系统权限</span></span><br><span class="line">        code_sel = KERNEL_SELECTOR_CS;</span><br><span class="line">        data_sel = KERNEL_SELECTOR_DS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户权限</span></span><br><span class="line">        code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">        data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 空闲任务初始化</span></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        TASK_FLAGS_SYSTEM,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5-修改用户任务的特权级"><a href="#11-5-修改用户任务的特权级" class="headerlink" title="11.5 修改用户任务的特权级"></a>11.5 修改用户任务的特权级</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192114720.png" alt="image-20240519211415052"></p>
<p>要实现从高特权级向低特权级的转移，需要使用<code>IRET</code>指令。</p>
<p>可以参考中断切换的操作，在<code>first_task</code>的<code>TSS</code>初始化时，将相应的字段手动压入栈中；然后再执行<code>IRET</code>指令，就可以返回到特权级<code>3</code>的状态。从而实现一种从高到低的特权级切换，并将寄存器的值设置到<code>CPU</code>中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192115446.png" alt="image-20240519211502898" style="zoom:50%;" />

<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="comment">// 模拟IRET中断返回，切换入第1个可运行应用进程</span></span><br><span class="line">        <span class="comment">// 不过这里并不直接进入到进程的入口，而是先设置好段寄存器，再跳过去</span></span><br><span class="line">        <span class="string">&quot;push %[ss]\n\t&quot;</span>			<span class="comment">// SS</span></span><br><span class="line">        <span class="string">&quot;push %[esp]\n\t&quot;</span>			<span class="comment">// ESP</span></span><br><span class="line">        <span class="string">&quot;push %[eflags]\n\t&quot;</span>        <span class="comment">// EFLAGS</span></span><br><span class="line">        <span class="string">&quot;push %[cs]\n\t&quot;</span>			<span class="comment">// CS</span></span><br><span class="line">        <span class="string">&quot;push %[eip]\n\t&quot;</span>		    <span class="comment">// ip</span></span><br><span class="line">        <span class="string">&quot;iret\n\t&quot;</span></span><br><span class="line">        ::[ss]<span class="string">&quot;r&quot;</span>(tss-&gt;ss),</span><br><span class="line">          [esp]<span class="string">&quot;r&quot;</span>(tss-&gt;esp),</span><br><span class="line">          [eflags]<span class="string">&quot;r&quot;</span>(tss-&gt;eflags),</span><br><span class="line">          [cs]<span class="string">&quot;r&quot;</span>(tss-&gt;cs),</span><br><span class="line">          [eip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调试得到的寄存器值如下。可以看到<code>ds/es/fs/gs</code>的值都变成了<code>0x0</code>，这是因为特权级<code>0</code>时这些寄存器存在一些值，而当切换到特权级<code>3</code>时，这些选择子会被清零。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192125386.png" alt="image-20240519212526869"></p>
<p>此时再单步调试<code>F11</code>，会发现<code>CPU</code>发生了复位。查看<code>info mem</code>可以看出，<code>0x800000000以上</code>的地址空间其权限状态，即<code>U/S</code>位依旧需要高特权级才能访问，但此时应该是低特权级程序去访问这段空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192128843.png" alt="image-20240519212808376"></p>
<p>因此，需要在内存分配的相关代码中进行修改。</p>
<ul>
<li>在<code>task_first_init</code>加入属性值<code>PTE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);</span><br><span class="line">    kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>find_pte</code>加入属性值<code>PDE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时寄存器值的设置更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192135719.png" alt="image-20240519213521035"></p>
<h2 id="11-6-为进程添加特权级0的栈空间"><a href="#11-6-为进程添加特权级0的栈空间" class="headerlink" title="11.6 为进程添加特权级0的栈空间"></a>11.6 为进程添加特权级0的栈空间</h2><p>目前进程<code>特权级0</code>和<code>特权级3</code>使用的是同一个栈，因此需要额外创建一个栈，以便进行不同特权级栈的分享。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192142734.png" alt="image-20240519214216716"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 任务初始化</span></span><br><span class="line">    <span class="comment">// task_init(&amp;task_manager.first_task, &quot;first task&quot;, 0, first_start, 0);  </span></span><br><span class="line">    <span class="comment">// 对first_task的esp进行修改如下：</span></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, <span class="number">0</span>, first_start, first_start + alloc_size);  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈，得到的是物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> kernel_stack = memory_alloc_page();</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tss_init_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    task-&gt;tss.esp = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.esp0 = kernel_stack + MEM_PAGE_SIZE;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">tss_init_failed:</span><br><span class="line">    gdt_free_sel(tss_sel);</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack) &#123;</span><br><span class="line">        memory_free_page(kernel_stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前页表地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pde_t</span> * <span class="title function_">current_page_dir</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">pde_t</span> *)task_current()-&gt;tss.cr3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 分配一页内存</span></span><br><span class="line"><span class="comment"> * 主要用于内核空间内存的分配，不用于进程内存空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_alloc_page</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内核空间虚拟地址与物理地址相同，因此可以直接调用</span></span><br><span class="line">    <span class="keyword">return</span> addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放一页内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_free_page</span> <span class="params">(<span class="type">uint32_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; MEM_TASK_BASE) &#123;</span><br><span class="line">        <span class="comment">// 若为内核空间，则直接释放</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, addr, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若为进程空间，则还要释放页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(current_page_dir(), addr, <span class="number">0</span>);</span><br><span class="line">        ASSERT((pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &amp;&amp; pte-&gt;present);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存页</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表</span></span><br><span class="line">        pte-&gt;v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进程就进入了特权级<code>3</code>的自己的栈：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192208389.png" alt="image-20240519220833546"></p>
<p>此时<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210217.png" alt="image-20240519221009717"></p>
<p>此时继续运行会出现异常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);  <span class="comment">// F11单步调试此处出现异常</span></span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210492.png" alt="image-20240519221047950"></p>
<p>这是因为<code>log_printf</code>在操作系统进程（<code>0x00012bcd</code>）中，用户代码是没有权限访问的，因此需要在后续通过系统调用来解决。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192213396.png" alt="image-20240519221354822" style="zoom: 80%;" />

<h1 id="十二、建立系统调用"><a href="#十二、建立系统调用" class="headerlink" title="十二、建立系统调用"></a>十二、建立系统调用</h1><h2 id="12-1-实现系统调用的调用和返回"><a href="#12-1-实现系统调用的调用和返回" class="headerlink" title="12.1 实现系统调用的调用和返回"></a>12.1 实现系统调用的调用和返回</h2><h3 id="1、调用门"><a href="#1、调用门" class="headerlink" title="1、调用门"></a>1、调用门</h3><p>（1）调用门的作用</p>
<p>到目前为此，由于特权级的影响，特权级为<code>3</code>的应用进程无法直接访问特权级为<code>0</code>的操作进程的代码。</p>
<p>切换特权级的几种方法：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201002440.png" alt="image-20240520100207964" style="zoom:50%;" />

<p>应用程序可以通过<strong>调用门接口</strong>，实现在低特权级下对操作系统提供的接口函数进行调用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201004667.png" alt="image-20240520100431449" style="zoom:50%;" />

<p>（2）调用门的描述符</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201005983.png" alt="image-20240520100512741" style="zoom:50%;" />

<p>（3）调用门的工作流程</p>
<p>调用门描述符实际上存放到<code>GDT</code>表中，应用调用门时需要传入对应的调用门选择子。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008417.png" alt="image-20240520100843015" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008739.png" alt="image-20240520100854431" style="zoom:50%;" />

<p>（4）权限检查，设置<code>CPL=3, RPL=0</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201010501.png" alt="image-20240520101031276" style="zoom:50%;" />

<h3 id="2、创建调用门"><a href="#2、创建调用门" class="headerlink" title="2、创建调用门"></a>2、创建调用门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加调用门描述符</span></span><br><span class="line">    <span class="comment">// (SELECTOR_SYSCALL &gt;&gt; 3)  =&gt; 段选择子的低3位用作其他用途，高13为才用于索引index</span></span><br><span class="line">    <span class="comment">// selector                 =&gt; KERNEL_SELECTOR_CS，是因为被调函数是操作系统的代码</span></span><br><span class="line">    <span class="comment">// offset                   =&gt; 由于段基地址为0，因此被调函数的入口地址即为偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当执行call指令时，会取选择子KERNEL_SELECTOR_CS找到代码段的起始地址，</span></span><br><span class="line">    <span class="comment">// 然后根据偏移量(uint32_t)exception_handler_syscall进入函数内部</span></span><br><span class="line">    gate_desc_set((<span class="type">gate_desc_t</span> *)(gdt_table + (SELECTOR_SYSCALL &gt;&gt; <span class="number">3</span>)), </span><br><span class="line">        KERNEL_SELECTOR_CS, </span><br><span class="line">        (<span class="type">uint32_t</span>)exception_handler_syscall, </span><br><span class="line">        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// init.c/start.S</span><br><span class="line"></span><br><span class="line">	.global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h3 id="3、实现调用和返回"><a href="#3、实现调用和返回" class="headerlink" title="3、实现调用和返回"></a>3、实现调用和返回</h3><p>如果为每一个系统调用都提供一个对应的调用门，会占用较多的描述符表项。<strong>因此，可通过一个或少量几个调用门实现系统调用，从而节省资源。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201032921.png" alt="image-20240520103254777" style="zoom:50%;" />

<p>进入调用门：远跳转；</p>
<p>退出调用门：RET。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201046034.png" alt="image-20240520104642832" style="zoom:50%;" />

<p>代码实现：</p>
<p>通用系统调用结构<code>sys_call()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applib/libsys.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用参数列表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;     <span class="comment">// 被调用函数的ID</span></span><br><span class="line">    <span class="type">int</span> arg0;</span><br><span class="line">    <span class="type">int</span> arg1;</span><br><span class="line">    <span class="type">int</span> arg2;</span><br><span class="line">    <span class="type">int</span> arg3;</span><br><span class="line">&#125;<span class="type">syscall_args_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep       0       <span class="comment">// sys_sleep()的ID</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        ::[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">          [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">          [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">          [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">          [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">          [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_sleep的系统调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">msleep</span> <span class="params">(<span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_sleep;</span><br><span class="line">    args.arg0 = ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lcalll</code>，即远跳转指令需要提供两个参数，段选择子和段内偏移，由<code>addr[]</code>提供。</p>
<ul>
<li><code>addr[0] = 0</code>，表示<strong>段内偏移</strong>，它指向系统调用处理函数的入口点。</li>
<li><code>addr[1] = SELECTOR_SYSCALL | 0</code>表示<strong>段选择子</strong>。<ul>
<li><code>SELECTOR_SYSCALL</code> 是被调用系统函数的段选择子；</li>
<li><code>| 0</code>是因为<code>RPL</code>设置为<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201109576.png" alt="image-20240520110945445" style="zoom:50%;" />

<ul>
<li><p>在保护模式下，x86架构使用段选择子和段内偏移配合进行内存寻址。例如，远调用指令<code>lcall</code>会使用段选择子和段内偏移来确定调用的目标地址：</p>
<ol>
<li><strong>段选择子</strong>：决定使用哪个段描述符，该描述符提供段的基地址和权限;</li>
<li><strong>段内偏移</strong>：在基地址的基础上加上偏移量，确定最终的内存地址。</li>
</ol>
</li>
<li><p>举例说明</p>
</li>
</ul>
<p>假设有一个段选择子<code>0x08</code>，它指向GDT中的一个代码段描述符，该描述符的基地址是<code>0x40000000</code>。如果段内偏移是<code>0x1000</code>，则最终的线性地址是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性地址 = 段基地址 + 段内偏移</span><br><span class="line"><span class="code">          = 0x40000000 + 0x1000</span></span><br><span class="line"><span class="code">          = 0x40001000</span></span><br></pre></td></tr></table></figure>

<p>这种机制使得程序可以通过改变段选择子访问不同的内存段，同时确保通过权限控制防止未经授权的访问。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201059277.png" alt="image-20240520105948178"></p>
<p><code>far jump</code>将跳转到下图的代码处：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201100500.png" alt="image-20240520110014325" style="zoom: 80%;" />



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201210574.png" alt="image-20240520121051430"></p>
<p><code>ESP</code>指向<code>0x122fdc</code>地址处（<code>1MB空间以下</code>），其内存存储的值如下图所示。也就是说，在用户进程中压入<code>特权级3</code>的对应栈的相关参数已经复制到了<code>特权级0</code>的对应栈中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201216326.png" alt="image-20240520121643956"></p>
<p>此时存在一些问题，若调用<code>RET</code>指令，不会执行特权级切换，因此需要采用<code>RETF</code>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    // ret</span><br><span class="line">    retf  // far return，即返回到不同的代码段中</span><br></pre></td></tr></table></figure>

<p>同时要注意，直接调用<code>REFT</code>时，在将<code>EIP/CS</code>弹出到对应的寄存器后，会直接从Parameter的位置开始弹出，这是系统“以为的”<code>ESP/SS</code>，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201221626.png" alt="image-20240520122108506" style="zoom: 50%;" />

<p>因此需要进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h2 id="12-2-具体的调用实现"><a href="#12-2-具体的调用实现" class="headerlink" title="12.2 具体的调用实现"></a>12.2 具体的调用实现</h2><p>在进入系统调用处理程序之前，除了硬件<strong>自动压栈</strong>之外，还需要<strong>手动压栈</strong>一部分寄存器的值，以便后续使用。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201224360.png" alt="image-20240520122430073"></p>
<p>在系统调用内部，使用<strong>系统调用表</strong>来保存所有系统调用处理函数的入口地址。当发生系统调用时，通过查表来获取跳转点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201251661.png" alt="image-20240520125101409"></p>
<h3 id="1、寄存器出入栈管理"><a href="#1、寄存器出入栈管理" class="headerlink" title="1、寄存器出入栈管理"></a>1、寄存器出入栈管理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    # 寄存器入栈（此处为手动入栈，有部分由硬件自动入栈）</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line">    pushf                # 手动压入调用门</span><br><span class="line">        </span><br><span class="line">    mov %esp, %eax</span><br><span class="line">    push %eax</span><br><span class="line">    call do_handler_syscall</span><br><span class="line">    add $<span class="number">4</span>, %esp</span><br><span class="line">        </span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    popf</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    retf $(<span class="number">5</span>*<span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>    pusha：将所有通用寄存器（EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI）的值压入栈中。
           这样可以保存调用者的寄存器状态。
    pushf：将标志寄存器 EFLAGS 的值压入栈中。
</code></pre>
</blockquote>
<blockquote>
<pre><code>mov %esp, %eax：
    将当前栈指针ESP的值移动到EAX寄存器中。
    这一步保存了当前的栈指针。
push %eax：
    将EAX寄存器（即栈指针ESP的值）压入栈中，作为参数传递给do_handler_syscall。
call do_handler_syscall：
    调用系统调用处理函数do_handler_syscall。
    在调用之前，栈中的ESP值被传递给该函数。
add $4, %esp：
    调整栈指针，移除之前压入的参数。
    由于调用do_handler_syscall后栈中多了一个参数（即EAX的值），需要将ESP增加4字节。
</code></pre>
</blockquote>
<h3 id="2、系统调用结构体"><a href="#2、系统调用结构体" class="headerlink" title="2、系统调用结构体"></a>2、系统调用结构体</h3><p>用于保存系统调用时的处理器状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用结构体，用于保存系统调用时的处理器状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_frame_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> eflags;</span><br><span class="line">	<span class="type">int</span> gs, fs, es, ds;</span><br><span class="line">	<span class="type">int</span> edi, esi, ebp, dummy, ebx, edx, ecx, eax;</span><br><span class="line">	<span class="type">int</span> eip, cs;</span><br><span class="line">	<span class="type">int</span> func_id, arg0, arg1, arg2, arg3;</span><br><span class="line">	<span class="type">int</span> esp, ss;</span><br><span class="line">&#125; <span class="type">syscall_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">        :[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">         [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">         [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">         [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">         [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">         [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、转发表实现系统调用"><a href="#3、转发表实现系统调用" class="headerlink" title="3、转发表实现系统调用"></a>3、转发表实现系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">syscall_handler_t</span>)</span><span class="params">(<span class="type">uint32_t</span> arg0, <span class="type">uint32_t</span> arg1, <span class="type">uint32_t</span> arg2, <span class="type">uint32_t</span> arg3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">    [SYS_sleep] = (<span class="type">syscall_handler_t</span>)sys_sleep,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用该函数时，传递的frame参数所指向的内存地址处保存了相关的寄存器信息。在exception_handler_syscall函数中，</span></span><br><span class="line"><span class="comment"> *        相关的寄存器值被保存到栈上，然后ESP寄存器的值（即当前栈顶指针）被传递给do_handler_syscall函数。</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        这个函数需要进行转发，找到需要调用的相应的系统函数。在frame中包含一个字段func_id，在对应的调用函数中是压入到</span></span><br><span class="line"><span class="comment"> *        syscall_args_t的id字段，并压入特权级3的栈中；在执行系统调用时，会被拷贝到特权级0的栈中（自动入栈），从而对</span></span><br><span class="line"><span class="comment"> *        应到相应的系统函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_syscall</span> <span class="params">(<span class="type">syscall_frame_t</span> *frame)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;func_id &lt; <span class="keyword">sizeof</span>(sys_table) / <span class="keyword">sizeof</span>(sys_table[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 查表取得处理函数，然后调用处理</span></span><br><span class="line">        <span class="type">syscall_handler_t</span> handler  = sys_table[frame-&gt;func_id];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="type">int</span> ret = handler(frame-&gt;arg0, frame-&gt;arg1, frame-&gt;arg2, frame-&gt;arg3);</span><br><span class="line">            frame-&gt;eax = ret;  <span class="comment">// eax用于存放函数的返回值，因此用ret赋值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数索引超出转发表</span></span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    log_printf(<span class="string">&quot;task: %s, Unkown syscall: %d&quot;</span>, task-&gt;name, frame-&gt;func_id);</span><br><span class="line">    frame-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释<code>frame-&gt;eax = ret;</code>，从下图可以看出最终的返回值放到了<code>%eax</code>中：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201607868.png" alt="image-20240520160709366" style="zoom: 80%;" />

<blockquote>
<p>在执行<code>lcalll</code>指令时，进入<code>start.S</code>中执行<code>exception_handler_syscall</code>进行寄存器的出入栈操作。1）首先通过<code>pusha</code>将<code>eax</code>压栈；2）再通过<code>sys_getpid()</code>获取到<code>pid</code>作为返回值，并放入<code>frame-&gt;eax</code>中，此时就对<code>eax</code>的值进行了修改；3）最后通过<code>popa</code>将<code>eax</code>出栈，返回到上一层的调用函数<code>sys_call</code>中。</p>
<p>以<code>getpid()</code>为例，调用的函数堆栈顺序如下：</p>
<p><code>getpid()  -&gt;  sys_call()  -&gt;  do_handler_syscall()  -&gt; sys_getpid()</code></p>
<p>也就是说，<code>ret</code>的返回如上述逆序。</p>
</blockquote>
<p>调试运行时<code>frame</code>的相关参数：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201512535.png" alt="image-20240520151212263"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201511396.png" alt="image-20240520151158125"></p>
<h1 id="十三、新进程的加载与创建"><a href="#十三、新进程的加载与创建" class="headerlink" title="十三、新进程的加载与创建"></a>十三、新进程的加载与创建</h1><h2 id="13-1-实现fork系统调用"><a href="#13-1-实现fork系统调用" class="headerlink" title="13.1 实现fork系统调用"></a>13.1 实现fork系统调用</h2><h3 id="1、理论基础-12"><a href="#1、理论基础-12" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>（1）流程</p>
<p>系统调用的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647344.png" alt="image-20240520164706084"></p>
<p>（2）功能详述</p>
<p><code>fork()</code>系统调用的功能：创建一个进程的副本，并且<strong>继续从调用fork的地址往下运行</strong>。（这一点很重要！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create child proc failed.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child task id=%d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647127.png" alt="image-20240520164718779"></p>
<h3 id="2、任务块的分配和释放"><a href="#2、任务块的分配和释放" class="headerlink" title="2、任务块的分配和释放"></a>2、任务块的分配和释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> *<span class="title">parent</span>;</span>     <span class="comment">// 指明父进程    </span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>

<p>将多个任务块存储在一个静态分配的进程表<code>task_table</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> task_table[TASK_NR];                  <span class="comment">// 进程表，静态分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> task_table_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Initializtion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    task-&gt;parent = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">alloc_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程表，找到没有名字的表项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr = task_table + i;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            task = curr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">free_task</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    task-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、初始化任务块"><a href="#3、初始化任务块" class="headerlink" title="3、初始化任务块"></a>3、初始化任务块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *parent_task = task_current();</span><br><span class="line">    <span class="type">task_t</span> *child_task = alloc_task();</span><br><span class="line">    <span class="keyword">if</span> (child_task == (<span class="type">task_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父进程执行系统调用时压栈的寄存器信息</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// frame-&gt;eip                                           ==&gt;  父进程执行系统调用的返回地址</span></span><br><span class="line">    <span class="comment">// frame-&gt;esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT  ==&gt;  恢复到对寄存器状态压栈之前的esp所指向的地址</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;child_task-&gt;tss;</span><br><span class="line">    tss-&gt;eax = <span class="number">0</span>;  <span class="comment">// 设置子进程的eax的返回值，使得调用fork()后子进程返回0</span></span><br><span class="line">    tss-&gt;ebx = frame-&gt;ebx;</span><br><span class="line">    tss-&gt;edx = frame-&gt;edx;</span><br><span class="line">    tss-&gt;ecx = frame-&gt;ecx;</span><br><span class="line">    tss-&gt;esi = frame-&gt;esi;</span><br><span class="line">    tss-&gt;edi = frame-&gt;edi;</span><br><span class="line">    tss-&gt;ebp = frame-&gt;ebp;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cs = frame-&gt;cs;</span><br><span class="line">    tss-&gt;ds = frame-&gt;ds;</span><br><span class="line">    tss-&gt;es = frame-&gt;es;</span><br><span class="line">    tss-&gt;fs = frame-&gt;fs;</span><br><span class="line">    tss-&gt;fs = frame-&gt;gs;</span><br><span class="line">    tss-&gt;eflags = frame-&gt;eflags;</span><br><span class="line"></span><br><span class="line">    child_task-&gt;parent = parent_task;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cr3 = parent_task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_failed:</span><br><span class="line">    <span class="keyword">if</span> (child_task) &#123;</span><br><span class="line">        task_uninit(child_task);</span><br><span class="line">        free_task(child_task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>sys_call()</code>中，当运行到<code>lcalll</code>指令时，会跳转到<code>start.S</code>的代码中执行压栈操作，也就是说此时保存了父进程相关的寄存器的所有信息。因此子进程只要能够也获取到<code>lcalll</code>指令调用时的内存信息，也即找到父进程的<code>syscall_frame_t</code>的指针，就可以获取到上述状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201950719.png" alt="image-20240520195025091"></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br></pre></td></tr></table></figure>



<p>父进程的执行完<code>fork()</code>后，是从特权级为<code>0</code>的代码返回到特权级为<code>3</code>的代码。</p>
<p>但对于子进程来说，只是通过<code>task_init</code>进行了初始化操作，包括对其<code>TSS</code>进行初始化。在父进程执行到<code>return</code>语句时它实际上并未运行，根据<code>first_task.c</code>的逻辑，会在父进程进入<code>msleep(1000);</code>睡眠时，通过任务切换<code>task_dispatch()</code>来切换到子进程中。此时子进程会从自己的<code>TSS</code>中进程对相关的寄存器进行状态恢复。</p>
<p>因此对于子进程来说，初始化子进程时传入的<code>esp</code>参数应该是和父进程的<code>esp</code>一致，但是区别在于子进程没有进行特权级切换，而是直接从特权级<code>3</code>的模式开始运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;task id= %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、复制进程地址空间"><a href="#4、复制进程地址空间" class="headerlink" title="4、复制进程地址空间"></a>4、复制进程地址空间</h3><p>在为子进程创建用户地址空间时，若共用同一页表，实际所用的存储空间就完全处在一页，当涉及到可读写数据时就可能导致冲突。比如，当涉及到栈空间时，父进程可能在执行时对<code>ESP</code>进行修改，这样当切换到子进程运行时，只能得到被破坏的寄存器状态，可能会造成返回出错，导致<code>Page Fault</code>的发生。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202030623.png" alt="image-20240520203019242"></p>
<p>因此，在为子进程创建用户地址空间时，<strong>只需要扫描父进程中<code>0x800000000</code>以上存在映射的地址区域，进行类似的映射。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202057353.png" alt="image-20240520205735959" style="zoom:50%;" />

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    <span class="keyword">if</span> ((tss-&gt;cr3 = memory_copy_uvm(parent_task-&gt;tss.cr3)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制页表及其所有的内存空间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_copy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 复制基础页表</span></span><br><span class="line">    <span class="type">uint32_t</span> to_page_dir = memory_create_uvm();</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制页表中用户空间的各项</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);  <span class="comment">// PD表的索引</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历用户空间页目录项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历页表</span></span><br><span class="line">        <span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分配物理内存</span></span><br><span class="line">            <span class="type">uint32_t</span> page = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (page == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="type">uint32_t</span> vaddr = (i &lt;&lt; <span class="number">22</span>) | (j &lt;&lt; <span class="number">12</span>);</span><br><span class="line">            <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)to_page_dir, vaddr, page, <span class="number">1</span>, get_pte_perm(pte));</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制内容</span></span><br><span class="line">            kernel_memcpy((<span class="type">void</span> *)page, (<span class="type">void</span> *)vaddr, MEM_PAGE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_page_dir;</span><br><span class="line"></span><br><span class="line">copy_uvm_failed:</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir) &#123;</span><br><span class="line">        memory_destroy_uvm(to_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁用户空间内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_destroy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="type">pde_t</span> * pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    ASSERT(page_dir != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页表中对应的各项，不包含映射的内核页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表对应的物理页 + 页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, (<span class="type">uint32_t</span>)pde_paddr(pde), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页目录表</span></span><br><span class="line">    addr_free_page(&amp;paddr_alloc, page_dir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-实现exec系统调用"><a href="#13-2-实现exec系统调用" class="headerlink" title="13.2 实现exec系统调用"></a>13.2 实现exec系统调用</h2><p>创建一个独立的应用程序文件，未来可<strong>单独放在磁盘上，并从磁盘上加载</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202146108.png" alt="image-20240520214639703" style="zoom:50%;" />

<p>对于一个<code>C</code>语言构建的应用程序，其入口地址并不是<code>main()</code>函数，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202148647.png" alt="image-20240520214815394" style="zoom:50%;" />

<h3 id="1、链接脚本设置"><a href="#1、链接脚本设置" class="headerlink" title="1、链接脚本设置"></a>1、链接脚本设置</h3><p>为了避免和<code>first_task</code>在调试时造成内存地址冲突，将起始地址设置为<code>0x81000000</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x81000000; </span><br><span class="line"></span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENTRY(_start)</code>这一句中的<code>_start</code>是<code>applib/crt0.S</code>文件的程序入口地址。这样做就是为了满足上图中<code>main</code>函数前还包含<code>crt0</code>和<code>clib</code>的框架结构。</p>
<h3 id="2、创建空exec调用"><a href="#2、创建空exec调用" class="headerlink" title="2、创建空exec调用"></a>2、创建空exec调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib_syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 指明进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> * <span class="type">const</span> *argv, <span class="type">char</span> * <span class="type">const</span> *env)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_execve;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)name;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)argv;</span><br><span class="line">    args.arg2 = (<span class="type">int</span>)env;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">	...</span><br><span class="line">    [SYS_execve] = (<span class="type">syscall_handler_t</span>)sys_execve,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> old_page_dir = task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该进程创建新的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载ELF文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表，并销毁原页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">exec_failed:</span><br><span class="line">    <span class="keyword">if</span> (new_page_dir) &#123;</span><br><span class="line">        task-&gt;tss.cr3 = old_page_dir;</span><br><span class="line">        mmu_set_page_dir(old_page_dir);</span><br><span class="line">        memory_destroy_uvm(new_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * conts * argv</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>char * const * argv</code> 表示一个指向常量字符指针数组的指针。</li>
<li>用于表示命令行参数的 <code>argv</code>，其中每个参数是一个字符串（<code>char *</code>）。</li>
<li>指针本身是常量（不能改变指向），但指向的内容（字符串）是可以修改的。</li>
</ul>
</blockquote>
<ul>
<li>解析2：为什么执行<code>sys_exec()</code>时，需要创建一个新页表？在<code>fork()</code>时子进程不是已经有了自己的新页表了吗？</li>
</ul>
<blockquote>
<ol>
<li><p>区别解释</p>
</li>
<li><p><code>fork</code> 函数：用于创建一个子进程，这个子进程是当前进程的副本。它会复制当前进程的页表，并在子进程的地址空间中共享同样的物理内存。这样做的目的是让子进程拥有与父进程相同的执行环境。</p>
</li>
</ol>
<ul>
<li><p><strong>页表复制</strong>：<code>fork</code> 时，通过<code>memory_copy_uvm</code>函数为子进程创建一个新的页表，该页表是父进程页表的副本。这使得父子进程各自独立，但初始时共享同样的物理内存。</p>
</li>
<li><p><strong>子进程的返回值</strong>：子进程的<code>eax</code>寄存器被设为0，以便<code>fork</code>系统调用在子进程中返回0，而在父进程中返回子进程的PID。</p>
</li>
</ul>
<ol start="2">
<li><p><code>execve</code> 函数：用于用一个新程序替换当前进程的内容。调用<code>execve</code>后，当前进程的地址空间会被新程序的地址空间替代。</p>
<ul>
<li><p><strong>新页表的创建</strong>：<code>execve</code>需要一个干净的、新的页表，用于加载和运行新的程序。这是因为 <code>execve</code> 的目的是清除当前进程的地址空间并加载新程序，所以必须分配一个新的页表。</p>
</li>
<li><p><strong>加载新程序</strong>：在新页表中加载新的程序，这样可以确保新程序有一个干净的内存环境，不受之前进程状态的影响。</p>
</li>
<li><p><strong>销毁旧页表</strong>：一旦新程序成功加载，旧的页表被销毁，以释放不再需要的资源。</p>
</li>
</ul>
</li>
<li><p>执行流程中的细节</p>
</li>
</ol>
<p> 在<code>sys_execve</code>函数中，以下步骤确保了这一点：</p>
<ol>
<li><p><strong>旧页表的保存</strong>；</p>
</li>
<li><p><strong>新页表的创建</strong>；</p>
</li>
<li><p><strong>加载新程序</strong>；</p>
</li>
<li><p><strong>切换到新页表</strong>。</p>
</li>
<li><p>总结：这种设计方式确保了每个系统调用的预期功能和行为：<code>fork</code> 保留现有执行环境，而 <code>execve</code> 则彻底替换执行环境。</p>
</li>
</ol>
<ul>
<li><p><code>fork</code> 通过复制当前进程的页表，为子进程创建了一个新的、但初始内容相同的地址空间。</p>
</li>
<li><p><code>execve</code> 通过创建一个全新的页表并加载新程序，确保新程序在一个干净的内存环境中运行。</p>
</li>
</ul>
</blockquote>
<h3 id="3、添加虚拟文件访问接口"><a href="#3、添加虚拟文件访问接口" class="headerlink" title="3、添加虚拟文件访问接口"></a>3、添加虚拟文件访问接口</h3><p>为实现应用程序的加载，需要完成两点工作：</p>
<ul>
<li>分配相应的存储空间；</li>
<li>从<code>ELF</code>文件中读取数据并写入内存页中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211017716.png" alt="image-20240521101728080"></p>
<p>目前仍未实现文件系统，因此采用下图的方式进行简单实现，只针对<code>shell.elf</code>文件进行处理：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211019558.png" alt="image-20240521101905366"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/include/fs/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FS_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _FS_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、解析并加载ELF文件"><a href="#4、解析并加载ELF文件" class="headerlink" title="4、解析并加载ELF文件"></a>4、解析并加载ELF文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载一个Phdr的数据到内存中</span></span><br><span class="line"><span class="comment"> * @param phdr      要加载的程序头</span></span><br><span class="line"><span class="comment"> * @param page_dir  程序头加载到的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成的ELF文件要求是页边界对齐的</span></span><br><span class="line">    ASSERT((phdr-&gt;p_vaddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(page_dir, phdr-&gt;p_vaddr, phdr-&gt;p_memsz, PTE_P | PTE_U | PTE_W);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整当前的读写位置</span></span><br><span class="line">    <span class="comment">// 具体来说，指针需要从Phdr的位置移动到该Phdr指向的代码/数据段的具体位置，也即p_offset参数</span></span><br><span class="line">    <span class="keyword">if</span> (sys_lseek(file, phdr-&gt;p_offset, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为段分配所有的内存空间，后续操作如果失败将在上层释放</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr = phdr-&gt;p_vaddr;     <span class="comment">// 内存中的起始地址，只针对传入的新创建的page_dir参数有效</span></span><br><span class="line">    <span class="type">uint32_t</span> size = phdr-&gt;p_filesz;     <span class="comment">// 要拷贝的文件大小</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前需要被拷贝的大小，一次最多只能拷贝一页</span></span><br><span class="line">        <span class="type">int</span> curr_size = (size &gt; MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line">        <span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        vaddr += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    Elf32_Ehdr elf_hdr;</span><br><span class="line">    Elf32_Phdr elf_phdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file = sys_open(name, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;open failed. %s&quot;</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，读取文件头（ELF Header）</span></span><br><span class="line">    <span class="type">int</span> cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_hdr, <span class="keyword">sizeof</span>(elf_hdr));</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Ehdr)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;elf hdr too small. size= %d&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做必要性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr.e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr.e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf indent failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是可执行文件和针对386处理器的类型，且有入口</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf type or entry failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有程序头部</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_phentsize == <span class="number">0</span>) || (elf_hdr.e_phoff == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;none programe header&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    sys_close(file);</span><br><span class="line">    <span class="keyword">return</span> elf_hdr.e_entry;</span><br><span class="line"></span><br><span class="line">load_failed:</span><br><span class="line">    <span class="keyword">if</span> (file &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sys_close(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有一个要注意的点在于：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211223596.png" alt="image-20240521122318108"></p>
<p>绿色框中框出的这两部分看起来好像是连续的，实际在对其进行拷贝时会发现它并非是连续的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载当前程序头</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="comment">// 为所有的段分配内存空间并复制</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述程序，在<code>21</code>行调用<code>load_phdr()</code>时传入了新建进程时新创建的页表<code>page_dir</code>，但在<code>load_phdr()</code>内部执行到段分配空间并复制时，实际用到的并非是这个新创建的<code>page_dir</code>，而是<code>first_task</code>在运行时创建的那个页表。</p>
<p>由于在<code>page_dir</code>这个页表中包含的映射关系并未被启用，也就是说在这个新页表中连续的一段内存空间在原来的页表中实际上是不连续的。需要将原页表的内容不连续地拷贝到新页表中。</p>
<p>需要像下面这样操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line"><span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、分配栈并进入进程执行"><a href="#5、分配栈并进入进程执行" class="headerlink" title="5、分配栈并进入进程执行"></a>5、分配栈并进入进程执行</h3><p>新进程的栈分配空间与<code>first_task</code>可能不相同。</p>
<p><code>first_task</code>的栈是紧挨着<code>.bss</code>段放置的，整体的空间不够大，对于<code>shell</code>来说，当后期涉及到堆空间以及一些较大的栈空间需求时很会麻烦，因此需要重新建立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_TOP  0xE0000000              <span class="comment">// shell进程的栈空间起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_SIZE     (MEM_PAGE_SIZE * 500)   <span class="comment">// shell进程的栈空间大小</span></span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211449653.png" alt="image-20240521144933288" style="zoom:50%;" />

<p>这个新分配的栈是需要返回给<code>shell</code>使用在特权级<code>3</code>的状态下的，但进程在使用时也会涉及到系统调用和中断等处理。因此，对于操作系统相关的代码可以<strong>继续使用原来建立的特权级<code>0</code>的栈</strong>，此处只需要对<strong>新分配属于自己的特权级<code>3</code>的栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211451843.png" alt="image-20240521145151527"></p>
<p>特权级<code>0</code>的栈保存了<code>frst_task</code>的相关信息，由于此处对于原来的页表进行了销毁，因此若不做相应的处理，返回到的内存地址处实际上是没有任何有效信息的，会造成错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新当前进程的页表</span></span><br><span class="line">task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">memory_destroy_uvm(old_page_dir);</span><br></pre></td></tr></table></figure>

<p>因此<strong>在更新页表前（上述代码）</strong>，需要先找到特权级<code>0</code>的栈，并对其中的相关寄存器值进行修改，以便在系统调用返回时能够切换回到<code>shell</code>进程中。</p>
<p>对寄存器值的修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载完毕，为程序的执行做必要准备</span></span><br><span class="line">    <span class="comment">// 注意，exec的作用是替换掉当前进程，所以只要改变当前进程的执行流即可</span></span><br><span class="line">    <span class="comment">// 当该进程恢复运行时，像完全重新运行一样，所以用户栈要设置成初始模式</span></span><br><span class="line">    <span class="comment">// 运行地址要设备成整个程序的入口地址</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> * frame = (<span class="type">syscall_frame_t</span> *)(task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line">    frame-&gt;eip = entry;  <span class="comment">// 修改为shell进程的入口地址</span></span><br><span class="line">    frame-&gt;eax = frame-&gt;ebx = frame-&gt;ecx = frame-&gt;edx = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;esi = frame-&gt;edi = frame-&gt;ebp = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;eflags = EFLAGS_DEFAULT| EFLAGS_IF;  <span class="comment">// 段寄存器无需修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核栈不用设置，保持不变，后面调用memory_destroy_uvm并不会销毁内核栈的映射。</span></span><br><span class="line">    <span class="comment">// 但用户栈需要更改, 同样要加上调用门的参数压栈空间</span></span><br><span class="line">    frame-&gt;esp = stack_top - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表</span></span><br><span class="line">    task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">    mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">    memory_destroy_uvm(old_page_dir);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、为进程传递参数"><a href="#6、为进程传递参数" class="headerlink" title="6、为进程传递参数"></a>6、为进程传递参数</h3><p><code>cstart.c</code>实际上是有参数的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cstart</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argc 存储参数的总个数，含应用程序的名字</span></span><br><span class="line"><span class="comment">// argv 参数的字符串指针数组</span></span><br></pre></td></tr></table></figure>

<p>在<code>C</code>语言中，如果需要传参的话，会将参数放入栈中。而此时的<code>esp = 0xE0000000</code>，对于当前进程来说，此时的参数保存在<code> 0xE0000000</code>以上的位置，但实际上此处是并未分配内存的，因此会造成异常。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211557399.png" alt="image-20240521155717841" style="zoom:50%;" />

<p>因此，在调用<code>main</code>函数之前，需要先往栈中压入<code>argc/argv</code>参数值：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211620385.png" alt="image-20240521162034894" style="zoom:50%;" />

<p>修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程参数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ret_addr;</span><br><span class="line">    <span class="type">uint32_t</span> argc;</span><br><span class="line">    <span class="type">char</span> **argv;</span><br><span class="line">&#125; <span class="type">task_args_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配用户栈空间，预留环境环境及参数的空间</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;</span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(</span><br><span class="line">        new_page_dir, </span><br><span class="line">        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,</span><br><span class="line">        MEM_TASK_STACK_SIZE,</span><br><span class="line">        PTE_P | PTE_U | PTE_W</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数，写入到栈顶的后边</span></span><br><span class="line">    <span class="type">int</span> argc = string_count(argv);</span><br><span class="line">    err = copy_args((<span class="type">char</span> *)stack_top, new_page_dir, argc, argv);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）参数拷贝函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 参数拷贝</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝到何处</span></span><br><span class="line"><span class="comment"> * @param page_dir  对应的页表</span></span><br><span class="line"><span class="comment"> * @param argc      要拷贝的参数个数</span></span><br><span class="line"><span class="comment"> * @param argv      要拷贝的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_args</span><span class="params">(<span class="type">char</span> *to, <span class="type">uint32_t</span> page_dir, <span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 在stack_top中依次写入argc, argv指针，参数字符串</span></span><br><span class="line">    <span class="type">task_args_t</span> task_args;</span><br><span class="line">    task_args.argc = argc;</span><br><span class="line">    task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制各项参数, 跳过task_args和参数表</span></span><br><span class="line">    <span class="comment">// 定义各argv参数写入的内存空间</span></span><br><span class="line">    <span class="type">char</span> * dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * (argc);   <span class="comment">// 留出结束符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// argv表</span></span><br><span class="line">    <span class="type">char</span> ** dest_argv_tb = (<span class="type">char</span> **)memory_get_paddr(page_dir, (<span class="type">uint32_t</span>)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>)));</span><br><span class="line">    ASSERT(dest_argv_tb != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *from = argv[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能用kernel_strcpy，因为to和argv不在一个页表里</span></span><br><span class="line">        <span class="type">int</span> len = kernel_strlen(from) + <span class="number">1</span>;  <span class="comment">// +1是为了加上&#x27;\0&#x27;</span></span><br><span class="line">        <span class="type">int</span> err = memory_copy_uvm_data((<span class="type">uint32_t</span>)dest_arg, page_dir, (<span class="type">uint32_t</span>)from, len);</span><br><span class="line">        ASSERT(err &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联字符串与对应的字符串指针</span></span><br><span class="line">        dest_argv_tb[i] = dest_arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下位置后，复制的位置前移</span></span><br><span class="line">        dest_arg += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入task_args</span></span><br><span class="line">    <span class="keyword">return</span> memory_copy_uvm_data((<span class="type">uint32_t</span>)to, page_dir, (<span class="type">uint32_t</span>)&amp;task_args, <span class="keyword">sizeof</span>(task_args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到char **argv的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * argc;  <span class="comment">// 获取argv中具体的每一个字符串的起始地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211649751.png" alt="image-20240521164949480" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到argv的起始地址</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211641068.png" alt="image-20240521164157766" style="zoom:50%;" />

<p>（2）重要函数：在不同的页表间拷贝数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在不同的页表间拷贝数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝的目的地址</span></span><br><span class="line"><span class="comment"> * @param page_dir  地址所在的页表</span></span><br><span class="line"><span class="comment"> *                  注意传入的page_dir为新页表，而当前仍在使用旧页表，因此需要结合物理地址来操作</span></span><br><span class="line"><span class="comment"> * @param from      当前地址</span></span><br><span class="line"><span class="comment"> * @param size      拷贝的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_copy_uvm_data</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取to对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> to_paddr = memory_get_paddr(page_dir, to);</span><br><span class="line">        <span class="keyword">if</span> (to_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to_paddr在自己所在物理页的偏移量</span></span><br><span class="line">        <span class="type">uint32_t</span> offset_in_page = to_paddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将from的数据拷贝到该偏移量处</span></span><br><span class="line">        <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - offset_in_page;</span><br><span class="line">        <span class="keyword">if</span> (curr_size &gt; size) &#123;</span><br><span class="line">            curr_size = size;</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_memcpy((<span class="type">void</span> *)to_paddr, (<span class="type">void</span> *)from, curr_size);</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        to += curr_size;</span><br><span class="line">        from += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-实现sys-yiled系统调用"><a href="#13-3-实现sys-yiled系统调用" class="headerlink" title="13.3 实现sys_yiled系统调用"></a>13.3 实现sys_yiled系统调用</h2><h3 id="1、解决task-init遗留问题"><a href="#1、解决task-init遗留问题" class="headerlink" title="1、解决task_init遗留问题"></a>1、解决task_init遗留问题</h3><p>在<code>sys_fork()</code>中，创建子进程时会调用<code>task_init()</code>函数，在这个函数中会对进程进行初始化，然后就加入<code>ready_list</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务加入ready_list</span></span><br><span class="line">task_set_ready(task);</span><br></pre></td></tr></table></figure>

<p>但在<code>sys_fork()</code>中，执行的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 对子进程进行初始化，并对必要的字段进行调整</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父进程的栈中取部分状态，然后写入子进程的tss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在<code>#8</code>行就将这个子进程加入<code>ready_list</code>中了，但此时的子进程仍未初始化完毕，包括对<code>TSS</code>以及对内存空间等的初始化，此时若发生了定时中断，就会发生<code>task_dispatch()</code>，切换到还未初始化完成的子进程中进行，造成错误。如下图所示，在执行完<code>first_task</code>的相关任务后，运行到<code>shell</code>进程的<code>fork()</code>操作时，会出现<code>CPU</code>重启：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211941992.png" alt="image-20240521194153623"></p>
<p>因此，需要对<code>task_init()</code>进行修改，删除加入就绪队列的部分，并新建一个函数专门用于启动进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 启动任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_start</span><span class="params">(<span class="type">task_t</span> * task)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    </span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、测试sys-yield"><a href="#2、测试sys-yield" class="headerlink" title="2、测试sys_yield()"></a>2、测试sys_yield()</h3><p><code>fork()</code>会调用两次。</p>
<p>出现异常：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221254675.png" alt="image-20240522125434543"></p>
<p>调试结果如下：</p>
<blockquote>
<p>根据提供的信息，故障发生时的关键寄存器和状态如下：</p>
<ul>
<li><strong>CS</strong>: 8 (内核代码段)</li>
<li><strong>EIP</strong>: 0x13757</li>
<li><strong>EAX</strong>: 0x13E000 (发生Page fault时访问的地址)</li>
<li><strong>ESP</strong>: 0x12FF2C</li>
<li><strong>EFLAGS</strong>: 0x206</li>
<li><strong>Error code</strong>: 11 (0000 1011)</li>
</ul>
<ul>
<li>Page fault错误代码分析</li>
</ul>
<ol>
<li>错误代码<code>11</code>（0000 1011）解释如下：</li>
</ol>
<ul>
<li><p>第0位（P）：0，表示该页没有被加载到内存中。</p>
</li>
<li><p>第1位（W&#x2F;R）：1，表示是写操作引起的。</p>
</li>
<li><p>第2位（U&#x2F;S）：1，表示是用户模式访问引起的。</p>
</li>
<li><p>第3位（RSV）：0，保留位。</p>
</li>
</ul>
<ol start="2">
<li>错误原因分析</li>
</ol>
<p>根据错误代码和寄存器值，访问地址0x13E000没有被映射到内存中，导致Page fault。发生Page fault的地方在0x13757，表示发生错误的指令位于该地址。</p>
<ol start="3">
<li><p>可能原因及排查步骤</p>
</li>
<li><p><strong>检查页表和内存管理</strong>：</p>
<ul>
<li>确保在fork过程中，子进程正确地继承和复制了父进程的页表。</li>
<li>在<code>sys_execve</code>过程中，确保新的页表正确创建和切换。</li>
<li>确保<code>memory_copy_uvm</code>函数正确地复制了页表。</li>
</ul>
</li>
<li><p><strong>查看发生异常的代码段</strong>：</p>
<ul>
<li>确定<code>EIP</code>值0x13757处的代码在执行什么操作。可能需要反汇编或调试来了解具体指令。</li>
</ul>
</li>
<li><p><strong>检查栈和寄存器状态</strong>：</p>
<ul>
<li><p>确认栈指针（ESP）和基址指针（EBP）的值是否合理。</p>
</li>
<li><p>检查<code>sys_execve</code>和<code>sys_fork</code>过程中对栈的操作是否正确。</p>
</li>
</ul>
</li>
<li><p><strong>日志和调试信息</strong>：</p>
<ul>
<li>增加更多日志，特别是在切换页表和分配内存时，记录相关操作的详细信息。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="十四、使用c标准库中的printf输出"><a href="#十四、使用c标准库中的printf输出" class="headerlink" title="十四、使用c标准库中的printf输出"></a>十四、使用c标准库中的printf输出</h1><p>本章节搭建了文件系统框架，引入了字符设备驱动程序，并引用<code>newlib</code>。</p>
<h2 id="14-1-增加文件系统调用"><a href="#14-1-增加文件系统调用" class="headerlink" title="14.1 增加文件系统调用"></a>14.1 增加文件系统调用</h2><p>整理<code>app</code>库下面的所有文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220934175.png" alt="image-20240522093404627" style="zoom:50%;" />

<p>在<code>libapp.a</code>中包含了<code>lib_syscall.c</code>相关的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220952365.png" alt="image-20240522095247136"></p>
<p>因此在将<code>lib_syscall.h</code>中的内联函数修改到<code>lib_syscall.c</code>中后，需要将<code>shell</code>工程与<code>applib.a</code>这个库链接起来。</p>
<p>在<code>kernel/CMakeLists.txt</code>中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;)</span><br><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds $&#123;LIBS_FLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure>



<p>此时调试，会发现进入<code>getpid()</code>内部时出现异常，其中	<code>EIP=0x13D77</code>，说明是在<code>1MB</code>空间内出现了异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;  <span class="comment">// 父子进程各自拥有一份自己的count</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();  <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220958926.png" alt="image-20240522095820675"></p>
<p>在<code>kernel_dis.txt</code>文件中对<code>getpid()</code>进程搜索，发现其所处的位置即在<code>1MB</code>空间内。但它作为一个系统调用的接口函数，不应该放在操作系统空间内，而应该放在用户进程空间内，即<code>0x80000000</code>以上的位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221000006.png" alt="image-20240522100021888"></p>
<p>因此需要对<code>kernel/kernel.lds</code>进行修改，将<code>applib</code>相关的代码和数据放到<code>0x80000000</code>以上的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">PROVIDE(s_first_task = LOADADDR(.first_task));</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">	*lib_syscall*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task));</span><br></pre></td></tr></table></figure>

<p>再次调试，<code>EIP</code>的地址正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221007171.png" alt="image-20240522100723076"></p>
<h2 id="14-2-导入newlib-c并引入printf"><a href="#14-2-导入newlib-c并引入printf" class="headerlink" title="14.2 导入newlib c并引入printf"></a>14.2 导入newlib c并引入printf</h2><p><code>newlib</code>库简介：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221022455.png" alt="image-20240522102216196"></p>
<p>引入<code>newlib</code>库之后的整体结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221023403.png" alt="image-20240522102346233" style="zoom:50%;" />

<p>在<code>shell</code>工程中引入<code>newlib</code>库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp -L $&#123;CMAKE_BINARY_DIR&#125;/../../newlib/i686-elf/lib -lm -lc&quot;)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221057186.png" alt="image-20240522105741951"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221059676.png" alt="image-20240522105925398"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">        <span class="comment">// 设置first_task的堆起始地址和结束地址</span></span><br><span class="line">        task-&gt;heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;  </span><br><span class="line">        	<span class="comment">// 通过循环，最终指向进程地址空间中最后一个表项的末端地址</span></span><br><span class="line">        	<span class="comment">// 也就是指向.bss的末端地址</span></span><br><span class="line">        task-&gt;heap_end = task-&gt;heap_start;</span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、sbrk"><a href="#1、sbrk" class="headerlink" title="1、sbrk()"></a>1、sbrk()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调整堆的内存分配，返回堆之前的指针</span></span><br><span class="line"><span class="comment"> *        目前并不处理incr小于0的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">sys_sbrk</span><span class="params">(<span class="type">int</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    <span class="type">int</span> pre_incr = incr;</span><br><span class="line">    <span class="type">char</span> *pre_heap_end = (<span class="type">char</span> *)task-&gt;heap_end;  <span class="comment">// 获取当前堆的末端地址</span></span><br><span class="line"></span><br><span class="line">    ASSERT(incr &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (incr == <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;sbrk(0): end=0x%x&quot;</span>, pre_heap_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增长空间的起始地址（即原末端地址），和末端地址</span></span><br><span class="line">    <span class="type">uint32_t</span> start = task-&gt;heap_end;</span><br><span class="line">    <span class="type">uint32_t</span> end = start + incr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x81001024 - 0x81001048      0x81001024并非页边界对齐 ： 0x81001000 </span></span><br><span class="line">    <span class="comment">// 0x81001000 - 0x81001FFF      假定这块内存已经存在</span></span><br><span class="line">    <span class="type">int</span> start_offset = start % MEM_PAGE_SIZE;  <span class="comment">// 0x24，start地址在页中的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset) &#123;</span><br><span class="line">        <span class="comment">// 若起始地址并非页边界对齐</span></span><br><span class="line">        <span class="keyword">if</span> (start_offset + incr &lt;= MEM_PAGE_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 0x24 + incr 若并未超过一页，直接在原内存中分配</span></span><br><span class="line">            task-&gt;heap_end = end;  <span class="comment">// 0x81001048</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若超过一页，则先分配掉一页</span></span><br><span class="line">            <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - start_offset;  <span class="comment">// 当前页可分配内存</span></span><br><span class="line">            start += curr_size;</span><br><span class="line">            incr -= curr_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若incr还有剩余，则新分配页来处理</span></span><br><span class="line">    <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> curr_size = end - start;</span><br><span class="line">        <span class="type">int</span> err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_U | PTE_W);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;sbrk: alloc mem failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span> *)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;sbrk(%d): end = 0x%x&quot;</span>, pre_incr, end);</span><br><span class="line">    task-&gt;heap_end = end;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> * )pre_heap_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib_syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    sbrk(<span class="number">0</span>);</span><br><span class="line">    sbrk(<span class="number">100</span>);</span><br><span class="line">    sbrk(<span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">2</span> + <span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">5</span> + <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot; -- arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221251345.png" alt="image-20240522125116933"></p>
<h3 id="2、printf"><a href="#2、printf" class="headerlink" title="2、printf()"></a>2、printf()</h3><p><code>printf()</code>最终会通过文件系统的接口，将格式化好的数据写入标准输出。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221944469.png" alt="image-20240522194431100" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    ptr[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 加入结束符</span></span><br><span class="line">    log_printf(<span class="string">&quot;%s&quot;</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、使用控制台与键盘进行输入输出"><a href="#十五、使用控制台与键盘进行输入输出" class="headerlink" title="十五、使用控制台与键盘进行输入输出"></a>十五、使用控制台与键盘进行输入输出</h1><h2 id="15-1-控制台简介"><a href="#15-1-控制台简介" class="headerlink" title="15.1 控制台简介"></a>15.1 控制台简介</h2><p>操作系统启动后可以分为图形模式和文本模式。但图形界面并不是一个操作系统必须的组件。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230918110.png" alt="image-20240523091843752" style="zoom:50%;" />

<p><strong>每个</strong>显示的字符由<strong>两个</strong>配置字节数据控制：</p>
<ul>
<li>一个字节用于显示的字符；</li>
<li>一个字节用于配置显示属性。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230920616.png" alt="image-20240523092019270" style="zoom: 50%;" />

<p>计算机上电启动后，显示器默认设置成<code>80列x25行</code>的文本显示模式。一屏的显示需要<code>80*25*2=4000</code>字节的显存，因此<code>32KB</code>可以装下<code>8</code>屏幕的显示内容。</p>
<ul>
<li><p>可以同时在几个虚拟屏幕上显示，相当于打开多个命令行窗口并显示相应的内容；<strong>（本项目主要实现）</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230925271.png" alt="image-20240523092543957" style="zoom:50%;" />
</li>
<li><p>也可以将<code>32KB</code>显存分成<code>8</code>块，每块分别用于显示虚拟的控制台界面。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230926563.png" alt="image-20240523092610198" style="zoom:50%;" /></li>
</ul>
<h2 id="15-2-在控制台上显示字符串"><a href="#15-2-在控制台上显示字符串" class="headerlink" title="15.2 在控制台上显示字符串"></a>15.2 在控制台上显示字符串</h2><h3 id="1、控制台结构体定义"><a href="#1、控制台结构体定义" class="headerlink" title="1、控制台结构体定义"></a>1、控制台结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">color_t</span> &#123;</span></span><br><span class="line">    COLOR_Black			= <span class="number">0</span>,</span><br><span class="line">    COLOR_Blue			= <span class="number">1</span>,</span><br><span class="line">    COLOR_Green			= <span class="number">2</span>,</span><br><span class="line">    COLOR_Cyan			= <span class="number">3</span>,</span><br><span class="line">    COLOR_Red			= <span class="number">4</span>,</span><br><span class="line">    COLOR_Magenta		= <span class="number">5</span>,</span><br><span class="line">    COLOR_Brown			= <span class="number">6</span>,</span><br><span class="line">    COLOR_Gray			= <span class="number">7</span>,</span><br><span class="line">    COLOR_Dark_Gray 	= <span class="number">8</span>,</span><br><span class="line">    COLOR_Light_Blue	= <span class="number">9</span>,</span><br><span class="line">    COLOR_Light_Green	= <span class="number">10</span>,</span><br><span class="line">    COLOR_Light_Cyan	= <span class="number">11</span>,</span><br><span class="line">    COLOR_Light_Red		= <span class="number">12</span>,</span><br><span class="line">    COLOR_Light_Magenta	= <span class="number">13</span>,</span><br><span class="line">    COLOR_Yellow		= <span class="number">14</span>,</span><br><span class="line">    COLOR_White			= <span class="number">15</span></span><br><span class="line">&#125;<span class="type">color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述显存字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">disp_char_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">char</span> foreground : <span class="number">4</span>;</span><br><span class="line">        <span class="type">char</span> background : <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint16_t</span> v;  <span class="comment">// 16位，一个字节表示字符；另一个字节表示属性</span></span><br><span class="line">&#125;<span class="type">disp_char_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">console_t</span> &#123;</span></span><br><span class="line">    <span class="type">disp_char_t</span> *disp_base;             <span class="comment">// 控制台基地址</span></span><br><span class="line">    <span class="type">int</span> disp_rows, disp_cols;           <span class="comment">// 总的行列数</span></span><br><span class="line">    <span class="type">int</span> cursor_row, cursor_col;         <span class="comment">// 当前光标所在的行列数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">color_t</span> foreground, background;     <span class="comment">// 字符颜色</span></span><br><span class="line">&#125;<span class="type">console_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、显示字符串"><a href="#2、显示字符串" class="headerlink" title="2、显示字符串"></a>2、显示字符串</h3><p>目前的所有写操作都定向到了<code>fs.c</code>部分，在<code>sys_write()</code>中采用<code>log_printf()</code>来输出，对其进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    console_write(<span class="number">0</span>, ptr, len);</span><br><span class="line">    <span class="comment">// ptr[len] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// log_printf(&quot;%s&quot;, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时调试，进入页异常：<code>Page doesn&#39;t present 0xB80A0</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231017216.png" alt="image-20240523101700997"></p>
<p>这是因为在创建内核页表时，没有加入显存部分的映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 地址映射表, 用于建立内核级的地址映射</span></span><br><span class="line">    <span class="comment">// 地址不变，但是添加了属性</span></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base,   s_text,         <span class="number">0</span>,              PTE_W&#125;,                           <span class="comment">// 内核栈区</span></span><br><span class="line">        &#123;s_text,        e_text,         s_text,         <span class="number">0</span>&#125;,                               <span class="comment">// 内核代码区</span></span><br><span class="line">        &#123;s_data,        (<span class="type">void</span> *)(MEM_EBDA_START - <span class="number">1</span>),   s_data,        PTE_W&#125;,            <span class="comment">// 内核数据区</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)CONSOLE_DISP_ADDR, (<span class="type">void</span> *)CONSOLE_DISP_END, (<span class="type">void</span> *)CONSOLE_DISP_ADDR, PTE_W&#125;,  <span class="comment">// 控制台</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END,     (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,   <span class="comment">// 扩展存储空间一一映射，方便直接操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串显示函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">        show_char(c, ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231024410.png" alt="image-20240523102431257"></p>
<p>对上述函数进行改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                move_to_col0(console);      <span class="comment">// 行号不变，列号变0</span></span><br><span class="line">                move_next_line(console);    <span class="comment">// 行号下移，列号不变</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:         </span><br><span class="line">            <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">            show_char(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、清屏"><a href="#3、清屏" class="headerlink" title="3、清屏"></a>3、清屏</h3><p>只需要将当前屏幕对应的显存显示内容全部用空格符清空，或者用前景色和后景色相同的字符清空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清屏操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_diaplay</span><span class="params">(<span class="type">console_t</span> *console)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算整个屏幕的字符量</span></span><br><span class="line">    <span class="type">int</span> size = console-&gt;disp_cols * console-&gt;disp_rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从基地址开始依次遍历</span></span><br><span class="line">    <span class="type">disp_char_t</span> *start = console-&gt;disp_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++, start++) &#123;</span><br><span class="line">        start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        start-&gt;background = console-&gt;background;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、滚屏"><a href="#4、滚屏" class="headerlink" title="4、滚屏"></a>4、滚屏</h3><p>注意以下两种情况需要滚屏：</p>
<ul>
<li>1）当光标前移时，若到达行末尾处需要移动到下一行，此时就需要判断当前是否需要滚屏；</li>
<li>2）在控制台写入内容时，若遇到换行操作，也需要判断当前是否需要滚屏。</li>
</ul>
<p>将除最底部的行外全部上移一行，再将最下边一行清空。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231031828.png" alt="image-20240523103159602" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 擦除从start到end的行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">erase_rows</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_start = console-&gt;disp_base + console-&gt;disp_cols * start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_end = console-&gt;disp_base + console-&gt;disp_cols * (end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (disp_start &lt; disp_end) &#123;</span><br><span class="line">        disp_start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        disp_start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        disp_start-&gt;background = console-&gt;background;</span><br><span class="line"></span><br><span class="line">        disp_start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 整体屏幕上移若干行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param lines 上移的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll_up</span><span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> lines)</span> &#123;</span><br><span class="line">    <span class="comment">// 整体上移</span></span><br><span class="line">    <span class="type">disp_char_t</span> * dest = console-&gt;disp_base;</span><br><span class="line">    <span class="type">disp_char_t</span> * src = console-&gt;disp_base + console-&gt;disp_cols * lines;</span><br><span class="line">    <span class="comment">// console-&gt;disp_rows - lines    上移后剩余的行数A</span></span><br><span class="line">    <span class="comment">// A *console-&gt;disp_cols         整体剩余的字符数（也就是上移后需要显示字符数）</span></span><br><span class="line">    <span class="type">uint32_t</span> size = (console-&gt;disp_rows - lines) * console-&gt;disp_cols * <span class="keyword">sizeof</span>(<span class="type">disp_char_t</span>);</span><br><span class="line">    kernel_memcpy(dest, src, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除最后一行</span></span><br><span class="line">    erase_rows(console, console-&gt;disp_rows - lines, console-&gt;disp_rows - <span class="number">1</span>);</span><br><span class="line">    console-&gt;cursor_row -= lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3-设置光标并重定向日志输出到显示器"><a href="#15-3-设置光标并重定向日志输出到显示器" class="headerlink" title="15.3 设置光标并重定向日志输出到显示器"></a>15.3 设置光标并重定向日志输出到显示器</h2><p>光标的位置分<strong>高8位和低8位</strong>两部分来表示，由于当前显示为<code>80*25</code>，共<code>2000</code>个字符，所以位置取值为<code>0~1999</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取当前光标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_cursor_pos</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"> 	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	pos = inb(<span class="number">0x3D5</span>);</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	pos |= inb(<span class="number">0x3D5</span>) &lt;&lt; <span class="number">8</span>;   </span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新鼠标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_cursor_pos</span> <span class="params">(<span class="type">console_t</span> * console)</span> &#123;</span><br><span class="line">	<span class="type">uint16_t</span> pos = console-&gt;cursor_row *  console-&gt;display_cols + console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-4-保存并恢复光标位置"><a href="#15-4-保存并恢复光标位置" class="headerlink" title="15.4 保存并恢复光标位置"></a>15.4 保存并恢复光标位置</h2><p><code>ANSI</code>转义序列(<code>ANSI escape sequences</code>)，可用于控制视频终端上的光标位置、颜色和其他选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\0337Hello, world!\0338123\n&quot;</span>);  <span class="comment">// 123lo,world!</span></span><br></pre></td></tr></table></figure>

<p><code>\0337</code>在<code>7</code>的位置保存光标位置，然后在<code>\0338</code>中<code>8</code>的位置用<code>123</code>进行替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 普通状态下的字符的写入处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> ASCII_ESC:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_ESC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写入以ESC开头的序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// https://blog.csdn.net/ScilogyHunter/article/details/106874395</span></span><br><span class="line">    <span class="comment">// ESC状态处理, 转义序列模式 ESC 0x20-0x27(0或多个) 0x30-0x7e</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:		<span class="comment">// ESC 7 保存光标</span></span><br><span class="line">            save_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:		<span class="comment">// ESC 8 恢复光标</span></span><br><span class="line">            restore_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c-&gt;write_state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_NORMAL: &#123;</span><br><span class="line">                write_normal(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_ESC:</span><br><span class="line">                write_esc(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_cursor_pos(c);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-5-更新显示字体的颜色"><a href="#15-5-更新显示字体的颜色" class="headerlink" title="15.5 更新显示字体的颜色"></a>15.5 更新显示字体的颜色</h2><blockquote>
<p>详见《LINUX内核完全剖析：基于0.12内核》附录部分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231527961.png" alt="image-20240523152720901" style="zoom:50%;" />&#96;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理ESC [Pn;Pn 开头的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc_square</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 接收参数</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 解析当前参数</span></span><br><span class="line">        <span class="type">int</span> * param = &amp;console-&gt;esc_param[console-&gt;curr_param_index];</span><br><span class="line">        *param = *param * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;;&#x27;</span>) &amp;&amp; console-&gt;curr_param_index &lt; ESC_PARAM_MAX) &#123;</span><br><span class="line">        <span class="comment">// 参数结束，继续处理下一个参数</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结束上一字符的处理</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经接收到所有的字符，继续处理</span></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">// 设置字符属性</span></span><br><span class="line">            set_font_style(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:	<span class="comment">// 光标左移n个位置 ESC [Pn D</span></span><br><span class="line">            move_left(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            move_right(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            move_cursor(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            erase_in_display(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-6-键盘初始化"><a href="#15-6-键盘初始化" class="headerlink" title="15.6 键盘初始化"></a>15.6 键盘初始化</h2><p>计算机中使用键盘控制器(<code>8042</code>)控制鼠标和键盘。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231600337.png" alt="image-20240523160008317" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231601872.png" alt="image-20240523160123502" style="zoom: 80%;" />

<p><strong>只需要对键盘的中断进行重写设置，而不需要自己去重新初始化键盘。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">    irq_enable(IRQ1_KEYBOARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_kbd</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>init/start.S</code>中进行增加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 硬件中断</span><br><span class="line">exception_handler kbd, 0x21, 0</span><br></pre></td></tr></table></figure>

<h2 id="15-7-借助按键映射表进行键值转换"><a href="#15-7-借助按键映射表进行键值转换" class="headerlink" title="15.7 借助按键映射表进行键值转换"></a>15.7 借助按键映射表进行键值转换</h2><p>当按键按下时和弹出时，都会产生一串扫描码，<strong>其数值并不与键盘上的字符ASCII相同</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231618145.png" alt="image-20240523161852835"></p>
<h1 id="十六、设备管理与文件系统"><a href="#十六、设备管理与文件系统" class="headerlink" title="十六、设备管理与文件系统"></a>十六、设备管理与文件系统</h1><h2 id="16-1-设备管理框架"><a href="#16-1-设备管理框架" class="headerlink" title="16.1 设备管理框架"></a>16.1 设备管理框架</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231934732.png" alt="image-20240523193407466" style="zoom:50%;" />

<p>在计算系统中，往往有很多种不同类型的设备，操作系统需要对这些设备进行统一管理。为每种类型设备都提供一套操作接口并不现实，且操作系统难以处理。因此，需要对设备进行“<strong>抽象</strong>”，得到所谓的“<strong>设备管理层</strong>”，负责对不同类型的设备进行抽象管理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936141.png" alt="image-20240523193634814" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936997.png" alt="image-20240523193649716" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME_SIZE       32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span>;</span></span><br><span class="line"><span class="comment">// 特定设备结构（定义该类设备下特殊设备的特殊性质）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mode;       <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">int</span> minor;      <span class="comment">// 次设备号（主次设备号决定具体是哪个设备）</span></span><br><span class="line">    <span class="type">void</span> *data;     <span class="comment">// 设备相关参数</span></span><br><span class="line">    <span class="type">int</span> open_count; <span class="comment">// 设备打开次数</span></span><br><span class="line">&#125;<span class="type">device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备结构（定义某类设备的一般特性）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DEV_NAME_SIZE];   <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">// 主设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="type">device_t</span> *dev);</span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*control)(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">device_t</span> *dev);</span><br><span class="line">&#125;<span class="type">dev_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-增加tty设备"><a href="#16-2-增加tty设备" class="headerlink" title="16.2 增加tty设备"></a>16.2 增加tty设备</h2><h3 id="1、理论-1"><a href="#1、理论-1" class="headerlink" title="1、理论"></a>1、理论</h3><p>由于键盘和显示器密切相关，因此将二者抽象为一种硬件设备<code>tty</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231949301.png" alt="image-20240523194931067" style="zoom:50%;" />

<p>操作系统需要提供一套抽象机制，对所有设备进行抽象管理，以向上屏蔽复杂的硬件细节。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231950402.png" alt="image-20240523195038914"></p>
<p>上图中左边的<code>5</code>个函数最终会被注册到<code>_dev_desc_t</code>的<code>5</code>个函数指针中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232005483.png" alt="image-20240523200517185"  />

<h3 id="2、增加tty设备的过程"><a href="#2、增加tty设备的过程" class="headerlink" title="2、增加tty设备的过程"></a>2、增加<code>tty</code>设备的过程</h3><ol>
<li><p>新增<code>tty.c</code>和<code>tty.h</code>；</p>
</li>
<li><p>在<code>tty.c</code>中实现<code>tty</code>相应的设备管理操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br></pre></td></tr></table></figure>

<p>并将上述操作注册到<code>dev_desc_t</code>中，定义一个<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">    .major = DEV_TTY,</span><br><span class="line">    .open = tty_open,</span><br><span class="line">    .read = tty_read,</span><br><span class="line">    .write = tty_write,</span><br><span class="line">    .control = tty_control,</span><br><span class="line">    .close = tty_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>dev.c</code>中声明外部变量<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br></pre></td></tr></table></figure>

<p>接下来根据<code>tty</code>相关操作实现上层接口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>tty</code>设备添加结构描述</p>
<p>根据<code>32KB</code>显存可显示<code>8</code>块屏幕，将键盘与<code>8</code>块（虚拟）屏幕共享：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232032635.png" alt="image-20240523203230358" style="zoom: 67%;" />

<p>因此，为所有设备定义一个<code>tty</code>数组，分别对应一部分显存。但是，由于操作系统的运行速度很快，因此向设备发送指令&#x2F;数据也很快；但设备的速度很慢，所以硬件写指令&#x2F;数据很慢，所以需要在设备驱动中配置缓存，用于解决这种速度不匹配的问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232037597.png" alt="image-20240523203716361"></p>
</li>
</ol>
<p>当前在<code>log.c</code>中采用<code>console_write()</code>进行打印操作，但未来也可能有其他的设备需要进行打印操作，因此需要进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> log_dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    log_dev_id = dev_open(DEV_TTY, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 日志打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// console_write(0, str_buf, kernel_strlen(str_buf));</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, str_buf, kernel_strlen(str_buf));</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// console_write(0, &amp;c, 1);</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样后续修改设备时，只需要在初始化时对<code>dev_open</code>进行改动即可。</p>
<h3 id="3、定义tty设备"><a href="#3、定义tty设备" class="headerlink" title="3、定义tty设备"></a>3、定义tty设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_IBUF_SIZE				512		<span class="comment">// tty输入缓存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_OBUF_SIZE				512		<span class="comment">// tty输出缓存大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 FIFO（First In, First Out）缓冲区，</span></span><br><span class="line"><span class="comment"> * 用于在字符设备（例如终端）中管理数据流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_fifo_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;      <span class="comment">// 指向存储缓冲区数据的指针</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 缓冲区的最大字节数</span></span><br><span class="line">    <span class="type">int</span> read;       <span class="comment">// 当前读位置的索引</span></span><br><span class="line">    <span class="type">int</span> write;      <span class="comment">// 当前写位置的索引</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 缓冲区中已有的数据量</span></span><br><span class="line">&#125;<span class="type">tty_fifo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> obuf[TTY_OBUF_SIZE];  <span class="comment">// 输出缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ofifo;          <span class="comment">// 输出FIFO队列</span></span><br><span class="line">    <span class="type">char</span> ibuf[TTY_IBUF_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ififo;          <span class="comment">// 输入处理后的FIFO队列</span></span><br><span class="line">&#125;<span class="type">tty_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、打开tty设备"><a href="#4、打开tty设备" class="headerlink" title="4、打开tty设备"></a>4、打开tty设备</h3><p>当<code>write</code>指向队列尾部时，会重新移到队头的位置，直到整个队列中没有空闲位置。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232051032.png" alt="image-20240523205100776" style="zoom:50%;" />

<p>由于整个系统中存在多个<code>tty</code>设备，因此对于键盘的初始化应该仅设置为一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> inited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">        irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">        irq_enable(IRQ1_KEYBOARD);</span><br><span class="line"></span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>console</code>的初始化，需要区别第<code>0</code>块还是其他块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_init</span> <span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *console = console_buf + idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里类型转换为disp_char_t *，那么CONSOLE_COL_MAX * CONSOLE_ROW_MAX就不必再乘以2</span></span><br><span class="line">    <span class="comment">// uint16_t *v = 0x1234;</span></span><br><span class="line">    <span class="comment">// v++;  // v = 0x1236，会按照uint16_t的类型来自增</span></span><br><span class="line">    console-&gt;disp_base = (<span class="type">disp_char_t</span> *)(CONSOLE_DISP_ADDR + idx *(CONSOLE_COL_MAX * CONSOLE_ROW_MAX));</span><br><span class="line"></span><br><span class="line">    console-&gt;disp_cols = CONSOLE_COL_MAX;</span><br><span class="line">    console-&gt;disp_rows = CONSOLE_ROW_MAX;</span><br><span class="line">    console-&gt;foreground = COLOR_White;</span><br><span class="line">    console-&gt;background = COLOR_Black;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console-&gt;cursor_col = 0;  不这样写，避免清空Boot和Loader的信息</span></span><br><span class="line">    <span class="comment">// console-&gt;cursor_row = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cursor_pos = read_cursor_pos();</span><br><span class="line">        console-&gt;cursor_row = cursor_pos / console-&gt;disp_cols;</span><br><span class="line">        console-&gt;cursor_col = cursor_pos % console-&gt;disp_cols;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console-&gt;cursor_row = <span class="number">0</span>;</span><br><span class="line">        console-&gt;cursor_col = <span class="number">0</span>;    </span><br><span class="line">        clear_display(console);</span><br><span class="line">        update_cursor_pos(console);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console-&gt;old_cursor_row = console-&gt;cursor_row;</span><br><span class="line">    console-&gt;old_cursor_col = console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">    console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、通过tty设备写显示数据"><a href="#5、通过tty设备写显示数据" class="headerlink" title="5、通过tty设备写显示数据"></a>5、通过tty设备写显示数据</h3><p>下图所示的缓存按字节存储数据，其中<code>write</code>指向下一待写入数据的位置，<code>read</code>指向下一数据读取的位置。</p>
<p>注项目中实际并未涉及到中断部分。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232118966.png" alt="image-20240523211809752" style="zoom:50%;" />

<p>最简单的方式，进程向硬件写入数据，然后等待硬件发送完成，再写入数据，如此反复，直到所有数据发送完毕。整个过程效率很低。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232120477.png" alt="image-20240523212056141"  />

<p>当加入缓存后，整个实现机制就改变了。一般情况下，进程负责向缓存写入数据，然后启动硬件发送机制，之后由硬件自动完成所有数据的发送，从而完成高效率地数据发送机制。</p>
<p>相比查询来说，速度要更快，进程不必等待。也就是说，在要发送的数据量小于缓存区的大小时，进程只需要将数据丢入缓存区即可退出，不需要再去考虑硬件的后续处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232122435.png" alt="image-20240523212223213"></p>
<p>当调用到<code>console_write()</code>时的调用堆栈如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232144307.png" alt="image-20240523214408045"></p>
<h2 id="16-3-文件系统初始化"><a href="#16-3-文件系统初始化" class="headerlink" title="16.3 文件系统初始化"></a>16.3 文件系统初始化</h2><p>操作系统使用文件系统对磁盘上的存储进行管理，给应用程序提供以文件组织的视图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932371.png" alt="image-20240524093221478"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932986.png" alt="image-20240524093256519"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240933690.png" alt="image-20240524093348655"></p>
<p>定义相关结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME_SIZE      32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_TABLE_SIZE     2048</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">file_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> file_name[FILE_NAME_SIZE];     <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">file_type_t</span> type;                   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                      <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> ref;                            <span class="comment">// 文件打开次数</span></span><br><span class="line">    <span class="type">int</span> dev_id;                         <span class="comment">// 文件对应设备号</span></span><br><span class="line">    <span class="type">int</span> pos;                            <span class="comment">// 文件当前读取位置</span></span><br><span class="line">    <span class="type">int</span> mode;                           <span class="comment">// 文件读取模式，只读/读写</span></span><br><span class="line">&#125;<span class="type">file_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_table_init</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">file_alloc</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">file_free</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-4-为进程添加文件打开表"><a href="#16-4-为进程添加文件打开表" class="headerlink" title="16.4 为进程添加文件打开表"></a>16.4 为进程添加文件打开表</h3><p>在实际应用场合中，往往同时运行着很多应用进程，每个应用进程都可能会进行文件的读写操作。因此，存在下列问题：</p>
<ul>
<li>每个进程需要记录自己打开了哪些文件；</li>
<li>同一件文件可能同时被多个进程同时打开。</li>
</ul>
<p>因此，为了实现文件打开的共享，每个进程只保存一个指针表，其中每项指向自己所打开的文件描述符。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405241450969.png" alt="image-20240524145013782" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_alloc_fd</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task_remove_fd</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">task_file</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-4-打开tty设备并向其写入数据"><a href="#16-4-打开tty设备并向其写入数据" class="headerlink" title="16.4 打开tty设备并向其写入数据"></a>16.4 打开tty设备并向其写入数据</h2><p>文件系统是处于设备管理层之上的。如果对文件进行相应的操作，不能直接调用tty相关的代码，因此文件系统调用设备管理相关的代码，其再调用tty相关的代码。</p>
<p>也就是说，调用层级从高到低依次如下：<code>sys-&gt;dev-&gt;tty</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_isatty</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">int</span> file, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> * dev, <span class="type">int</span> addr, <span class="type">char</span> * buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_close</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-5-从tty读取键值字符串并显示"><a href="#16-5-从tty读取键值字符串并显示" class="headerlink" title="16.5 从tty读取键值字符串并显示"></a>16.5 从tty读取键值字符串并显示</h2><p>原理图如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242032828.png" alt="image-20240524203218224" style="zoom:50%;" />

<h3 id="1、向缓冲区写入，并通知硬件数据已到达"><a href="#1、向缓冲区写入，并通知硬件数据已到达" class="headerlink" title="1、向缓冲区写入，并通知硬件数据已到达"></a>1、向缓冲区写入，并通知硬件数据已到达</h3><p>当有按键按下时，调用<code>tty_in()</code>，此时：</p>
<p>1）首先通过信号量判断缓冲区是否有空闲区域；</p>
<p>2）若有，则会将按下的字符<code>ch</code>放入<code>ififo</code>缓冲区，并通过<code>sem_notify()</code>通知硬件有数据到达；</p>
<p>3）否则，进入等待状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    <span class="type">char</span> key = get_key(raw_code);		<span class="comment">// 去掉最高位</span></span><br><span class="line">    <span class="type">int</span> is_make = is_make_code(raw_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时只处理按键按下的状态</span></span><br><span class="line">	<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (is_make) &#123;</span><br><span class="line">            ...</span><br><span class="line">            tty_in(<span class="number">0</span>, key);  <span class="comment">// important</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入tty字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_in</span> <span class="params">(<span class="type">int</span> idx, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">	<span class="type">tty_t</span> *tty = tty_devs + idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ch放入ififo缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (sem_count(&amp;tty-&gt;isem) &gt;= TTY_IBUF_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入辅助队列，通知数据到达</span></span><br><span class="line">	tty_fifo_put(&amp;tty-&gt;ififo, ch);</span><br><span class="line">	sem_notify(&amp;tty-&gt;isem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从缓冲区读取数据"><a href="#2、从缓冲区读取数据" class="headerlink" title="2、从缓冲区读取数据"></a>2、从缓冲区读取数据</h3><p>通过缓存实现进程和中断之间的配合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">       ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-6-打开标准输出及错误输出文件"><a href="#16-6-打开标准输出及错误输出文件" class="headerlink" title="16.6 打开标准输出及错误输出文件"></a>16.6 打开标准输出及错误输出文件</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242035079.png" alt="image-20240524203555183"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242040884.png" alt="image-20240524204007541"></p>
<blockquote>
<p>在操作系统中，TTY设备（终端设备）通常与标准输入输出文件（即 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>）关联，以便用户能够通过终端设备与系统交互。具体的关联机制可能因操作系统的不同而有所差异，但大致可以分为以下几个步骤和组件：</p>
<ol>
<li><strong>设备驱动与设备文件的关联</strong></li>
</ol>
<p>TTY设备的驱动程序定义了如何与实际的终端硬件进行交互。设备文件（如 <code>/dev/tty</code>）是设备驱动的一个接口，使用户空间程序可以通过文件系统与设备驱动交互。设备文件通常在操作系统启动时由设备驱动创建并注册到文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// TTY设备驱动的初始化</span></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">tty_init</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 注册TTY设备</span></span><br><span class="line">   <span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">       .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">       .major = DEV_TTY,</span><br><span class="line">       .open = tty_open,</span><br><span class="line">       .read = tty_read,</span><br><span class="line">       .write = tty_write,</span><br><span class="line">       .control = tty_control,</span><br><span class="line">       .close = tty_close,</span><br><span class="line">   &#125;;</span><br><span class="line">   register_device(&amp;dev_tty_desc);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>设备文件与文件描述符的关联</strong></li>
</ol>
<p>当用户空间的程序打开一个TTY设备文件时，内核会为该设备文件分配一个文件描述符，并将该文件描述符与TTY设备驱动的操作函数（如 <code>open</code>、<code>read</code>、<code>write</code> 等）关联起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 打开TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="type">device_t</span> *dev)</span> &#123;</span><br><span class="line">   <span class="comment">// 初始化TTY设备</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 读取TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_read</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 从TTY设备读取数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写入TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_write</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 向TTY设备写入数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>标准输入输出与文件描述符的关联</strong></li>
</ol>
<p>在程序启动时，操作系统会为标准输入输出（<code>stdin</code>、<code>stdout</code>、<code>stderr</code>）分配文件描述符（通常是 <code>0</code>、<code>1</code> 和 <code>2</code>），并将这些文件描述符与TTY设备文件关联起来。这使得程序可以通过标准输入输出进行与终端设备的交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">setup_standard_io</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 打开标准输入</span></span><br><span class="line">   <span class="type">file_t</span> *stdin_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">0</span>] = stdin_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准输出</span></span><br><span class="line">   <span class="type">file_t</span> *stdout_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">1</span>] = stdout_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准错误输出</span></span><br><span class="line">   <span class="type">file_t</span> *stderr_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">2</span>] = stderr_file;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>关联关系图</strong></li>
</ol>
<p>以下是TTY设备与标准输入输出文件关联关系的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;lua复制代码+----------------------+           +----------------------+</span><br><span class="line">&gt;| 用户空间程序        |           | 操作系统             |</span><br><span class="line">&gt;|                      |           |                      |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输入（stdin）| |           | | TTY设备文件      | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输出（stdout）| |           | | 设备驱动        | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准错误（stderr）| |           | | 设备文件系统    | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 文件描述符表        |           | 设备描述符表         |</span><br><span class="line">&gt;| (file_table)        |           | (device_table)       |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 设备文件            |           | TTY设备驱动         |</span><br><span class="line">&gt;| (/dev/tty)          |           | (tty_open, tty_read, |</span><br><span class="line">&gt;|                     |           |  tty_write, ...)     |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联</span><br><span class="line">        v</span><br><span class="line">&gt;+----------------------+</span><br><span class="line">&gt;| 硬件设备            |</span><br><span class="line">&gt;| (终端硬件)          |</span><br><span class="line">&gt;+----------------------+</span><br></pre></td></tr></table></figure>

<p>解释每一步的关联</p>
<ol>
<li><strong>用户空间程序</strong>通过标准输入（<code>stdin</code>）、标准输出（<code>stdout</code>）和标准错误（<code>stderr</code>）进行I&#x2F;O操作，这些操作实际上是对文件描述符表（<code>file_table</code>）中的文件描述符进行操作。</li>
<li><strong>文件描述符表</strong>中的文件描述符（如 <code>0</code>, <code>1</code>, <code>2</code>）对应TTY设备文件（如 <code>/dev/tty</code>）。</li>
<li><strong>设备文件</strong>（如 <code>/dev/tty</code>）通过设备描述符表（<code>device_table</code>）与TTY设备驱动（如 <code>tty_open</code>、<code>tty_read</code>、<code>tty_write</code> 等）关联。</li>
<li><strong>TTY设备驱动</strong>负责与实际的硬件设备（终端硬件）进行交互。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param file 当前文件的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_dup</span> <span class="params">(<span class="type">int</span> file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((file &lt; <span class="number">0</span>) || (file &gt;= TASK_OFILE_NR)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;file(%d) is not valid.&quot;</span>, file);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">file_t</span> *p_file = task_file(file);</span><br><span class="line">    <span class="keyword">if</span> (!p_file) &#123;</span><br><span class="line">		log_printf(<span class="string">&quot;file not opened&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在打开文件表中分配新的表项，同样指向该任务</span></span><br><span class="line">    <span class="type">int</span> fd = task_alloc_fd(p_file);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        p_file-&gt;ref++;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log_printf(<span class="string">&quot;No task file avaliable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-7-允许切换tty窗口"><a href="#16-7-允许切换tty窗口" class="headerlink" title="16.7 允许切换tty窗口"></a>16.7 允许切换tty窗口</h2><h3 id="1、通过快捷键方式切换"><a href="#1、通过快捷键方式切换" class="headerlink" title="1、通过快捷键方式切换"></a>1、通过快捷键方式切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_fx_key</span> <span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key - KEY_F1;</span><br><span class="line">    <span class="keyword">if</span> (kbd_state.lctrl_press || kbd_state.rctrl_press) &#123;</span><br><span class="line">        tty_select(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 功能键：写入键盘缓冲区，由应用自行决定如何处理</span></span><br><span class="line">    <span class="keyword">case</span> KEY_F1:</span><br><span class="line">    <span class="keyword">case</span> KEY_F2:</span><br><span class="line">    <span class="keyword">case</span> KEY_F3:</span><br><span class="line">    <span class="keyword">case</span> KEY_F4:</span><br><span class="line">    <span class="keyword">case</span> KEY_F5:</span><br><span class="line">    <span class="keyword">case</span> KEY_F6:</span><br><span class="line">    <span class="keyword">case</span> KEY_F7:</span><br><span class="line">    <span class="keyword">case</span> KEY_F8:</span><br><span class="line">        do_fx_key(key);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 选择tty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_select</span> <span class="params">(<span class="type">int</span> tty)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tty != curr_tty) &#123;</span><br><span class="line">		console_select(tty);</span><br><span class="line">		curr_tty = tty;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_select</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> * console = console_buf + idx;</span><br><span class="line">    <span class="keyword">if</span> (console-&gt;disp_base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 可能没有初始化，先初始化一下</span></span><br><span class="line">        console_init(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pos = idx * console-&gt;display_cols * console-&gt;display_rows;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xC</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xD</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新光标到当前屏幕</span></span><br><span class="line">    update_cursor_pos(console);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="type">char</span> num = idx + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    show_char(console, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、在first-task中初始化8个窗口"><a href="#2、在first-task中初始化8个窗口" class="headerlink" title="2、在first_task中初始化8个窗口"></a>2、在first_task中初始化8个窗口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/init/first_task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NR; i++)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="type">char</span> tty_num[<span class="number">5</span>] = <span class="string">&quot;tty:?&quot;</span>;</span><br><span class="line">            tty_num[<span class="number">4</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> * argv[] = &#123;tty_num, (<span class="type">char</span> *)<span class="number">0</span>&#125;;</span><br><span class="line">            execve(<span class="string">&quot;/shell.elf&quot;</span>, argv, (<span class="type">char</span> **)<span class="number">0</span>);</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                msleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        msleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// open(&quot;tty:0&quot;, 0);            // fd = 0，标准输入</span></span><br><span class="line">    open(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 1，标准输出</span></span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 2，标准错误输出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;os version: %s\n&quot;</span>, OS_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        gets(cmd_buf);</span><br><span class="line">        <span class="built_in">puts</span>(cmd_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;shell pid= %d\n&quot;, getpid());</span></span><br><span class="line">        <span class="comment">// msleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，还要在<code>conmsole.c</code>中进行相应的调整。</p>
<h1 id="十七、实现一个命令行解释器"><a href="#十七、实现一个命令行解释器" class="headerlink" title="十七、实现一个命令行解释器"></a>十七、实现一个命令行解释器</h1><h2 id="17-1-初始化命令行解释器"><a href="#17-1-初始化命令行解释器" class="headerlink" title="17.1 初始化命令行解释器"></a>17.1 初始化命令行解释器</h2><p><code>shell</code>俗称壳，即<strong>命令行解释器</strong>，它允许用户交互式的输入命令并解释执行，并且可以调用出相应的应用程序运行，从而让用户能够使用内核的 功能去操作计算机。<code>shell</code>也是一门程序语言，其定义了相应的语法规则，允许用户编写脚本。脚本编写后，由<code>shell</code>解释执行，不需要编译生成可执行程序。除非图形化的<code>shell</code>之外，还有图形化的<code>shell</code>，允许用户用鼠标等进行控制。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242158605.png" alt="image-20240524215849436"></p>
<p>本项目的目标是提供一个命令行的<code>shell</code>，支持执行内置的命令以及加载磁盘上的程序运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242232682.png" alt="image-20240524223243130"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command line interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLI_INPUT_SIZE     1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置命令结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_cmd_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 命令名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *usage;      <span class="comment">// 命令功能</span></span><br><span class="line">    <span class="type">int</span> (*do_func)(<span class="type">int</span> argc, <span class="type">char</span> **argv);</span><br><span class="line">&#125;<span class="type">cli_cmd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行接口结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> curr_input[CLI_INPUT_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_start;</span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *promot;               <span class="comment">// 每次按下回车时显示的提示信息</span></span><br><span class="line">&#125;<span class="type">cli_t</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1、show-promot"><a href="#1、show-promot" class="headerlink" title="1、show_promot()"></a>1、show_promot()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示命令行提示符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_promot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);  <span class="comment">// 注意此处不能使用puts函数</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么不能用 <code>puts</code>？</strong></p>
<ul>
<li><p><code>puts</code> 和 <code>printf</code> 的区别：</p>
<blockquote>
<ul>
<li><strong><code>puts</code>：</strong><ul>
<li><code>puts</code> 函数用于输出字符串，并在末尾自动添加一个换行符 <code>\n</code>。</li>
<li>它的原型是：<code>int puts(const char *str);</code></li>
<li>当你调用 <code>puts(&quot;Hello&quot;);</code> 时，实际输出的是 <code>&quot;Hello\n&quot;</code>。</li>
<li><code>puts</code> 自动刷新输出缓冲区。</li>
</ul>
</li>
<li><strong><code>printf</code>：</strong><ul>
<li><code>printf</code> 函数用于格式化输出，可以输出字符串、整数、浮点数等多种类型的数据。</li>
<li>它的原型是：<code>int printf(const char *format, ...);</code></li>
<li><code>printf(&quot;Hello&quot;);</code> 仅输出 <code>&quot;Hello&quot;</code>，不会自动添加换行符。</li>
<li><code>printf</code> 默认情况下不自动刷新输出缓冲区，除非遇到换行符或手动调用 <code>fflush</code>。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>在 <code>show_promot</code> 函数中不能使用 <code>puts</code> 的原因：</p>
<p><code>show_promot</code> 函数的目的是显示命令行提示符。通常情况下，命令行提示符不需要在末尾自动添加换行符，因为这样会导致用户输入内容出现在下一行，而不是提示符之后。例如：</p>
<ul>
<li><p>使用 <code>printf</code> 和 <code>fflush</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot</code> 直接跟随用户输入。</p>
</li>
<li><p>使用 <code>puts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(cli.promot);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot\n</code>，用户输入会在下一行开始，这不是希望的行为。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2、为什么要加上 <code>fflush</code>？</strong></p>
<ul>
<li><p>缓冲区和 <code>fflush</code>：</p>
<ul>
<li><p><strong>缓冲区</strong>：</p>
<ul>
<li>在标准 I&#x2F;O 库中，输出通常是缓冲的。这意味着输出操作先将数据存储在缓冲区中，只有在缓冲区满、遇到换行符、程序正常结束或手动刷新缓冲区时，数据才会实际输出到终端或文件。</li>
</ul>
</li>
<li><p>**<code>fflush</code>**：</p>
<ul>
<li><code>fflush</code> 函数用于强制刷新输出缓冲区，将缓冲区中的数据立即输出到目标设备。<ul>
<li>它的原型是：<code>int fflush(FILE *stream);</code></li>
<li>当你调用 <code>fflush(stdout);</code> 时，它会刷新标准输出缓冲区，确保所有缓冲的数据立即输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 <code>show_promot</code> 函数中使用 <code>fflush</code> 的原因：</p>
<p>当我们使用 <code>printf</code> 输出命令行提示符时，缓冲区中的数据可能不会立即输出到终端。这意味着用户可能不会立即看到提示符，从而无法开始输入。为了确保提示符立即显示出来，我们需要手动刷新标准输出缓冲区。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>这样可以确保提示符在 <code>printf</code> 调用后立即显示，用户可以看到提示符并开始输入。</p>
</li>
</ul>
<p><strong>3、总结</strong></p>
<p>在 <code>show_promot</code> 函数中：</p>
<ol>
<li>不能使用 <code>puts</code> 是因为 <code>puts</code> 会在字符串末尾自动添加换行符，这不符合命令行提示符的预期行为。</li>
<li>使用 <code>printf</code> 后调用 <code>fflush(stdout)</code> 是为了确保提示符立即显示在终端上，避免缓冲区未被及时刷新导致的显示延迟。</li>
</ol>
<h3 id="2、在shell中按下回退键，回退键也会被写入"><a href="#2、在shell中按下回退键，回退键也会被写入" class="headerlink" title="2、在shell中按下回退键，回退键也会被写入"></a>2、在shell中按下回退键，回退键也会被写入</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405251645958.png" alt="image-20240525164517703"></p>
<p>解决方法：在<code>tty.c/tty_read()</code>中加入相应的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">		<span class="keyword">case</span> ASCII_DEL:</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			len--;</span><br><span class="line">			pbuf--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-进程主动退出exit"><a href="#17-2-进程主动退出exit" class="headerlink" title="17.2 进程主动退出exit()"></a>17.2 进程主动退出exit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 退出进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数有两个关键步骤：</p>
<h3 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、<strong>步骤一</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找当前进程（curr_task）所有的子进程，并将其转交给init进程（first_task）</span></span><br><span class="line"><span class="type">int</span> move_child = <span class="number">0</span>;  <span class="comment">// 标志是否需要唤醒first_task</span></span><br><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_table + i;</span><br><span class="line">    <span class="comment">// 判断当前进程（curr_task）是否有子进程</span></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent == curr_task) &#123;</span><br><span class="line">        <span class="comment">// 若有，则转给first_task，由first_task进行处理</span></span><br><span class="line">        task-&gt;parent = &amp;task_manager.first_task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子进程中有僵尸进程，将其唤醒并回收资源</span></span><br><span class="line">        <span class="comment">// 但注意并不由当前进程（curr_task）自己回收，因为自己将要退出</span></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">            move_child = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>寻找子进程并转交给 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 确保当前进程（<code>curr_task</code>）退出后，其所有的子进程不会成为孤儿进程。孤儿进程需要被重新指定为 <code>first_task</code>（通常是系统的守护进程）的子进程。</li>
<li>操作<ul>
<li>遍历 <code>task_table</code> 中的所有任务。</li>
<li>如果某任务的 <code>parent</code> 是 <code>curr_task</code>，则将该任务的 <code>parent</code> 改为 <code>first_task</code>。</li>
<li>如果该任务是僵尸进程（<code>TASK_ZOMBIE</code>），设置 <code>move_child</code> 标志为1，表示需要唤醒 <code>first_task</code> 来处理这些僵尸进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加锁和解锁</strong>:<ul>
<li><strong>目的</strong>: 保证对 <code>task_table</code> 的操作是线程安全的。</li>
<li><strong>操作</strong>: 在遍历和修改 <code>task_table</code> 时，加锁 (<code>mutex_lock</code>) 和解锁 (<code>mutex_unlock</code>) 确保其他线程不能同时修改任务表。</li>
</ul>
</li>
</ol>
<h3 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒first_task</span></span><br><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"><span class="type">task_t</span> * parent = curr_task-&gt;parent;</span><br><span class="line"><span class="comment">// 若需要唤醒first_task，且当前进程（curr_task）的父进程不是first_task，唤醒first_task</span></span><br><span class="line"><span class="keyword">if</span> (move_child &amp;&amp; (parent != &amp;task_manager.first_task)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task_manager.first_task.state == TASK_WAITING) &#123;</span><br><span class="line">        task_set_ready(&amp;task_manager.first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有父进程在wait，则唤醒父任务进行回收</span></span><br><span class="line"><span class="comment">// 如果父进程没有等待，则一直处理僵死状态？</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;state == TASK_WAITING) &#123;</span><br><span class="line">    task_set_ready(curr_task-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存返回值，当前进程（curr_task）进入僵尸状态</span></span><br><span class="line">curr_task-&gt;status = status;</span><br><span class="line">curr_task-&gt;state = TASK_ZOMBIE;</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>唤醒 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 如果有子进程转交给了 <code>first_task</code> 并且这些子进程中有僵尸进程，确保 <code>first_task</code> 可以及时处理这些僵尸进程。</li>
<li>操作<ul>
<li>如果 <code>move_child</code> 标志为<code>1</code>且 <code>curr_task</code> 的父进程不是 <code>first_task</code>，并且 <code>first_task</code> 当前处于等待状态（<code>TASK_WAITING</code>），则将 <code>first_task</code> 设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>唤醒父任务</strong>:<ul>
<li><strong>目的</strong>: 如果 <code>curr_task</code> 的父任务在等待（例如通过 <code>wait</code> 系统调用等待子进程结束），需要唤醒父任务来处理当前进程的退出。</li>
<li>操作<ul>
<li>如果 <code>curr_task</code> 的父任务处于等待状态（<code>TASK_WAITING</code>），将其设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理当前进程的退出</strong>:<ul>
<li><strong>目的</strong>: 将当前进程标记为僵尸状态，并阻塞当前任务以等待其父进程回收。</li>
<li>操作<ul>
<li>设置 <code>curr_task</code> 的返回状态（<code>status</code>）。</li>
<li>将 <code>curr_task</code> 的状态设置为僵尸状态（<code>TASK_ZOMBIE</code>）。</li>
<li>阻塞当前任务（<code>task_set_block</code>）。</li>
<li>调度其他任务运行（<code>task_dispatch</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>进入和离开中断保护</strong>:<ul>
<li><strong>目的</strong>: 确保在执行关键部分代码时不会被中断打断。</li>
<li><strong>操作</strong>: 进入中断保护（<code>irq_enter_protection</code>）和离开中断保护（<code>irq_leave_protection</code>）。</li>
</ul>
</li>
</ol>
<h3 id="3、两个步骤对比"><a href="#3、两个步骤对比" class="headerlink" title="3、两个步骤对比"></a>3、两个步骤对比</h3><ul>
<li><strong>第一步</strong>: 处理当前进程的子进程，将其重新分配给 <code>first_task</code>，并标记是否有僵尸进程需要处理。</li>
<li><strong>第二步</strong>: 唤醒 <code>first_task</code> 以处理重新分配的子进程和僵尸进程，同时处理当前进程的父任务和将当前进程设置为僵尸状态。</li>
</ul>
<h2 id="17-3-进程等待wait"><a href="#17-3-进程等待wait" class="headerlink" title="17.3 进程等待wait()"></a>17.3 进程等待wait()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待子进程退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1、遍历任务表，寻找僵尸状态的子进程"><a href="#1、遍历任务表，寻找僵尸状态的子进程" class="headerlink" title="1、遍历任务表，寻找僵尸状态的子进程"></a>1、遍历任务表，寻找僵尸状态的子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> * task = task_table + i;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent != curr_task) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">        <span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line"></span><br><span class="line">        *status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">        memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">        memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">        kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;task_table_mutex);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁和解锁<ul>
<li>通过 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 来保护对 <code>task_table</code> 的访问，防止并发修改。</li>
</ul>
</li>
<li>检查子进程<ul>
<li>遍历 <code>task_table</code>，检查每个任务的父进程是否是当前进程（<code>curr_task</code>）。</li>
<li>如果找到一个子进程处于 <code>TASK_ZOMBIE</code> 状态，则准备回收其资源。</li>
</ul>
</li>
</ul>
<h3 id="2、回收僵尸进程"><a href="#2、回收僵尸进程" class="headerlink" title="2、回收僵尸进程"></a>2、回收僵尸进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line">*status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">return</span> pid;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存退出状态<ul>
<li>将子进程的退出状态保存到 <code>status</code> 指向的变量中。</li>
</ul>
</li>
<li>回收资源<ul>
<li>销毁子进程的用户虚拟内存（<code>memory_destroy_uvm</code>）。</li>
<li>释放子进程的内核栈（<code>memory_free_page</code>）。</li>
<li>清空任务结构（<code>kernel_memset</code>）。</li>
</ul>
</li>
<li>解锁并返回<ul>
<li>解锁任务表互斥量，返回子进程的 <code>pid</code>。</li>
</ul>
</li>
</ul>
<h3 id="3、等待子进程退出"><a href="#3、等待子进程退出" class="headerlink" title="3、等待子进程退出"></a>3、等待子进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">curr_task-&gt;state = TASK_WAITING;</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ul>
<li>进入中断保护<ul>
<li>进入中断保护状态，防止在关键操作期间被中断打断。</li>
</ul>
</li>
<li>设置当前进程为等待状态<ul>
<li>将当前进程的状态设置为 <code>TASK_WAITING</code>，并阻塞当前进程（<code>task_set_block</code>）。</li>
</ul>
</li>
<li>任务调度<ul>
<li>通过 <code>task_dispatch</code> 切换到其他任务运行。</li>
</ul>
</li>
<li>离开中断保护<ul>
<li>离开中断保护状态。</li>
</ul>
</li>
</ul>
<h3 id="4、关键步骤总结"><a href="#4、关键步骤总结" class="headerlink" title="4、关键步骤总结"></a>4、关键步骤总结</h3><ol>
<li><strong>遍历任务表，寻找僵尸状态的子进程</strong>。</li>
<li><strong>回收僵尸进程</strong><ul>
<li>保存退出状态。</li>
<li>销毁子进程资源。</li>
<li>清空任务结构。</li>
</ul>
</li>
<li><strong>等待子进程退出</strong><ul>
<li>进入中断保护。</li>
<li>设置当前进程为等待状态。</li>
<li>任务调度。</li>
<li>离开中断保护。</li>
</ul>
</li>
</ol>
<h2 id="17-4-让子进程继承父进程已打开的文件"><a href="#17-4-让子进程继承父进程已打开的文件" class="headerlink" title="17.4 让子进程继承父进程已打开的文件"></a>17.4 让子进程继承父进程已打开的文件</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252002902.png" alt="image-20240525200208616"></p>
<p>出现<code>file not opened</code>是因为在<code>fork()</code>操作的<code>task_init()</code>中，对于<code>file_table</code>进行了清零操作，因此就使得子进程并未继承父进程已打开的文件，无法调用标准输入输出文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset(&amp;task-&gt;file_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;file_table));</span><br></pre></td></tr></table></figure>

<h3 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h3><p>在<code>sys_fork()</code>中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝打开的文件</span></span><br><span class="line">copy_opened_files(child_task);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从当前进程中拷贝已经打开的文件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_opened_files</span><span class="params">(<span class="type">task_t</span> * child_task)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> * parent = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">        <span class="type">file_t</span> * file = parent-&gt;file_table[i];</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            file_inc_ref(file);</span><br><span class="line">            child_task-&gt;file_table[i] = parent-&gt;file_table[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252000979.png" alt="image-20240525200053427"></p>
<h1 id="十八、使用文件系统管理硬件设备"><a href="#十八、使用文件系统管理硬件设备" class="headerlink" title="十八、使用文件系统管理硬件设备"></a>十八、使用文件系统管理硬件设备</h1><h2 id="18-1-描述一个文件系统"><a href="#18-1-描述一个文件系统" class="headerlink" title="18.1 描述一个文件系统"></a>18.1 描述一个文件系统</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252046871.png" alt="image-20240525204658527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252013293.png" alt="image-20240525201314917"></p>
<p> <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252018279.png" alt="image-20240525201853857"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252020223.png" alt="image-20240525202007781"></p>
<h3 id="1、问题1：如何通过路径区分不同的设备"><a href="#1、问题1：如何通过路径区分不同的设备" class="headerlink" title="1、问题1：如何通过路径区分不同的设备"></a>1、问题1：如何通过路径区分不同的设备</h3><p>针对问题一：借鉴设备管理层的方法，针对不同类型的设备，添加相应的文件系统层接口实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405261156858.png" alt="image-20240526115647584" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252025262.png" alt="image-20240525202527701" style="zoom:50%;" />

<h2 id="18-2-挂载设备文件系统"><a href="#18-2-挂载设备文件系统" class="headerlink" title="18.2 挂载设备文件系统"></a>18.2 挂载设备文件系统</h2><h3 id="1、挂载原理"><a href="#1、挂载原理" class="headerlink" title="1、挂载原理"></a>1、挂载原理</h3><p>对于不同类型的文件系统，使用统一的链接进行挂载和管理。</p>
<p>在<code>mount_list</code>中存放了所支持的所有类型的文件系统，存放每个文件系统的名称（如<code>/dev</code>）和对应的操作（以函数指针的方式保存）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252050216.png" alt="image-20240525205036777"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">fs_type_t</span> &#123;</span></span><br><span class="line">    FS_DEVFS,</span><br><span class="line">&#125;<span class="type">fs_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象文件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> mount_point[FS_MOUNTP_SIZE];   <span class="comment">// 挂载文件系统名称</span></span><br><span class="line">    <span class="type">fs_type_t</span> type;     <span class="comment">// 挂载文件系统类型</span></span><br><span class="line">    <span class="type">fs_op_t</span> *op;        <span class="comment">// 指明该结构对应的文件系统的相关操作</span></span><br><span class="line">    <span class="type">void</span> *data;         <span class="comment">// 底层调用时使用，上层调用不使用</span></span><br><span class="line">    <span class="type">int</span> dev_id;         <span class="comment">// 设备id</span></span><br><span class="line">    <span class="type">list_node_t</span> node;   <span class="comment">// 链表节点</span></span><br><span class="line">    <span class="type">mutex_t</span> *mutex;</span><br><span class="line">&#125;<span class="type">fs_t</span>;</span><br></pre></td></tr></table></figure>



<p>在函数调用方面，从高层到底层依次如下：</p>
<p><code>devfs_func =&gt; dev_func =&gt; tty_func</code></p>
<h3 id="2、具体挂载流程"><a href="#2、具体挂载流程" class="headerlink" title="2、具体挂载流程"></a>2、具体挂载流程</h3><p>在文件系统的挂载过程中，<code>mount</code> 函数调用另一个同名的 <code>mount</code> 函数可能会引起混淆。事实上，这里有两个不同的 <code>mount</code> 函数，分别属于不同的上下文。一个是高层次的文件系统管理函数，另一个是具体文件系统的操作函数。</p>
<p><strong>（1）高层次的 <code>mount</code> 函数</strong></p>
<p>负责管理挂载的总体流程，包括检查是否已经挂载、分配资源、调用具体文件系统的挂载操作等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">fs_t</span> *<span class="title function_">mount</span> <span class="params">(<span class="type">fs_type_t</span> type, <span class="type">char</span> *mount_point, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="type">fs_t</span> *fs = (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;mount file system, name: &amp;s, dev: %x&quot;</span>, mount_point, dev_major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前文件系统是否已被挂载</span></span><br><span class="line">    <span class="type">list_node_t</span> *curr = list_first(&amp;mounted_list);</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="type">fs_t</span> *fs = list_node_parent(curr, <span class="type">fs_t</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE) == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;fs is already mounted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> mount_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = list_node_next(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个free_node对应的文件系统fs</span></span><br><span class="line">    <span class="type">list_node_t</span> *free_node = list_remove_first(&amp;free_list);</span><br><span class="line">    <span class="keyword">if</span> (!free_node) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no free, mounted failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    fs = list_node_parent(free_node, <span class="type">fs_t</span>, node);</span><br><span class="line">    <span class="type">fs_op_t</span> *op = get_fs_op(type, dev_major);</span><br><span class="line">    <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;unsupported fs type: %d&quot;</span>, type);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统fs通用初始化</span></span><br><span class="line">    kernel_memset(fs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">fs_t</span>));</span><br><span class="line">    kernel_strncpy(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE);</span><br><span class="line">    fs-&gt;op = op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (op-&gt;mount(fs, dev_major, dev_minor) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;mount fs %s failed&quot;</span>, mount_point);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    list_insert_last(&amp;mounted_list, &amp;fs-&gt;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (fs) &#123;</span><br><span class="line">        <span class="comment">// 回收fs</span></span><br><span class="line">        list_insert_first(&amp;free_list, &amp;fs-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）具体文件系统的 <code>mount</code> 函数</strong></p>
<p>这个 <code>mount</code> 函数是每个具体文件系统实现的一个函数，它被注册到文件系统操作结构（<code>fs_op_t</code>）中。在高层次的 <code>mount</code> 函数中调用 <code>op-&gt;mount</code> 时，实际上是调用具体文件系统的挂载实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor);</span><br><span class="line">    <span class="comment">// 其他操作函数...</span></span><br><span class="line">&#125; <span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体文件系统的挂载函数负责实际的挂载工作，比如初始化文件系统的内部结构、检查设备、加载超级块等。例如，假设我们有一个简单的 <code>devfs</code> 文件系统，它的挂载函数可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devfs_mount</span><span class="params">(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化devfs文件系统的内部结构</span></span><br><span class="line">    <span class="comment">// 检查设备</span></span><br><span class="line">    <span class="comment">// 加载超级块等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）挂载流程详解</strong></p>
<ol>
<li><strong>调用高层次的 <code>mount</code> 函数</strong>：在文件系统初始化过程中，调用 <code>mount</code> 函数，例如 <code>fs_t *fs = mount(FS_DEVFS, &quot;/dev&quot;, 0, 0);</code>。</li>
<li><strong>检查是否已经挂载</strong>：高层次的 <code>mount</code> 函数检查指定的挂载点是否已经挂载文件系统。</li>
<li><strong>分配文件系统结构</strong>：从空闲列表中获取一个 <code>fs_t</code> 结构，并初始化。</li>
<li><strong>获取文件系统操作结构</strong>：通过文件系统类型和主设备号找到对应的文件系统操作结构 <code>fs_op_t</code>。</li>
<li><strong>调用具体文件系统的挂载函数</strong>：通过 <code>op-&gt;mount</code> 调用具体文件系统的挂载函数，例如 <code>devfs_mount</code>。</li>
<li><strong>将挂载的文件系统添加到挂载列表</strong>：如果挂载成功，将文件系统结构 <code>fs_t</code> 添加到挂载列表中。</li>
</ol>
<p><strong>（4）思维导图</strong></p>
<p>以下是这个流程的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml复制代码  高层次的 mount 函数</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  检查是否已经挂载</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  分配文件系统结构</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  获取文件系统操作结构 (fs_op_t)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  调用具体文件系统的 mount 函数 (op-&gt;mount)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  如果挂载成功，添加到挂载列表</span><br></pre></td></tr></table></figure>

<p>通过这个流程图，可以看到高层次的 <code>mount</code> 函数如何协调和管理整个挂载过程，而具体文件系统的 <code>mount</code> 函数则负责实际的挂载操作。</p>
<h2 id="18-3-打开dev-tty0设备"><a href="#18-3-打开dev-tty0设备" class="headerlink" title="18.3 打开dev&#x2F;tty0设备"></a>18.3 打开dev&#x2F;tty0设备</h2><p>设备文件系统并不对应于某个实际的硬件设备，而是抽象出来的用于管理所有硬件设备的一种文件系统。</p>
<p>修改<code>sys_open()</code>，使其变得比较通用，步骤如下：</p>
<ol>
<li><p>分配文件描述符链接</p>
</li>
<li><p>将分配的file结构和一个fd关联</p>
</li>
<li><p>根据传入的路径解析对应的fs结构</p>
<ul>
<li><p>检查名称是否以挂载点开头，如果没有，则认为name在根目录下</p>
</li>
<li><p>即只允许根目录下的遍历</p>
</li>
</ul>
</li>
<li><p>设置file内部相关字段</p>
</li>
<li><p>调用fs内部特定的open函数进行文件打开操作</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> err = fs-&gt;op-&gt;open(fs, name, file);  <span class="comment">// 就是这一句保证了其通用性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续要增加其他设备时只需要修改此处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// devfs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devfs_open</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有支持的设备类型列表，根据path中的路径，找到相应的设备类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(devfs_type_list) / <span class="keyword">sizeof</span>(devfs_type_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="type">devfs_type_t</span> *type = devfs_type_list + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相同的名称，然后从中提取后续部分，转换成字符串</span></span><br><span class="line">        <span class="type">int</span> type_name_len = kernel_strlen(type-&gt;name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 举例：path:tty0  |  type-&gt;name:tty</span></span><br><span class="line">        <span class="comment">// 如果存在挂载点路径，则跳过该路径，取下级子目录</span></span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(path, type-&gt;name, type_name_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换得到设备子序号</span></span><br><span class="line">            <span class="type">int</span> minor;</span><br><span class="line">            <span class="keyword">if</span> ((kernel_strlen(path) &gt; type_name_len) &amp;&amp; (path_to_num(path + type_name_len, &amp;minor) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Get device num failed. %s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开设备</span></span><br><span class="line">            <span class="type">int</span> dev_id = dev_open(type-&gt;dev_type, minor, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dev_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Open device failed:%s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录所在的设备号</span></span><br><span class="line">            file-&gt;dev_id = dev_id;  <span class="comment">// file的设备号指向打开的特定的设备</span></span><br><span class="line">            file-&gt;fs = fs;          <span class="comment">// file所属的文件系统</span></span><br><span class="line">            file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">            file-&gt;size = <span class="number">0</span>;</span><br><span class="line">            file-&gt;type = type-&gt;file_type;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、磁盘与fat16文件系统"><a href="#十九、磁盘与fat16文件系统" class="headerlink" title="十九、磁盘与fat16文件系统"></a>十九、磁盘与fat16文件系统</h1><h2 id="19-1-磁盘基本特性简介"><a href="#19-1-磁盘基本特性简介" class="headerlink" title="19.1 磁盘基本特性简介"></a>19.1 磁盘基本特性简介</h2><h3 id="1、MBR是什么"><a href="#1、MBR是什么" class="headerlink" title="1、MBR是什么"></a>1、MBR是什么</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262044874.png" alt="image-20240526204427543"></p>
<h3 id="2、磁盘的分区和扇区有什么区别"><a href="#2、磁盘的分区和扇区有什么区别" class="headerlink" title="2、磁盘的分区和扇区有什么区别"></a>2、磁盘的分区和扇区有什么区别</h3><p>磁盘分区和扇区是磁盘存储管理中的两个基本概念，但它们指的是不同层次的内容。</p>
<p><strong>1、扇区（<code>Sector</code>）</strong></p>
<p><strong>扇区</strong>是硬盘存储的最小单位。硬盘上的数据被划分为一个一个的扇区进行存储和读取。传统上，一个扇区的大小是512字节，但在一些现代硬盘中，这个大小可以是4096字节（4K扇区）。</p>
<ul>
<li><strong>扇区大小</strong>：通常为512字节或4096字节。</li>
<li><strong>位置</strong>：硬盘表面被划分成多个轨道，每个轨道再分成多个扇区。</li>
<li><strong>标识</strong>：每个扇区有一个唯一的地址，传统上使用柱面（Cylinder）、磁头（Head）、扇区（Sector，简称CHS）来标识，现在更多地使用逻辑块地址（LBA，Logical Block Addressing）来标识。</li>
</ul>
<p><strong>2、分区（<code>Partition</code>）</strong></p>
<p><strong>分区</strong>是硬盘上的一段连续的存储区域，可以被操作系统或用户作为一个独立的逻辑磁盘来使用。分区将一个物理硬盘划分为一个或多个独立的部分，每个部分可以包含文件系统、操作系统或其他数据。</p>
<ul>
<li><strong>分区类型</strong><ul>
<li><strong>主分区（Primary Partition）</strong>：硬盘上最多可以有四个主分区。</li>
<li><strong>扩展分区（Extended Partition）</strong>：扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li>
<li><strong>逻辑分区（Logical Partition）</strong>：位于扩展分区内，可以用于存储数据。</li>
</ul>
</li>
<li><strong>用途</strong>：每个分区可以格式化为不同的文件系统，例如FAT32、NTFS、EXT4等，可以用于安装操作系统或存储数据。</li>
<li><strong>管理</strong>：分区信息存储在硬盘的分区表中，传统的MBR（Master Boot Record）分区表最多支持四个主分区或三个主分区加一个扩展分区，GPT（GUID Partition Table）分区表支持更多的分区和更大的磁盘。</li>
</ul>
<p><strong>3、区别和联系</strong></p>
<p>（1）区别</p>
<ol>
<li><strong>定义和作用</strong>：<ul>
<li><strong>扇区</strong>是硬盘的最小存储单元，具体指硬盘上物理的存储位置。</li>
<li><strong>分区</strong>是硬盘上的逻辑区域，包含多个扇区，可以被操作系统识别和使用。</li>
</ul>
</li>
<li><strong>大小和范围</strong>：<ul>
<li><strong>扇区</strong>的大小通常是固定的（512字节或4096字节）。</li>
<li><strong>分区</strong>的大小可以变化不定，取决于用户或系统的配置，可以包含许多扇区。</li>
</ul>
</li>
<li><strong>管理和用途</strong>：<ul>
<li><strong>扇区</strong>由硬盘控制器直接管理，硬件层面上的数据存储单位。</li>
<li><strong>分区</strong>由操作系统和分区表管理，逻辑层面上的数据管理单位。</li>
</ul>
</li>
</ol>
<p>（2）联系</p>
<ol>
<li><strong>分区包含扇区</strong>：<ul>
<li>一个分区由多个连续的扇区组成，分区的大小和位置通过扇区来确定。</li>
</ul>
</li>
<li><strong>共同作用</strong>：<ul>
<li>分区划分后，操作系统在分区上创建文件系统，文件系统管理扇区上的数据存储。</li>
<li>分区表记录每个分区的起始扇区和大小，操作系统通过分区表来访问和管理硬盘上的数据。</li>
</ul>
</li>
</ol>
<p><strong>4、示例</strong></p>
<p>假设有一个大小为<code>1TB</code>的硬盘，使用传统的<code>512</code>字节扇区：</p>
<ul>
<li><strong>扇区</strong>：整个硬盘包含约<code>2^40 / 2^9 = 2^31</code>个扇区，即大约<code>21亿</code>个扇区。</li>
<li>分区<ul>
<li>第一个分区：从第<code>2048</code>扇区开始，大小为<code>200GB</code>（约400,000,000个扇区）。</li>
<li>第二个分区：从第<code>400,002,048</code>扇区开始，大小为<code>300GB</code>（约600,000,000个扇区）。</li>
<li>其他部分可以划分为更多分区或留作未分区空间。</li>
</ul>
</li>
</ul>
<p>通过分区工具（如fdisk、parted等）可以查看和管理硬盘上的分区信息，每个分区都会有一个对应的起始和结束扇区。文件系统（如NTFS、EXT4等）则进一步管理分区内的数据，决定如何在扇区中存储和检索文件。</p>
<blockquote>
<p>总结来说，<strong>扇区是物理存储单位</strong>，<strong>分区是逻辑存储单位</strong>，分区包含多个扇区，分区表管理和记录分区信息。</p>
</blockquote>
<h3 id="3、初始化磁盘结构和分区结构"><a href="#3、初始化磁盘结构和分区结构" class="headerlink" title="3、初始化磁盘结构和分区结构"></a>3、初始化磁盘结构和分区结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">partinfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[PART_NAME_SIZE];  <span class="comment">// 分区名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> *<span class="title">disk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FS_INVALID = <span class="number">0x00</span>,</span><br><span class="line">        FS_FAT16_0 = <span class="number">0x6</span>,</span><br><span class="line">        FS_FAT16_1 = <span class="number">0xE</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_sector;   <span class="comment">// 起始扇区号</span></span><br><span class="line">    <span class="type">int</span> total_sector;   <span class="comment">// 占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">partinfo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述特定磁盘结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DISK_NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> sector_size;    <span class="comment">// 扇区大小</span></span><br><span class="line">    <span class="type">int</span> sector_count;   <span class="comment">// 扇区个数</span></span><br><span class="line">    <span class="type">partinfo_t</span> partinfo[DISK_PRIMARY_PART_CNT];  <span class="comment">// 分区信息</span></span><br><span class="line">&#125;<span class="type">disk_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="19-2-识别系统中已有的磁盘"><a href="#19-2-识别系统中已有的磁盘" class="headerlink" title="19.2 识别系统中已有的磁盘"></a>19.2 识别系统中已有的磁盘</h2><h3 id="1、系统中有多少块硬盘"><a href="#1、系统中有多少块硬盘" class="headerlink" title="1、系统中有多少块硬盘"></a>1、系统中有多少块硬盘</h3><p>两条总线，<code>primary bus</code>和<code>secondary bus</code>，每条总线分别对应两个硬盘。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262111920.png" alt="image-20240526211100606"></p>
<h3 id="2、磁盘检测"><a href="#2、磁盘检测" class="headerlink" title="2、磁盘检测"></a>2、磁盘检测</h3><p>可以通过识别命令来检测硬盘的存在，以及硬盘相关的信息。原始参考资料见:<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode%E3%80%82%E4%BB%A5%E4%B8%8B%E4%BB%85%E5%88%97%E5%87%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">https://wiki.osdev.org/ATA_PIO_Mode。以下仅列出项目中使用的部分内容</a><br>具体流程如下:</p>
<ul>
<li>写<code>Drive/HeadRegster</code>寄存器(地址<code>0x1F6</code>)：<code>0xA0</code>(master drive)或者<code>0xB0</code>(slave driver)</li>
<li>将扇区数量寄存器、<code>LBAlo,LBAmid,和LBAhi10</code>(地址<code>0x1F2-0x1F5</code>)全设置成0</li>
<li>向命令寄存器(地址<code>0x1F7</code>)发送<code>IDENTIFY</code>命令(<code>0xEC</code>)</li>
<li>读取状态寄存器(<code>0x1F7</code>)：如果值为0，则表明该硬盘不存在。如果其它值，等待DRQ置位或者ERR置位</li>
<li>如果<code>ERR</code>清令状态，从<code>0x1F0</code>读取<code>256</code>个<code>16</code>位的数据，其中保存了有关该磁盘相关的信息。</li>
</ul>
<p>返回的256个<code>16</code>位的数据内容：</p>
<ul>
<li>第<code>100-103</code>个数据，共<code>64</code>位：保存了该磁盘总的扇区数量</li>
</ul>
<h3 id="3、代码细节"><a href="#3、代码细节" class="headerlink" title="3、代码细节"></a>3、代码细节</h3><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define DISK_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define PART_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define DISK_PRIMARY_PART_CNT       (<span class="number">4</span>+<span class="number">1</span>)</span><br><span class="line">#define DISK_CNT                    <span class="number">2</span></span><br><span class="line">#define DISK_PER_CHANNEL            <span class="number">2</span>           <span class="comment">// 每通道磁盘数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://wiki.osdev.org/ATA_PIO_Mode#IDENTIFY_command</span></span><br><span class="line"><span class="comment">// 只考虑支持主总线primary bus</span></span><br><span class="line">#define IOBASE_PRIMARY              <span class="number">0</span>x1F0</span><br><span class="line">#define	DISK_DATA(disk)				(disk-&gt;port_base + <span class="number">0</span>)		<span class="comment">// 数据寄存器</span></span><br><span class="line">#define	DISK_ERROR(disk)			(disk-&gt;port_base + <span class="number">1</span>)		<span class="comment">// 错误寄存器</span></span><br><span class="line">#define	DISK_SECTOR_COUNT(disk)		(disk-&gt;port_base + <span class="number">2</span>)		<span class="comment">// 扇区数量寄存器</span></span><br><span class="line">#define	DISK_LBA_LO(disk)			(disk-&gt;port_base + <span class="number">3</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_MID(disk)			(disk-&gt;port_base + <span class="number">4</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_HI(disk)			(disk-&gt;port_base + <span class="number">5</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_DRIVE(disk)			(disk-&gt;port_base + <span class="number">6</span>)		<span class="comment">// 磁盘或磁头</span></span><br><span class="line">#define	DISK_STATUS(disk)			(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 状态寄存器</span></span><br><span class="line">#define	DISK_CMD(disk)				(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 命令寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ATA命令</span></span><br><span class="line">#define	DISK_CMD_IDENTIFY			<span class="number">0</span>xEC	    <span class="comment">// IDENTIFY命令</span></span><br><span class="line">#define	DISK_CMD_READ				<span class="number">0</span>x24	    <span class="comment">// 读命令</span></span><br><span class="line">#define	DISK_CMD_WRITE				<span class="number">0</span>x34	    <span class="comment">// 写命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态寄存器</span></span><br><span class="line">#define DISK_STATUS_ERR             (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)    <span class="comment">// 发生错误</span></span><br><span class="line">#define DISK_STATUS_DRQ             (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)    <span class="comment">// 准备好接受数据或者输出数据</span></span><br><span class="line">#define DISK_STATUS_DF              (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)    <span class="comment">// 驱动错误</span></span><br><span class="line">#define DISK_STATUS_BUSY            (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)    <span class="comment">// 正忙</span></span><br><span class="line"></span><br><span class="line">#define	DISK_DRIVE_BASE		    <span class="number">0</span>xE0		<span class="comment">// 驱动器号基础值:0xA0 + LBA</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262205497.png" alt="image-20240526220510242"></p>
<p>1、<code>sda</code>：放<code>boot/loader/kernel</code>；</p>
<p>2、<code>sdb</code>：放<code>FAT16</code>磁盘文件系统，放置相应的应用程序。</p>
<h2 id="19-3-解析磁盘分区表"><a href="#19-3-解析磁盘分区表" class="headerlink" title="19.3 解析磁盘分区表"></a>19.3 解析磁盘分区表</h2><p>分区表中共<code>4</code>个表项，每个表项包含了起始扇区、总扇区数、文件系统类型等关键性信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262212616.png" alt="image-20240526221201306"></p>
<blockquote>
<p><strong>MBR（主引导记录，Master Boot Record）</strong>是传统的磁盘分区表格式之一，用于在硬盘上划分不同的分区。它位于硬盘的第一个扇区（即0柱面、0磁头、1扇区），占用512字节。MBR不仅包含用于启动操作系统的引导代码，还包含分区表，用于描述磁盘上分区的布局。</p>
<p>（1）MBR由三个主要部分组成：</p>
<ol>
<li><strong>引导程序（Bootloader）</strong>：446字节</li>
</ol>
<p>  引导程序包含启动代码，用于引导操作系统。当计算机启动时，BIOS（或UEFI）会加载MBR中的引导代码，并执行它。这个引导代码通常用于查找活动分区，并加载该分区的引导扇区，以便进一步启动操作系统。</p>
<ol start="2">
<li><strong>分区表（Partition Table）</strong>：64字节</li>
</ol>
<p>  分区表包含四个分区项，每个分区项占用16字节。每个分区项描述一个分区的信息。</p>
<p>  一个分区项的格式如下：</p>
<ul>
<li><strong>引导标志（1字节）</strong>：表示该分区是否为活动分区（引导分区），值为0x80表示活动分区，0x00表示非活动分区。</li>
<li><strong>起始CHS地址（3字节）</strong>：分区起始地址，以CHS（柱面、磁头、扇区）格式表示。</li>
<li><strong>分区类型（1字节）</strong>：表示分区类型，例如0x83表示Linux分区，0x07表示NTFS分区。</li>
<li><strong>结束CHS地址（3字节）</strong>：分区结束地址，以CHS格式表示。</li>
<li><strong>起始LBA地址（4字节）</strong>：分区起始地址，以LBA（逻辑块地址）格式表示。</li>
<li><strong>分区大小（4字节）</strong>：分区的大小，以扇区为单位。</li>
</ul>
<ol start="3">
<li><strong>签名（Signature）</strong>：2字节</li>
</ol>
<p>  MBR的最后两个字节是签名，固定为0x55AA，用于标识这是一个有效的MBR。如果这两个字节不匹配，BIOS会认为硬盘上没有有效的MBR，不会继续引导。</p>
<p>（2）示例</p>
<p>假设我们有一个硬盘，其MBR如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&gt;0000: 33 C0 8E D0 BC 00 7C 8B F4 50 07 50 1F FB FC BE 00 7C ...</span></span><br><span class="line">&gt;...</span><br><span class="line"><span class="section">&gt;01BE: 00 01 01 00 07 FE FF FF 3F 00 00 00 BF 9E 0D 00</span></span><br><span class="line"><span class="section">&gt;01CE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01DE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01EE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01FE: 55 AA</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><strong>引导程序</strong>：从偏移量<code>0x0000</code>到<code>0x01BD</code>，共<code>446</code>字节。</li>
<li><strong>分区表</strong></li>
<li>第一个分区项从<code>0x01BE</code>到<code>0x01CD</code>。<ul>
<li><strong>引导标志</strong>：0x00，表示非活动分区。</li>
<li><strong>起始CHS地址</strong>：0x010100，表示柱面1，磁头1，扇区1。</li>
<li><strong>分区类型</strong>：0x07，表示NTFS分区。</li>
<li><strong>结束CHS地址</strong>：0xFEFFFF，表示柱面1023，磁头254，扇区63。</li>
<li><strong>起始LBA地址</strong>：0x0000003F，表示LBA地址63。</li>
<li><strong>分区大小</strong>：0x0DBF9EBF，表示分区大小为22934559扇区（约11GB）。</li>
</ul>
</li>
<li>其他三个分区项从<code>0x01CE</code>到<code>0x01ED</code>，当前示例中这些分区项未使用，全为0。</li>
<li><strong>签名</strong>：最后两个字节<code>0x55AA</code>。</li>
</ul>
<p>（3）分区操作</p>
<p>操作系统和磁盘工具通过读写MBR中的分区表来管理硬盘分区。例如，创建、删除、调整分区大小等操作都涉及到修改MBR中的分区表信息。</p>
<p>（4）MBR的局限性</p>
<p>由于MBR使用32位地址来表示分区大小，因此单个分区的最大容量为2^32个扇区（每扇区512字节），即2TB。此外，MBR分区表最多只能有四个主分区或三个主分区和一个扩展分区（扩展分区内可以包含多个逻辑分区）。这些局限性促使了GPT（GUID Partition Table）等更现代的分区表格式的出现，支持更大的磁盘和更多的分区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检测分区表信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">detect_part_info</span><span class="params">(<span class="type">disk_t</span> *disk)</span> &#123;</span><br><span class="line">    <span class="type">mbr_t</span> mbr;</span><br><span class="line"></span><br><span class="line">    ata_send_cmd(disk, <span class="number">0</span>, <span class="number">1</span>, DISK_CMD_READ);</span><br><span class="line">    <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read mbr failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ata_read_data(disk, &amp;mbr, <span class="keyword">sizeof</span>(mbr));</span><br><span class="line">    <span class="type">part_item_t</span> *item = mbr.part_item;  <span class="comment">// 指向分区表起始位置</span></span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = disk-&gt;partinfo + <span class="number">1</span>;  <span class="comment">// 第0个表项已被使用，所以从第1个表项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MBR_PRIMARY_PART_NR; i++, item++, part_info++) &#123;</span><br><span class="line">        part_info-&gt;type = item-&gt;system_id;</span><br><span class="line">        <span class="keyword">if</span> (part_info-&gt;type == FS_INVALID) &#123;</span><br><span class="line">            part_info-&gt;total_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;start_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;disk = (<span class="type">disk_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            kernel_sprintf(part_info-&gt;name, <span class="string">&quot;%s%d&quot;</span>, disk-&gt;name, i+<span class="number">1</span>);</span><br><span class="line">            part_info-&gt;total_sector = item-&gt;total_sectors;</span><br><span class="line">            part_info-&gt;start_sector = item-&gt;relative_sectors;</span><br><span class="line">            part_info-&gt;disk = disk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262245138.png" alt="image-20240526224546950"></p>
<h2 id="19-4-增加磁盘设备管理"><a href="#19-4-增加磁盘设备管理" class="headerlink" title="19.4 增加磁盘设备管理"></a>19.4 增加磁盘设备管理</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914097.png" alt="image-20240527091359469"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914740.png" alt="image-20240527091426820"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    DEV_TTY,</span><br><span class="line">    DEV_DISK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_disk_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备表（静态注册）</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_desc_t</span> *dev_desc_tbl[] = &#123;</span><br><span class="line">    &amp;dev_tty_desc,</span><br><span class="line">    &amp;dev_disk_desc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disk.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_desc_t</span> dev_disk_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">    .major = DEV_DISK,</span><br><span class="line">    .open = disk_open,</span><br><span class="line">    .read = disk_read,</span><br><span class="line">    .write = disk_write,</span><br><span class="line">    .control = disk_control,</span><br><span class="line">    .close = disk_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>disk_open()</code></p>
<ol>
<li><p>根据次设备号取磁盘号和分区号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> disk_idx = (*dev*-&gt;minor &gt;&gt; <span class="number">4</span>) - <span class="number">0xa</span>;  *<span class="comment">// 取高4位*</span></span><br><span class="line"><span class="type">int</span> part_idx = *dev*-&gt;minor &amp; <span class="number">0xF</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据磁盘编号取对应磁盘</p>
</li>
<li><p>根据分区号取对应分区</p>
</li>
<li><p>将分区信息保存到data中</p>
</li>
<li><p>打开相应中断</p>
</li>
</ol>
<h2 id="19-5-实现磁盘的读取和写入"><a href="#19-5-实现磁盘的读取和写入" class="headerlink" title="19.5 实现磁盘的读取和写入"></a>19.5 实现磁盘的读取和写入</h2><p>由于每条总线上的<code>2</code>块磁盘<strong>共用相同的中断和IO端口</strong>，考虑到多进程可能同时对磁盘进行读写操作，因此最好是加上锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270936751.png" alt="image-20240527093651259"></p>
<p>在<code>identify_disk()</code>中调用了<code>ata_wait_data()</code>来等到数据到达磁盘：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = ata_wait_data(disk);  <span class="comment">// 在此过程中一直占用CPU，效率较低</span></span><br></pre></td></tr></table></figure>

<p>这个等待过程是一个<code>do-while</code>循环，在此过程中一直占用CPU，效率较低。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">// 等待数据或者有错误</span></span><br><span class="line">       status = inb(DISK_STATUS(disk));</span><br><span class="line">       <span class="keyword">if</span> ((status &amp; (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因此考虑结合<strong>信号量和中断</strong>来进行处理。</p>
<p>当进程向磁盘发送读写请求后，在磁盘准备数据的期间，进程暂时主动放弃CPU，并进入等待队列；当磁盘的数据准备好后，向对应的进程发送中断信号，告知进程。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270948328.png" alt="image-20240527094819093" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">disk_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_READ);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ata_read_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">disk_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_WRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        ata_write_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-6-FAT16文件系统"><a href="#19-6-FAT16文件系统" class="headerlink" title="19.6 FAT16文件系统"></a>19.6 FAT16文件系统</h2><h3 id="1、FAT16"><a href="#1、FAT16" class="headerlink" title="1、FAT16"></a>1、FAT16</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271025353.png" alt="image-20240527102544023"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271027930.png" alt="image-20240527102751513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271028998.png" alt="image-20240527102858618"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271034500.png" alt="image-20240527103442028"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271036205.png" alt="image-20240527103603679"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271038250.png" alt="image-20240527103821885"></p>
<h3 id="2、FAT表项配置"><a href="#2、FAT表项配置" class="headerlink" title="2、FAT表项配置"></a>2、FAT表项配置</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271051879.png" alt="image-20240527105122660"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 解析DBR参数，解析出有用的参数</span></span><br><span class="line">    <span class="type">fat_t</span> *fat = &amp;fs-&gt;fat_data;</span><br><span class="line">    fat-&gt;fat_buffer = (<span class="type">uint8_t</span> *)dbr;</span><br><span class="line">    fat-&gt;bytes_per_sec = dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">    fat-&gt;tbl_start = dbr-&gt;BPB_RsvdSecCnt;</span><br><span class="line">    fat-&gt;tbl_sectors = dbr-&gt;BPB_FATSz16;</span><br><span class="line">    fat-&gt;tbl_cnt = dbr-&gt;BPB_NumFATs;</span><br><span class="line">    fat-&gt;root_ent_cnt = dbr-&gt;BPB_RootEntCnt;</span><br><span class="line">    fat-&gt;sec_per_cluster = dbr-&gt;BPB_SecPerClus;</span><br><span class="line">    fat-&gt;cluster_byte_size = fat-&gt;sec_per_cluster * dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">	fat-&gt;root_start = fat-&gt;tbl_start + fat-&gt;tbl_sectors * fat-&gt;tbl_cnt;</span><br><span class="line">    fat-&gt;data_start = fat-&gt;root_start + fat-&gt;root_ent_cnt * <span class="number">32</span> / SECTOR_SIZE;</span><br><span class="line">    fat-&gt;curr_sector = <span class="number">-1</span>;</span><br><span class="line">    fat-&gt;fs = fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单检查是否是FAT16文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (fat-&gt;tbl_cnt != <span class="number">2</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;fat table num error, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">		<span class="keyword">goto</span> mount_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_memcmp(dbr-&gt;BS_FileSysType, <span class="string">&quot;FAT16&quot;</span>, <span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;not a fat16 file system, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录相关的打开信息</span></span><br><span class="line">    fs-&gt;type = FS_FAT16;</span><br><span class="line">    fs-&gt;data = &amp;fs-&gt;fat_data;</span><br><span class="line">    fs-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (dbr) &#123;</span><br><span class="line">        memory_free_page((<span class="type">uint32_t</span>)dbr);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_close(dev_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatfs_unmount</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs)</span> &#123;</span><br><span class="line">    <span class="type">fat_t</span> * fat = (<span class="type">fat_t</span> *)fs-&gt;data;</span><br><span class="line"></span><br><span class="line">    dev_close(fs-&gt;dev_id);</span><br><span class="line">    memory_free_page((<span class="type">uint32_t</span>)fat-&gt;fat_buffer);  <span class="comment">// 释放FAT表项缓冲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-7-遍历目录命令ls"><a href="#19-7-遍历目录命令ls" class="headerlink" title="19.7 遍历目录命令ls"></a>19.7 遍历目录命令ls</h2><p>目前的项目有一个问题：</p>
<p>在<code>first_task()</code>中有系统调用相关的工作，因此在<code>kernel.lds</code>中将系统调用相关的代码和数据放到了内核空间中，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PROVIDE(s_text = .);</span><br><span class="line">.text : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .rodata)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_text = .);</span><br><span class="line"></span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">PROVIDE(s_data = .);</span><br><span class="line">.data : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .data)</span><br><span class="line">&#125;</span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .bss)</span><br><span class="line">&#125;</span><br><span class="line">e_data = .;</span><br></pre></td></tr></table></figure>

<p>然而我们在<code>lib_syscall.c</code>的下述函数中调用了<code>newlib</code>库的<code>malloc()/free()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>但是在链接脚本中并没有把内核空间和<code>newlib</code>库链接起来，因此在编译时就找不到<code>malloc()/free()</code>。</p>
<p>有两种解决方法：</p>
<ol>
<li>将<code>newlib</code>库也加入到内核空间中；——不推荐，会使得内核体积膨胀</li>
<li>将<code>lib_syscall.c</code>复制一份到<code>kernel/init</code>中，同时在<code>CMakeLists.txt</code>中去掉<code>-lapp</code>。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;</span>)</span><br><span class="line">set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>增加<code>ls</code>命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_ls</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span> &#123;</span><br><span class="line">    DIR *p_dir = opendir(<span class="string">&quot;temp&quot;</span>);  <span class="comment">// 本项目暂只支持顶层目录访问</span></span><br><span class="line">    <span class="keyword">if</span> (p_dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(p_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s %d&quot;</span>,</span><br><span class="line">            entry-&gt;type = FILE_DIR ? <span class="string">&#x27;d&#x27;</span> : <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">            entry-&gt;name,</span><br><span class="line">            entry-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(p_dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">    FILE_DIR,</span><br><span class="line">    FILE_NORMAL,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br></pre></td></tr></table></figure>

<p>由于对每个类型的文件的遍历方式不同，因此在<code>_fs_op_t</code>中增加相应的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*opendir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *name, DIR *dir);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir, <span class="keyword">struct</span> dirent *dirent);</span><br><span class="line">    <span class="type">int</span> (*closedir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体的调用实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, DIR * dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;opendir(root_fs, name, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_readdir</span><span class="params">(DIR* dir, <span class="keyword">struct</span> dirent * dirent)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;readdir(root_fs, dir, dirent);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_closedir</span><span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;closedir(root_fs, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    DIR *dir = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DIR));</span><br><span class="line">    <span class="keyword">if</span> (dir == (DIR *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_opendir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)path;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dir);</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_readdir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)&amp;dir-&gt;dirent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> dirent *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;dirent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_closedir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    sys_call(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尤其注意<code>readdir()</code>这一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br></pre></td></tr></table></figure>



<p>FAT16文件系统将顶层目录下的所有文件和目录的信息放在<strong>根目录区</strong>中，因此可以通过读取根目录区中的内容获取根目录下所有的文件和目录信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559579.png" alt="image-20240527155922869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559465.png" alt="image-20240527155900689"></p>
<h2 id="19-8-文件查看命令less"><a href="#19-8-文件查看命令less" class="headerlink" title="19.8 文件查看命令less"></a>19.8 文件查看命令less</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271834662.png" alt="image-20240527183438134"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 列出文本文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_less</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271856539.png" alt="image-20240527185627202"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271857558.png" alt="image-20240527185722278"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/13/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/13/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/" class="post-title-link" itemprop="url">对含有虚函数的类进行sizeof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-13 18:57:45" itemprop="dateCreated datePublished" datetime="2024-06-13T18:57:45+08:00">2024-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 15:48:04" itemprop="dateModified" datetime="2024-07-16T15:48:04+08:00">2024-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">继承与多态</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>561</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoMember</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B3继承空类和B2：</span></span><br><span class="line"><span class="comment"> *  由于本身有数据成员，所以空类的大小并未计算进来；</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 最终的大小为：4(i2) + 8(vptr) + 4(i1) = 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : <span class="keyword">public</span> NoMember, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B4继承B1和B2：</span></span><br><span class="line"><span class="comment"> *  继承B1的数据成员ch</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 4(i3) + 8(vptr_B1) + 1(ch) + 4(i1) + 8(vptr_B2) = 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B4</span> : <span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于B,C都是虚继承，因此D只包含一个A的副本</span></span><br><span class="line"><span class="comment">// 内存大小为 4(int) + 8(B类中指向虚基类A的指针) + 8(C类中指向虚基类A的指针) = 20</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(char b[10]) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">// 定义数组大小</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, n&gt; arr; <span class="comment">// 创建 std::array 对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::array&lt;int, &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;&gt;) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::string s1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(NoMember) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NoMember) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt; std::endl;  <span class="comment">// 9    |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B2) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B2) &lt;&lt; std::endl;  <span class="comment">// 12   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B3) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B3) &lt;&lt; std::endl;  <span class="comment">// 16   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B4) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B4) &lt;&lt; std::endl;  <span class="comment">// 25   |   32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(A) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(C) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(D) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/12/0%20%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/12/0%20%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-12 17:03:47" itemprop="dateCreated datePublished" datetime="2024-06-12T17:03:47+08:00">2024-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-22 10:34:03" itemprop="dateModified" datetime="2024-07-22T10:34:03+08:00">2024-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1、进程和线程以及并发和并行的概念是什么？"><a href="#1、进程和线程以及并发和并行的概念是什么？" class="headerlink" title="1、进程和线程以及并发和并行的概念是什么？"></a>1、进程和线程以及并发和并行的概念是什么？</h3><p><strong>进程</strong>：</p>
<ul>
<li>进程是系统资源分配的最小单位；</li>
<li>进程在 Linux 中通过 <code>fork</code> 系统调用创建，子进程拥有独立的内存空间。每个进程有独立的进程控制块 PCB，包含进程状态、寄存器、内存管理信息等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程是操作系统中的最小执行单元；</li>
<li>线程在 Linux 中通过 <code>pthread_create</code> 创建，每个线程都有独立的线程控制块 TCB，但共享进程的资源。</li>
</ul>
<p><strong>并发和并行</strong>：并发是在单个处理器上多个任务交替执行，实现多个线程同时执行的假象；而并行是在多个处理器上实现多个线程同时执行。</p>
<blockquote>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<strong>一个进程崩溃后，在保护模式下不会对其它进程产生影响</strong>，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉</strong>，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>在 Linux 中，<strong>线程不会拥有独立的内存空间。所有线程共享进程的虚拟地址空间，但每个线程拥有自己独立的栈空间和寄存器集合。</strong>共享内存空间使得线程之间的通信比进程间通信更加高效，但也意味着需要通过同步机制（如互斥锁）来保护共享资源，防止竞态条件。</p>
</blockquote>
<h3 id="2、线程比进程具有哪些优势？"><a href="#2、线程比进程具有哪些优势？" class="headerlink" title="2、线程比进程具有哪些优势？"></a>2、线程比进程具有哪些优势？</h3><ol>
<li>线程在程序中是独立的，并发的执行流，只是同一进程中的多个线程间的隔离程度较小；</li>
<li>当操作系统创建⼀个进程时，必须为进程分配独立的内存空间，并分配大量相关资源；但对于同一进程中的多个线程来说，它们共享进程的虚拟地址空间，每个线程只拥有自己独立的栈空间和寄存器集合。</li>
</ol>
<h3 id="【-】3、什么时候用多进程？什么时候用多线程？"><a href="#【-】3、什么时候用多进程？什么时候用多线程？" class="headerlink" title="【*】3、什么时候用多进程？什么时候用多线程？"></a>【*】3、什么时候用多进程？什么时候用多线程？</h3><ol>
<li><p>需要<strong>频繁创建销毁</strong>的优先用线程；</p>
<p>线程的创建和销毁相对于进程来说更为轻量级，开销更小。线程共享同一个进程的地址空间，可以快速创建和销毁，而进程创建时需要分配独立的地址空间，并且系统调用的开销较大。</p>
</li>
<li><p>需要<strong>进行大量计算</strong>的优先使用线程；</p>
<p>大量计算任务通常需要频繁访问和操作内存。线程共享同一个进程的地址空间，可以快速访问共享数据，避免了进程间通信的开销。另外，线程之间的上下文切换速度较快，更适合 CPU 密集型的计算任务。</p>
</li>
<li><p><strong>强相关的处理</strong>用线程，<strong>弱相关的处理</strong>用进程；</p>
<p>强相关的处理通常需要频繁访问和操作相同的数据。由于线程共享同一地址空间，数据共享和同步相对简单，适合处理强相关的任务。弱相关的处理任务之间相对独立，进程之间互不干扰，独立的地址空间增加了隔离性和安全性，因此弱相关的处理任务使用进程更加合适。</p>
</li>
<li><p>可能要扩展到<strong>多机分布</strong>的用进程，<strong>多核分布</strong>的用线程。</p>
<p><strong>多机分布要求任务能够在不同的物理机器上独立运行</strong>。进程具有独立的地址空间和资源，可以在不同机器之间通过网络进行通信，适合分布式系统。而<strong>多核分布则是指在同一台多核机器上进行并行处理</strong>。线程共享同一进程的地址空间，能够在多核 CPU 上高效运行，利用多核的并行计算能力。</p>
</li>
</ol>
<h3 id="【-】4、线程内存存储在哪里？"><a href="#【-】4、线程内存存储在哪里？" class="headerlink" title="【*】4、线程内存存储在哪里？"></a>【*】4、线程内存存储在哪里？</h3><ol>
<li><strong>线程栈</strong>（Thread Stack）：每个线程都有自己的栈空间，这是线程存储本地变量、函数参数和返回地址的地方。线程栈通常有固定的大小，这个大小可以在创建线程时指定，也可能由操作系统预设。这部分内存通常位于用户空间的栈内存中。</li>
<li><strong>寄存器集</strong>：包括程序计数器、堆栈指针和其他必要的硬件寄存器。这些通常是在处理器内部维护的，并且每个线程都有自己的寄存器状态。</li>
<li><strong>线程局部存储（TLS）</strong>：这是一种允许数据在多个线程之间被隔离的机制。每个线程可以访问自己的专用数据副本，对其他线程不可见。这在编程中用于保持数据的线程安全性。</li>
<li><strong>线程控制块（TCB）</strong>：这是一个内核数据结构，包含了管理线程所需的所有信息，如线程的状态、优先级、调度信息等。线程控制块通常存储在操作系统内核的内存中。</li>
</ol>
<p>这些部分合在一起定义了一个线程的运行环境。每个线程的栈是独立的，但它们共享进程的堆和其他全局资源。</p>
<h3 id="5、线程中的锁包含哪些？"><a href="#5、线程中的锁包含哪些？" class="headerlink" title="5、线程中的锁包含哪些？"></a>5、线程中的锁包含哪些？</h3><ol>
<li><strong>互斥锁</strong>：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</li>
<li><strong>自旋锁</strong>：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</li>
<li><strong>递归锁</strong>：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</li>
<li><strong>读写锁</strong>：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用在读多于写的场景。</li>
</ol>
<h3 id="6、什么是死锁？"><a href="#6、什么是死锁？" class="headerlink" title="6、什么是死锁？"></a>6、什么是死锁？</h3><p><strong>死锁</strong>（Deadlock）是指在多线程或多进程的环境中，两个或多个执行单元因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，这些进程将无法向前推进。</p>
<h3 id="7、死锁产生的原因"><a href="#7、死锁产生的原因" class="headerlink" title="7、死锁产生的原因"></a>7、死锁产生的原因</h3><p>死锁产生主要有以下几个条件，这些条件<strong>同时满足</strong>时，就可能发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被多个线程（或进程）共享，只能被一个线程（或进程）所占用。</li>
<li><strong>请求与保持条件</strong>：线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。</li>
<li><strong>不剥夺条件</strong>：线程所获得的资源在未使用完之前，不能被其他线程强行剥夺。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源循环等待链，每个线程占有一种资源并等待另一种被下一个线程占有的资源。</li>
</ol>
<h3 id="【-】8、如何避免死锁？"><a href="#【-】8、如何避免死锁？" class="headerlink" title="【*】8、如何避免死锁？"></a>【*】8、如何避免死锁？</h3><ol>
<li>系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源。如果分配后系统可能发生死锁，则不予分配，否则予以分配。保证系统不进入死锁状态的动态策略。</li>
<li>在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</li>
</ol>
<h3 id="9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"><a href="#9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？" class="headerlink" title="9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"></a>9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</h3><ol>
<li>如果两个线程同时去分别获取不同的锁时，会出现死锁，比如线程 1 先获得锁 A 而线程 2 先获得锁 B，然后二者都会等待；</li>
<li>正确的获取和释放顺序是：<ol>
<li><strong>按照固定顺序获取锁</strong>：所有线程都按照相同的顺序获取锁，例如，先获取锁 <code>A</code>，然后获取锁 <code>B</code>；</li>
<li><strong>使用 try-lock 方法</strong>：尝试获取锁，如果获取不到，就放弃所有已持有的锁，稍后重试。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex lockA;</span><br><span class="line">std::mutex lockB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、从锁的粒度来说，有哪些？"><a href="#10、从锁的粒度来说，有哪些？" class="headerlink" title="10、从锁的粒度来说，有哪些？"></a>10、从锁的粒度来说，有哪些？</h3><p>（1）<strong>粗粒度锁</strong>：</p>
<ul>
<li><strong>全局锁</strong>：对整个应用程序或系统加锁，通常用于单个进程或单个应用实例中；</li>
<li><strong>模块级锁</strong>：对某个模块或组件加锁，通常用于大型系统中。</li>
</ul>
<p>（2）<strong>细粒度锁</strong>：</p>
<ul>
<li><strong>对象锁</strong>：对单个对象加锁。</li>
<li><strong>方法锁</strong>：对单个方法加锁；</li>
<li><strong>变量锁</strong>：对单个变量或数据结构加锁。</li>
</ul>
<h3 id="11、悲观锁和乐观锁？"><a href="#11、悲观锁和乐观锁？" class="headerlink" title="11、悲观锁和乐观锁？"></a>11、悲观锁和乐观锁？</h3><p>悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。互斥锁、自旋锁、读写锁都属于悲观锁。</p>
<p>相反的，如果并发操作之间的冲突很少，就可以使用乐观锁，它的工作方式是：在读取数据时不加锁，而是在更新数据时检查数据是否发生变化。如果数据没有变化，则进行更新；如果数据发生变化，则放弃更新并重新尝试。</p>
<h3 id="12、忙等待和阻塞的区别是什么？"><a href="#12、忙等待和阻塞的区别是什么？" class="headerlink" title="12、忙等待和阻塞的区别是什么？"></a>12、忙等待和阻塞的区别是什么？</h3><p><strong>（1）忙等待（Busy Waiting）</strong>：忙等待指线程在等待锁或资源可用期间<strong>不断地检查锁的状态，而不进行任何上下文切换</strong>，这种等待方式会使线程保持活跃状态，具有低延迟的特点，但占用 CPU 时间。适用于高并发、低延迟需求的实时系统；如果锁等待时间较长，忙等待会导致大量的 CPU 资源浪费。</p>
<p><strong>（2）阻塞（Blocking）</strong>：阻塞指线程在等待锁或资源可用期间会<strong>被挂起，进入睡眠状态，直到条件满足或锁可用时被唤醒</strong>。这种机制需要操作系统的线程调度和上下文切换支持，但释放了 CPU 资源，以便被其他线程使用。适用于长时间等待或锁持有时间较长的情况，避免了 CPU 资源的浪费。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忙等待</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忙等待，直到 ready 变为 true</span></span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;  </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));  <span class="comment">// 忙等待期间可以加入适当的休眠，减少 CPU 资源浪费</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  <span class="comment">// 模拟一些工作</span></span><br><span class="line">    ready = <span class="literal">true</span>;  <span class="comment">// 设置ready为true，此时worker线程会自动检测到这一情况并执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到ready变为true</span></span><br><span class="line">    <span class="comment">// 此处ready为共享变量，因此用lock来保护</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));      <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="comment">// 唤醒worker线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  </span><br><span class="line">    <span class="comment">// worker线程会在ready变为true之前阻塞等待，而不会浪费CPU资源进行忙等待</span></span><br><span class="line">    <span class="comment">// 一旦ready变为true，worker线程就会被唤醒并继续执行</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>t.join();</code> 是用于等待线程完成执行的一种方法。<code>std::thread</code> 类的 <code>join</code> 成员函数可以确保主线程（或其他调用 <code>join</code> 的线程）等待一个线程完成其执行，并在其完成后继续执行。</p>
<p>具体作用如下：</p>
<ol>
<li><strong>等待线程完成：</strong> <code>t.join();</code> 会阻塞调用线程，直到线程 <code>t</code> 完成其执行。</li>
<li><strong>清理资源：</strong> <code>join</code> 还会清理与线程相关的资源。如果不调用 <code>join</code> 或 <code>detach</code>，在线程对象生命周期结束时会导致程序异常。</li>
</ol>
</blockquote>
<h3 id="13、一个进程可以创建多少线程？和什么有关？"><a href="#13、一个进程可以创建多少线程？和什么有关？" class="headerlink" title="13、一个进程可以创建多少线程？和什么有关？"></a>13、一个进程可以创建多少线程？和什么有关？</h3><p>分不同系统去看。</p>
<ul>
<li>如果是 <code>32</code> 位系统，用户态的虚拟空间只有 <code>3G</code>，如果创建线程时分配的栈空间是 <code>10M</code>，那么一个进程最多只能创建 <code> 300 (3G/10M)</code> 个左右的线程。</li>
<li>如果是 <code>64</code> 位系统，用户态的虚拟空间大到有 <code>128T</code>，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如以下三个内核参数：<ul>
<li><code>/proc/sys/kernel/threads-max</code>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><code>/proc/sys/kernel/pid_max</code>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><code>/proc/sys/vm/max_map_count</code>，表示限制一个进程可以拥有的 VMA (虚拟内存区域)的数量，默认值是 <code>65530</code>。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407032203672.png" alt="image-20240703220333465" style="zoom:80%;" />

<h3 id="14、多线程如何保证线程安全？"><a href="#14、多线程如何保证线程安全？" class="headerlink" title="14、多线程如何保证线程安全？"></a>14、多线程如何保证线程安全？</h3><ol>
<li>使用<strong>互斥锁（Mutex）</strong>保护共享资源。</li>
<li>使用<strong>自旋锁（Spinlock）</strong>在短时间锁定的场景。</li>
<li>使用<strong>条件变量（Condition Variable）</strong>进行线程间通信。</li>
<li>使用<strong>原子操作（Atomic Operations）</strong>进行无锁编程。</li>
<li>使用<strong>读写锁（Reader-Writer Lock）</strong>优化读多写少的场景。</li>
<li>使用<strong>线程局部存储（Thread-Local Storage）</strong>确保每个线程独立的数据。</li>
</ol>
<h3 id="15、多线程环境下对变量的读写操作是否是原子的？"><a href="#15、多线程环境下对变量的读写操作是否是原子的？" class="headerlink" title="15、多线程环境下对变量的读写操作是否是原子的？"></a>15、多线程环境下对变量的读写操作是否是原子的？</h3><p>不一定是原子性的。（1）对基本数据类型的赋值操作通常被认为是原子性的，因为它们在单个指令周期内完成；（2）而对于那些被总线带宽、cache line 以及 page 大小给分隔开的内存地址的访问则不是原子性的。</p>
<p>以下是举例说明：</p>
<p>1）对于 <code>x=1</code> 来说，因为 x 是 int 类型，在 x86 上由硬件直接提供了原子性支持。在进行这样的赋值操作时，CPU 会将整个 32 位的值一次性写入到内存中，而不是分开写入。因此，即使有多个线程同时执行类似 <code>x=1</code> 的赋值语句，也不会出现损坏 x 值的情况。</p>
<p>2）对于 <code>x++</code> 和 <code>++x</code> 来说，这样的操作在多线程环境下是需要同步的。因为 x86 会按三条指令的形式来处理这种语句：A. 从内存中读 x 的值到寄存器中；B. 对寄存器加 1；C. 再把新值写回 x 所处的内存地址。</p>
<blockquote>
<p>（1）一些基本的内存读写操作本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；</p>
<p>（2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性；</p>
<p>（3）因为很多内存数据是已经存放在L1&#x2F;L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache  coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值（关于cache coherency可以参加我的<a target="_blank" rel="noopener" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">一篇博文</a>）。</p>
</blockquote>
<blockquote>
<p>从Intel486 processor开始，<strong>以下的基本内存操作是原子的</strong>：<br>• Reading or writing a byte（<strong>一个字节的读写</strong>）<br>• Reading or writing a word aligned on a 16-bit boundary（<strong>对齐到16位边界的字的读写</strong>）<br>• Reading or writing a doubleword aligned on a 32-bit boundary（<strong>对齐到32位边界的双字的读写</strong>）</p>
<p>从Pentium processor开始，除了之前支持的原子操作外又新增了以下原子操作：<br>• Reading or writing a quadword aligned on a 64-bit boundary（<strong>对齐到64位边界的四字的读写</strong>）<br>• 16-bit accesses to uncached memory locations that fit within a 32-bit data bus（<strong>未缓存且在32位数据总线范围之内的内存地址的访问</strong>）</p>
<p>从P6 family processors开始，除了之前支持的原子操作又新增了以下原子操作：<br>• Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line（<strong>对单个cache line中缓存地址的未对齐的16&#x2F;32&#x2F;64位访问</strong>）</p>
<p><strong>那么哪些操作是非原子的呢？</strong><br>Accesses to cacheable memory that are split across bus widths, cache lines, and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.（说点简单点，<strong>那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的</strong>，你如果想保证这些操作是原子的，你就得求助于机制（2），对总线发出相应的控制信号才行）。</p>
</blockquote>
<h3 id="16、为什么线程的开销要小于进程的开销？"><a href="#16、为什么线程的开销要小于进程的开销？" class="headerlink" title="16、为什么线程的开销要小于进程的开销？"></a>16、为什么线程的开销要小于进程的开销？</h3><p>首先，任务调度的开销主要包含以下两个方面：</p>
<ol>
<li><p>CPU执行任务调度的开销，主要是<strong>上下文切换</strong>的开销；</p>
</li>
<li><p>任务调度后，CPU Cache&#x2F;TLB 不命中，导致<strong>缺页中断</strong>的开销。</p>
</li>
</ol>
<p>针对第 1 点，无论是进程调度还是线程调度都是必须的，因此两者的差异体现在第 2 点。</p>
<p>进程切换会导致页表、cache、TLB 中的内容发生变化，原进程保存的内容无效，新的进程必须重新加载，导致缺页中断增多，cache，TLB 也命中率下降。而线程切换会保留页表、cache、TLB 中的内容，因为多个线程之间共享进程的这部分资源。因此线程调度的开销要小于进程调度的开销。</p>
<h3 id="17、线程池中的线程数如何确定？"><a href="#17、线程池中的线程数如何确定？" class="headerlink" title="17、线程池中的线程数如何确定？"></a>17、线程池中的线程数如何确定？</h3><p>一般的经验法则是<strong>根据系统的硬件资源，特别是 CPU 的核心数</strong>来确定线程数。</p>
<ul>
<li><p>对于<strong>计算密集型任务</strong>，线程数通常设置为等于或稍大于 CPU 核心数。这样可以最大化CPU利用率，避免上下文切换的开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"><span class="comment">// 返回可用的并发线程数（通常等于CPU核心数）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<strong>I&#x2F;O 密集型任务</strong>，由于任务在执行过程中需要等待 I&#x2F;O 操作完成，因此线程数可设置为高于 CPU 核心数以隐藏 I&#x2F;O 等待时间，提高整体吞吐量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这个倍数可以根据实际情况调整，通常在2到4之间。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18、为什么线程池可以提高吞吐量？"><a href="#18、为什么线程池可以提高吞吐量？" class="headerlink" title="18、为什么线程池可以提高吞吐量？"></a>18、为什么线程池可以提高吞吐量？</h3><ul>
<li><strong>减少线程创建和销毁的开销</strong>，线程池在初始化时会创建一定数量的线程，并将它们保存在池中。当任务到达时，线程池会分配一个空闲线程来执行任务，而不是每次都创建新线程。这样可以减少线程创建和销毁的开销，提高了任务处理的效率。</li>
<li><strong>复用线程资源</strong>，执行完一个任务后线程不会立即销毁，而是继续等待新的任务。这样可以避免频繁地创建和销毁线程，减少系统资源的消耗。</li>
<li><strong>控制并发线程数量</strong>，防止因过多线程竞争资源导致系统性能下降的情况发生。</li>
</ul>
<h3 id="【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"><a href="#【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？" class="headerlink" title="【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"></a>【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？</h3><blockquote>
<p>假设队列里边的任务是按时间顺序管理的，那么如果有个高优先级的事件你怎么处理，比如说我移动了一下鼠标它不可能等待所有线程执行完去执行，那怎么处理这样的事件？</p>
<p>如果任务队列的任务之间有依赖关系要怎么处理呢？如果采用同步是不是就死锁了？</p>
</blockquote>
<h3 id="20、C-多线程编程时要链接什么库，怎么找到对应的动态库？"><a href="#20、C-多线程编程时要链接什么库，怎么找到对应的动态库？" class="headerlink" title="20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？"></a>20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？</h3><p>链接 <code>pthread(POSIX threads)</code> 库或 C++11 标准库提供的线程支持库。</p>
<blockquote>
<ol>
<li><p>使用<code>pthread</code>库</p>
</li>
<li><p>链接<code>pthread</code>库</p>
<p>在Linux系统中，使用<code>pthread</code>库时需要在编译时加上<code>-pthread</code>选项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -pthread</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找和链接动态库</p>
<p>动态库一般位于系统的标准库路径中，如<code>/usr/lib</code>或<code>/usr/local/lib</code>。在运行时，操作系统会自动从这些路径中查找所需的动态库。如果动态库位于非标准路径，可以通过设置<code>LD_LIBRARY_PATH</code>环境变量来指定动态库路径。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/your/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>pthread</code>库进行多线程编程</p>
</li>
<li><p>使用 C++11 标准库：不需要额外链接任何库，编译器会自动处理。</p>
</li>
</ol>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -std=c++11</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="21、多线程切换，CPU-和内存会做一些什么处理？"><a href="#21、多线程切换，CPU-和内存会做一些什么处理？" class="headerlink" title="21、多线程切换，CPU 和内存会做一些什么处理？"></a>21、多线程切换，CPU 和内存会做一些什么处理？</h3><ol>
<li><strong>保存当前线程的上下文：</strong> 包括程序计数器（PC）、寄存器状态、栈指针（SP）、调度器信息等，便于在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 不同进程的线程可能涉及页表（Page Table）等内存映射表的切换，以确保能访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。因此可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong>包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<blockquote>
<p>进程切换的意义在于<strong>实现多任务操作系统的基本功能，使多个进程能够在有限的CPU资源下共享执行时间</strong>。</p>
</blockquote>
<h3 id="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"><a href="#22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？" class="headerlink" title="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"></a>22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</h3><p>首先判断这个请求数量远远多于线程是否是常态：</p>
<ul>
<li>如果是常态则先要考虑是不是线程数量设置有问题，其次判断机器是否能力不足以处理这些数据；</li>
<li>假如说硬件和软件都没有问题，那么考虑这个问题为什么会产生，是不是<strong>高计算密集型任务</strong>太多了。如果说当前请求任务比较复杂，那么考虑进行分类，将处理的特别慢的请求作为一个特定类，将一些线程固定给他们使用，而不是所有线程都用来处理这种任务，因为既然很慢，那么慢1个和慢10个点区别就没有那么大了，然后将其他线程用来处理能够快速处理完的请求。</li>
</ul>
<h3 id="23、线程间的通信包括哪些方式？"><a href="#23、线程间的通信包括哪些方式？" class="headerlink" title="23、线程间的通信包括哪些方式？"></a>23、线程间的通信包括哪些方式？</h3><ol>
<li><p><strong>互斥锁（Mutex）</strong>：用于控制多个线程对共享资源的访问，保证同一时间只有一个线程可以访问资源。</p>
</li>
<li><p><strong>条件变量</strong>：利用线程间共享全局变量进行同步的一种机制。允许一个或多个线程在某些条件下暂停执行并等待，直到另一个线程通知它们条件已经满足，从而避免了线程不断轮询检查该条件是否成立而降低效率的情况。</p>
<ol>
<li><p>包含两种等待方式，无条件等待<code>pthread_cond_wait()</code>和计时等待<code>pthread_cond_timewait()</code>两种。注意无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求竞争条件；</p>
<blockquote>
<p><strong>条件变量为什么要和互斥锁一起使用？</strong></p>
<p>这是为了应对线程<code>1</code>在调用<code>pthread_cond_wait()</code>但线程<code>1</code>还没有进入<code>wait cond</code>的状态时，线程<code>2</code>调用了<code>cond_singal</code>的情况。 </p>
<p>如果不用互斥锁的话，这个<code>cond_singal</code>就丢失了。加了锁的情况下，线程<code>2</code>必须等到<code>mutex</code>被释放（也就是<code>pthread_cond_wait()</code>释放锁并进入<code>wait_cond</code>状态 ，此时线程<code>2</code>上锁） 的时候才能调用<code>cond_singal</code>。</p>
</blockquote>
</li>
<li><p>互斥锁必须是普通锁或者适应锁；</p>
</li>
<li><p>在调用<code>pthread_cond_wait()</code>前必须由本线程加锁，而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并<strong>在线程挂起进入等待前解锁</strong>；</p>
<blockquote>
<p><strong>为什么必须由本线程加锁，而不在函数内部定义？</strong></p>
<p>无法确定会有多少用户使用条件变量，所以每个互斥锁都须要动态定义，而且管理大量互斥锁的开销太大，使用用户定义的锁会更加灵活又方便。</p>
</blockquote>
</li>
<li><p>在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 调用前由本线程加锁</span></span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);  <span class="comment">// 无条件等待（经历了解锁-&gt;加锁的过程）</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>信号量（Semaphores）</strong>：如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。 </p>
<ol>
<li><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem , <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// sem 		- 指定要初始化的信号量； </span></span><br><span class="line"><span class="comment">// pshared 	- 信号量 sem 的共享选项，linux只支持0，表示它是当前进程的局部信号量； </span></span><br><span class="line"><span class="comment">// value 	- 信号量 sem 的初始值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值加<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值减<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>sem</code>所指的信号量的数值为<code>0</code>，函数将会等待直到有其它线程使它不再是<code>0</code>为止，此时相当于获取到该信号。</p>
</li>
<li><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>事件（Event）</strong>：类似于条件变量，用于通知一个或多个正在等待的线程某个事件已经发生。</p>
</li>
<li><p><strong>屏障（Barriers）</strong>：用于多个线程同步到某一点，当所有线程都达到屏障点后，它们再同时开始执行后续操作。常用于并行计算，确保所有线程在进行下一步操作前已完成当前操作。</p>
</li>
</ol>
<h3 id="24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"><a href="#24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？" class="headerlink" title="24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"></a>24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？</h3><ol>
<li><p><strong>线程同步</strong>是多线程编程中保证多个线程安全访问共享资源或协调工作的一种机制。它确保在任何给定时刻，只有一个线程可以访问特定的数据或代码块，以防止数据损坏或不一致性。</p>
</li>
<li><p>底层原理上，线程同步问题主要是由于<strong>并发性、不确定性和原子性</strong>导致的：</p>
<ol>
<li><strong>并发性</strong>：多个线程同时执行，导致对共享资源的访问不可控；</li>
<li><strong>不确定性</strong>：线程的执行顺序和执行时间不确定，可能导致对共享资源的交叉访问</li>
<li><strong>原子性</strong>：对共享资源的操作可能不是原子操作，而是由多条指令组成，这会导致中间状态的出现，从而引发问题。</li>
</ol>
</li>
</ol>
<h3 id="25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？"><a href="#25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？" class="headerlink" title="25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？"></a>25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括<strong>互斥锁、条件变量、信号量</strong>等。</p>
<p><strong>等待线程A执行完任务后再执行线程B的处理方式</strong></p>
<ol>
<li><p><strong>使用信号量：</strong></p>
<ul>
<li><p>通过 sem_init() 初始化信号量为 0。</p>
</li>
<li><p>线程 A 执行完任务后调用 sem_post() 释放信号量，通知线程 B 可以继续执行。</p>
</li>
<li><p>线程 B 调用 sem_wait() 等待信号量被释放，然后继续执行。</p>
</li>
</ul>
</li>
<li><p><strong>使用条件变量和互斥锁结合的方式：</strong></p>
<ul>
<li>创建互斥锁和条件变量，互斥锁用于保护共享数据的访问；条件变量作为共享状态变量，用于阻塞一个或多个线程，直到接收到其他线程的通知。</li>
<li>线程 A 执行完其任务后，修改共享状态变量，通知等待线程任务已完成。</li>
<li>线程 B 等待线程 A 完成任务，收到通知后继续执行。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// For sleep function</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;  <span class="comment">// 信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 任务A执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 释放信号量</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 等待信号量</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">    <span class="comment">// 2. 任务B执行</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化信号量，初始值为0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem);  <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 互斥锁</span></span><br><span class="line">std::condition_variable cv;  <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> taskA_completed = <span class="literal">false</span>;  <span class="comment">// 任务A是否完成的标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 任务A执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 修改标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        taskA_completed = <span class="literal">true</span>;  <span class="comment">// 设置任务A完成的标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// cv.notify_one()/cv.notify_all() 通知等待线程任务A已完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检测标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> taskA_completed; &#125;); <span class="comment">// cv.wait() 等待任务A完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 任务B执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26、进程的五种状态分别是？"><a href="#26、进程的五种状态分别是？" class="headerlink" title="26、进程的五种状态分别是？"></a>26、进程的五种状态分别是？</h3><p>进程一共有 5 种状态，分别是<strong>创建、就绪、运行、阻塞、终止</strong>。</p>
<ul>
<li>运行状态就是进程正在 CPU 上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 即可运行。</li>
<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 I&#x2F;O 完成。即使 CPU 空闲，该进程也不能运行。</li>
</ul>
<h3 id="【-】27、进程不同状态转换的关系？"><a href="#【-】27、进程不同状态转换的关系？" class="headerlink" title="【*】27、进程不同状态转换的关系？"></a>【*】27、进程不同状态转换的关系？</h3><p>进程在不同状态之间的转换过程如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406131948229.png" alt="在这里插入图片描述"></p>
<h3 id="28、孤儿进程和僵尸进程是什么，怎么处理？"><a href="#28、孤儿进程和僵尸进程是什么，怎么处理？" class="headerlink" title="28、孤儿进程和僵尸进程是什么，怎么处理？"></a>28、孤儿进程和僵尸进程是什么，怎么处理？</h3><p>（1）<strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程号为<code>1</code>）所收养，并由 <code>init</code> 进程对它们完成状态收集工作。</p>
<p>（2）<strong>僵尸进程</strong>：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么<strong>子进程的进程描述符</strong>仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>（3）<strong>解决方案</strong>：</p>
<ul>
<li><p><strong>1）kill 杀死元凶父进程（一般不用）</strong></p>
</li>
<li><p><strong>2）通过信号机制，在处理函数中调用 wait，回收资源</strong></p>
<p>通过信号机制，子进程退出时向父进程发送 <code>SIGCHLD</code> 信号，父进程调用 <code>signal(SIGCHLD, sig_child)</code> 去处理 <code>SIGCHLD</code> 信号，在信号处理函数 <code>sig_child()</code> 中调用 <code>wait</code> 进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，过程中父进程可以继续做其他工作，不用去阻塞等待。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="comment">// 使用循环回收所有已经结束的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; terminated&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, sig_child); <span class="comment">// 设置信号处理程序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟子进程工作</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 子进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程可以继续做其他工作，不会被阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process doing work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、两个进程的内核空间是共享的吗？"><a href="#29、两个进程的内核空间是共享的吗？" class="headerlink" title="29、两个进程的内核空间是共享的吗？"></a>29、两个进程的内核空间是共享的吗？</h3><p>在大多数现代操作系统中，包括 Linux 和 Windows，内核空间是在所有进程之间共享的。这意味着内核空间中的代码和数据结构对所有进程来说都是相同的，并且在任何时候都位于相同的物理内存位置。</p>
<h3 id="30、进程间的通信包括哪些方式？"><a href="#30、进程间的通信包括哪些方式？" class="headerlink" title="30、进程间的通信包括哪些方式？"></a>30、进程间的通信包括哪些方式？</h3><ol>
<li><p><strong>管道</strong>，半双工的通信方式，通常用于具有亲缘关系的进程之间的通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道</strong>，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;&#x27;hi midori&#x27; from writer(fifo)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    fd = open(FIFO_FILE, O_WRONLY);  <span class="comment">// 打开命名管道</span></span><br><span class="line">    write(fd, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);      <span class="comment">// 向命名管道写入数据</span></span><br><span class="line">    close(fd);      <span class="comment">// 关闭命名管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息队列</strong>，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> msg_type;</span><br><span class="line">    <span class="type">char</span> msg_text[MSG_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列或获取现有消息队列的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列接收消息</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对消息队列进行控制操作，如获取信息、修改权限、删除消息队列等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号量</strong>，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
</li>
<li><p><strong>共享内存</strong>：</p>
<ul>
<li><p><strong>效率最高</strong>，允许多个进程共享同一块内存区域，没有数据复制的开销，进程可以直接读写共享内存中的数据。</p>
</li>
<li><p>不过，1）需要额外的同步机制（如信号量或互斥锁）来防止并发访问问题；2）同时，共享内存的数据一旦被破坏，所有依赖于该数据的进程都会受到影响，容错性较差；3）需要注意临界变量的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建共享内存段或获取现有共享内存段的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存连接到当前进程的地址空间，返回共享内存段的首地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存段从当前进程的地址空间中分离，即解除映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对共享内存段进行控制操作，如获取信息、修改权限、删除共享内存段等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套接字</strong>，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
</li>
</ol>
<h3 id="【-看视频重新总结-】31、进程调度算法"><a href="#【-看视频重新总结-】31、进程调度算法" class="headerlink" title="【&#x3D;看视频重新总结&#x3D;】31、进程调度算法"></a>【&#x3D;看视频重新总结&#x3D;】31、进程调度算法</h3><h3 id="32、进程同步的方式？"><a href="#32、进程同步的方式？" class="headerlink" title="32、进程同步的方式？"></a>32、进程同步的方式？</h3><ul>
<li><strong>互斥锁</strong>，一种用于保护共享资源的同步机制，确保同一时间只有一个进程可以访问共享资源。</li>
<li><strong>信号量</strong>，用于控制对共享资源的访问。</li>
<li><strong>条件变量</strong>，允许进程在某个条件不满足的情况下阻塞自己，直到有其他进程通知条件满足。</li>
<li><strong>共享内存</strong>，允许多个进程共享一块内存区域，以便快速交换数据。</li>
<li><strong>消息队列</strong>，允许进程通过发送和接收消息进行通信。</li>
</ul>
<h3 id="33、信号量和互斥锁解决父子线程同时阻塞的区别？"><a href="#33、信号量和互斥锁解决父子线程同时阻塞的区别？" class="headerlink" title="33、信号量和互斥锁解决父子线程同时阻塞的区别？"></a>33、信号量和互斥锁解决父子线程同时阻塞的区别？</h3><p>假设有一个场景，其中父线程和子线程需要按特定顺序访问某个资源（例如，父线程需要等待子线程完成某个任务后才能继续执行）。</p>
<ul>
<li><strong>使用互斥锁</strong>：如果使用互斥锁，需要<strong>配合条件变量</strong>来实现这种顺序控制。<strong>互斥锁本身只能保证互斥，不能控制线程之间的执行顺序</strong>。父线程需要在条件变量上等待一个特定条件（通常由子线程设置）。</li>
<li><strong>使用信号量</strong>：信号量可以更直接地控制执行顺序。父线程等待子线程释放某个信号后才能继续执行，这样就控制了对资源的访问顺序。</li>
</ul>
<h3 id="34、windows-下-thread-create-会有什么问题？"><a href="#34、windows-下-thread-create-会有什么问题？" class="headerlink" title="34、windows 下 thread_create 会有什么问题？"></a>34、windows 下 thread_create 会有什么问题？</h3><p>？</p>
<h3 id="35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT"><a href="#35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT" class="headerlink" title="35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?"></a>35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?</h3><p><strong>SIGALRM</strong>：时钟定时器超时信号，通常用于定时操作。</p>
<p><strong>SIGSEGV</strong>：非法内存访问信号，通常由无效的指针或越界访问引发。</p>
<p><strong>SIGINT</strong>：中断信号，通常由用户通过 Ctrl+C 发出，用于中断程序执行。</p>
<h3 id="36、Ctrl-C-后发生了什么？"><a href="#36、Ctrl-C-后发生了什么？" class="headerlink" title="36、Ctrl+C 后发生了什么？"></a>36、Ctrl+C 后发生了什么？</h3><p>按下 Ctrl+C 后，会向前台运行的进程发送 SIGINT 信号。这个信号通常用于中断和终止正在运行的程序。如果程序捕获并处理了 SIGINT 信号，它可以执行清理操作或选择忽略信号；否则，默认行为是终止程序。</p>
<h3 id="37、sigaction-可以干哪些事情？解释一下屏蔽集？"><a href="#37、sigaction-可以干哪些事情？解释一下屏蔽集？" class="headerlink" title="37、sigaction 可以干哪些事情？解释一下屏蔽集？"></a>37、sigaction 可以干哪些事情？解释一下屏蔽集？</h3><p><code>sigaction</code> 是一个用于设置和检测信号处理方式的系统调用，主要有以下功能：</p>
<ol>
<li><strong>设置信号处理函数</strong>：可以用于指定一个函数，用来处理特定信号发生时的行为。</li>
<li><strong>指定信号的处理方式</strong>：可以指定信号的处理方式，比如忽略信号、执行默认操作、或者调用指定的处理函数。</li>
<li><strong>检查和修改信号的屏蔽集</strong>：可以检查当前对信号的屏蔽状态，也可以修改进程对信号的屏蔽集。</li>
</ol>
<p><strong>屏蔽集</strong> 是一个用来管理信号处理的机制，它决定了<strong>在特定时间点一个进程可以接收哪些信号</strong>。当信号被屏蔽时，进程在收到该信号时不会立即处理，而是被加入到<strong>未决信号集</strong>中，直到信号被解除屏蔽后才会处理。屏蔽集可以通过 <code>sigprocmask</code> 系统调用来设置和修改。</p>
<h3 id="38、线程崩溃，进程一定会崩溃吗？"><a href="#38、线程崩溃，进程一定会崩溃吗？" class="headerlink" title="38、线程崩溃，进程一定会崩溃吗？"></a>38、线程崩溃，进程一定会崩溃吗？</h3><p>一般来说，如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p>
<h2 id="二、内存模型-虚拟内存"><a href="#二、内存模型-虚拟内存" class="headerlink" title="二、内存模型&#x2F;虚拟内存"></a>二、内存模型&#x2F;虚拟内存</h2><h3 id="39、什么是虚拟内存？"><a href="#39、什么是虚拟内存？" class="headerlink" title="39、什么是虚拟内存？"></a>39、什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301943905.png" alt="img" style="zoom: 67%;" />

<h3 id="40、为什么操作系统要使用虚拟内存？"><a href="#40、为什么操作系统要使用虚拟内存？" class="headerlink" title="40、为什么操作系统要使用虚拟内存？"></a>40、为什么操作系统要使用虚拟内存？</h3><ol>
<li>第一，虚拟内存可以<strong>使得进程的运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统<strong>提供了更好的安全性</strong>。</li>
</ol>
<h3 id="41、虚拟内存有没有大小的限制？"><a href="#41、虚拟内存有没有大小的限制？" class="headerlink" title="41、虚拟内存有没有大小的限制？"></a>41、虚拟内存有没有大小的限制？</h3><ol>
<li><p>虚拟内存的大小<strong>受到地址线的限制</strong>：</p>
<ul>
<li><p><code>32</code>位系统下虚拟内存空间的大小为2^32^字节（约4GB）；</p>
</li>
<li><p><code>64</code>位系统下虚拟内存空间的大小为2^64^字节。</p>
</li>
</ul>
</li>
<li><p>另外，操作系统还可以通过配置来限制每个进程能够使用的虚拟内存大小。</p>
</li>
</ol>
<h3 id="42、虚拟内存中分页算法是为了解决什么样的问题？"><a href="#42、虚拟内存中分页算法是为了解决什么样的问题？" class="headerlink" title="42、虚拟内存中分页算法是为了解决什么样的问题？"></a>42、虚拟内存中分页算法是为了解决什么样的问题？</h3><p>虚拟内存中的分页算法是为了解决<strong>连续长内存分配时物理内存不足</strong>的问题。它通过<strong>将内存分成固定大小的页面（page），并将页面映射到物理内存或者存储在磁盘上的页面文件</strong>中，来提供更大的地址空间。</p>
<h3 id="43、虚拟内存的内存模型如何？"><a href="#43、虚拟内存的内存模型如何？" class="headerlink" title="43、虚拟内存的内存模型如何？"></a>43、虚拟内存的内存模型如何？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<code>.text</code>段，<code>.rodata</code>段，<code>.data</code>段，<code>.bss</code>段，堆，内存映射区，栈，内核空间。其中，各项主要内容如下：</p>
<p>（1）<code>.text</code>段 ：主要存在程序编译后的机器指令；</p>
<p>（2）<code>.rodata</code>段 ：主要存放程序中的各种只读变量；</p>
<p>（3）<code>.data</code>段：主要存放指定了初始值的全局变量和静态变量；</p>
<p>（4）<code>.bss</code>段：主要存放没有指定初始值的全局变量和静态变量，这些未初始化的全局变量被加载进内存之后会被初始化为 0 值；</p>
<p>（5）堆：由程序员进行动态分配，如调用 malloc 或 new；</p>
<p>（6）文件映射与匿名映射区：存放动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区；</p>
<p>（7）栈：由编译器自动分配释放，存放调用函数过程中使用到的局部变量和函数参数等；</p>
<p>（8）内核空间：存放操作系统的一些内核数据和代码。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ffb6e1727e2289f142f6a2a6291cd68c.png" alt="image.png" style="zoom: 50%;" />

<img src="https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png" alt="image.png" style="zoom: 33%;" />

<h3 id="44、为什么要区分代码段和数据段？"><a href="#44、为什么要区分代码段和数据段？" class="headerlink" title="44、为什么要区分代码段和数据段？"></a>44、为什么要区分代码段和数据段？</h3><ul>
<li><strong>访问权限控制</strong>：<strong>代码段通常设置为只读</strong>，以防止程序代码被意外或恶意修改，这可能导致程序行为不正确或系统安全受到威胁。<strong>数据段则通常需要读写权限</strong>，因为程序在运行时需要修改数据。</li>
<li><strong>分页策略</strong>：代码段和数据段可能会<strong>采用不同的分页和交换策略</strong>。例如，代码页可能较少交换出内存，因为它们被频繁访问；而数据段的某些部分<strong>如果使用不频繁可以被交换出去</strong>以节约资源。</li>
</ul>
<h3 id="45、堆和栈有什么样的区别？"><a href="#45、堆和栈有什么样的区别？" class="headerlink" title="45、堆和栈有什么样的区别？"></a>45、堆和栈有什么样的区别？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301519980.png" alt="image-20240630151957779"></p>
<h3 id="46、什么时候用栈，什么时候用堆？"><a href="#46、什么时候用栈，什么时候用堆？" class="headerlink" title="46、什么时候用栈，什么时候用堆？"></a>46、什么时候用栈，什么时候用堆？</h3><ol>
<li><p>与堆相比，栈不会导致内存碎片，分配效率高。<strong>函数返回地址，函数的局部变量，调用参数以及使用的寄存器</strong>等信息都采取栈的形式存放，如果<strong>少量数据需要频繁的操作</strong>，那么在程序中动态申请少量栈内存会获得很好的性能提升。</p>
</li>
<li><p>堆可以申请的内存大很多，与堆相比，栈的使用没那么灵活，如果<strong>分配大量的内存空间</strong>，推荐使用堆内存，保存着程序运行时使用 new 和 malloc 等动态分配的内存。</p>
</li>
</ol>
<h3 id="47、不同段上的对象的生命周期是怎样的？"><a href="#47、不同段上的对象的生命周期是怎样的？" class="headerlink" title="47、不同段上的对象的生命周期是怎样的？"></a>47、不同段上的对象的生命周期是怎样的？</h3><ol>
<li><p><code>.data/.bss</code> 段的生命周期<strong>和程序的生命周期一致</strong>，在程序加载到内存时被分配，程序结束时被销毁；</p>
</li>
<li><p><code>堆</code>上的对象<strong>由程序员进行动态分配</strong>；</p>
</li>
<li><p><code>栈</code>上的对象由编译器进行分配，当<strong>离开作用域范围时被编译器销毁</strong>。</p>
</li>
</ol>
<h3 id="48、如何-让对象只能存在于栈-堆中？"><a href="#48、如何-让对象只能存在于栈-堆中？" class="headerlink" title="48、如何 让对象只能存在于栈&#x2F;堆中？"></a>48、如何 让对象只能存在于栈&#x2F;堆中？</h3><ol>
<li>如果<strong>将<code>operator new</code>设置为私有的</strong>，此时尝试在堆上分配内存失败，对象就会<strong>存在于栈中</strong>。</li>
<li>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果<strong>将析构函数设置为私有的</strong>，在栈上分配内存失败，对象就会<strong>存在于堆中</strong>。</li>
</ol>
<h3 id="49、栈的速度为什么比堆上的要快？"><a href="#49、栈的速度为什么比堆上的要快？" class="headerlink" title="49、栈的速度为什么比堆上的要快？"></a>49、<strong>栈的速度为什么比堆上的要快？</strong></h3><p>栈的读取速度比堆上的要快，主要是由于以下几个原因：</p>
<ol>
<li><strong>数据结构的特点</strong>：栈是一种线性数据结构，其操作是基于栈顶的，因此可以通过简单的指针操作来读取栈上的数据。相比之下，堆是一种树形数据结构，要读取堆上的数据可能需要进行指针的跳转和内存的查找操作，因此相对更为复杂和耗时。</li>
<li><strong>内存布局的连续性</strong>：栈上的内存分配是连续的，数据项之间存储的地址是相邻的，这使得栈上的数据读取更为高效，因为可以通过栈指针进行连续的内存读取操作。而堆上的内存分配是动态的，可能是分散的，需要通过指针跳转来访问不同的内存块，导致读取速度较慢。 </li>
<li><strong>硬件优化</strong>：由于栈的读取操作频繁且简单，因此处理器和编译器通常会对栈上的操作进行优化，例如采用特定的指令集或硬件机制来提高栈操作的执行效率。相比之下，堆上的内存操作较为复杂，难以进行同样程度的优化。</li>
</ol>
<h3 id="50、栈何时会溢出？"><a href="#50、栈何时会溢出？" class="headerlink" title="50、栈何时会溢出？"></a>50、<strong>栈何时会溢出</strong>？</h3><ol>
<li><p>递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出。</p>
</li>
<li><p>局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出。</p>
</li>
<li><p>大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出。</p>
</li>
</ol>
<blockquote>
<p>在 C&#x2F;C++ 中，可以使用编译器选项 <code>-Wl,--stack,&lt;size&gt;</code> 来设置栈的大小。</p>
</blockquote>
<h3 id="51、new-和-malloc-的区别？"><a href="#51、new-和-malloc-的区别？" class="headerlink" title="51、new 和 malloc 的区别？"></a>51、new 和 malloc 的区别？</h3><p>主要包含以下区别：</p>
<ol>
<li>malloc 是 C 中的函数，但可以同时在 C&#x2F;C++ 中使用；new 是 C++ 特有的操作符，只能在 C++ 中使用；</li>
<li>malloc 在使用时需要指定分配内存的大小，如 <code>malloc(sizeof(int))</code>，但 new 的使用则比较简洁，如 <code>new int</code>；</li>
<li>malloc 分配的内存是未定义的，而 new 在分配内存时还会调用构造函数进行初始化；</li>
<li>malloc 返回的是 void * 类型的指针，需要进行强制类型转换以得到需要的指针类型，而 new 会自动转换为响应的指针类型；</li>
<li>malloc 调用 free 进行释放， new 调用 delete 进行释放。</li>
<li>若内存分配失败，malloc 调用会返回 nullptr，而 new 调用会返回 <code>std::bad_alloc</code>。</li>
</ol>
<blockquote>
<p>注意！<strong>malloc() 是库函数，不是系统调用</strong>，只是它内部调用了系统调用。</p>
</blockquote>
<h3 id="52、既然有了-malloc-free，为什么还需要-new-delete-呢？"><a href="#52、既然有了-malloc-free，为什么还需要-new-delete-呢？" class="headerlink" title="52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？"></a>52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？</h3><ul>
<li>malloc&#x2F;free 和 new&#x2F;delete 都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc&#x2F;free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc&#x2F;free，所以 new&#x2F;delete 是必不可少的。</li>
</ul>
<h3 id="【-】53、malloc-函数的底层实现是什么？"><a href="#【-】53、malloc-函数的底层实现是什么？" class="headerlink" title="【*】53、malloc() 函数的底层实现是什么？"></a>【*】53、malloc() 函数的底层实现是什么？</h3><ol>
<li>当开辟的空间<strong>小于 128kb</strong> 时，调用 <code>brk()</code> 函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针 <code>_enddata</code>，即堆区的末尾地址，将「堆顶」指针往高地址推。</li>
<li>当开辟的空间<strong>大于 128kb</strong>  时，系统调用 <code>mmap()</code> 在堆和栈之间找一块空闲内存分配.</li>
<li><code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节。因此，free() 函数只传入一个内存地址却能知道要释放多大的内存。而由于堆中的内存是成块分配的，与内存对齐有关，在 64 位系统中，内存对齐为 16 字节，因此<strong>实际分配的内存大小还要考虑 8 字节的管理内存和内存对齐</strong>。</li>
</ol>
<blockquote>
<p>brk() 是将「堆顶」指针向高地址移动，获得新的内存空间；mmap() 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【-】54、mmap-的原理"><a href="#【-】54、mmap-的原理" class="headerlink" title="【*】54、mmap() 的原理"></a>【*】54、mmap() 的原理</h3><h3 id="55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"><a href="#55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？" class="headerlink" title="55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"></a>55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？</h3><p>（1）<strong>free(p+50) 是否有效？</strong></p>
<ul>
<li><strong>不可以</strong>。<code>free()</code> 函数要求传入的指针必须是由 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 返回的指针的起始地址。如果传入的是偏移后的地址（如 <code>p + 50</code>），会导致未定义行为。<code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节， <code>free()</code> 需要据此来释放正确的内存区域，而偏移后的指针不包含这些信息。</li>
</ul>
<p>（2）<strong>将内存扩充到 200 字节应该如何操作？</strong></p>
<ul>
<li><p>在 C 语言中，<code>malloc</code> 分配的内存是固定大小的，一旦分配完成后，大小不能直接更改。要将内存扩充到 200 字节，可以使用 <code>realloc</code> 函数。<code>realloc</code> 函数可以重新分配先前通过 <code>malloc</code> 或 <code>calloc</code> 分配的内存块，将其大小调整为新的字节数。</p>
</li>
<li><p>例如，要将 <code>p</code> 指向的内存块扩充到 200 字节，可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = q; <span class="comment">// 更新 p，因为 realloc 可能会返回新的地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>realloc(p, 200)</code> 将尝试将原始分配的内存块大小调整为 200 字节。如果内存块成功扩展，<code>realloc</code> 返回一个指向新分配区域的指针，并且原来的 <code>p</code> 指针仍然有效（或者更新为新的地址）。如果失败，返回 <code>NULL</code>，并且原来的 <code>p</code> 指针仍然有效。</p>
</li>
</ul>
<h3 id="56、malloc、realloc、calloc-的区别"><a href="#56、malloc、realloc、calloc-的区别" class="headerlink" title="56、malloc、realloc、calloc 的区别"></a>56、malloc、realloc、calloc 的区别</h3><ol>
<li><code>malloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>申请 20 个 int 类型的空间。</p>
<ol start="2">
<li><code>calloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc 申请的空间的值是随机初始化的，calloc 申请的空间的值是初始化为0的；</p>
<ol start="3">
<li><code>realloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<h3 id="57、对于-malloc-分配的内存，调用-free-后立即释放吗？"><a href="#57、对于-malloc-分配的内存，调用-free-后立即释放吗？" class="headerlink" title="57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？"></a>57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？</h3><p>在使用 <code>brk()</code> 或 <code>sbrk()</code> 分配的情况下，这块内存并不会立即返还给操作系统，而是标记为<strong>可再利用状态</strong>，并被 <code>ptmalloc</code> 使用双链表保存起来。当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时 <code>ptmalloc</code> 也会尝试对小块内存进行合并，避免过多的内存碎片。如果释放的是堆末端的内存，程序的断点可能会被回退，从而实际上将内存返还给操作系统。</p>
<p>而对于使用 <code>mmap()</code> 分配的较大内存块，在调用 <code>free()</code> 后通常会通过 <code>munmap()</code> 立即返还给操作系统。</p>
<h3 id="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？"></a>58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？</h3><p>因为向操作系统申请内存需要进行系统调用，而执行系统调用会在内核态和用户态之间切换，耗费不少时间，如果都用 mmap 来分配内存，等于每次都要执行系统调用。此外，mmap 分配的内存每次释放的时候，都会归还给操作系统。由于每次  mmap 分配的虚拟地址都是缺页状态的，在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<p>也就是说，<strong>频繁通过 mmap 分配的内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次再申请内存的时候，就直接从内存池取出对应的内存块，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。</p>
<h3 id="59、kmalloc-和用户态的-malloc-有什么区别。"><a href="#59、kmalloc-和用户态的-malloc-有什么区别。" class="headerlink" title="59、kmalloc() 和用户态的 malloc() 有什么区别。"></a>59、kmalloc() 和用户态的 malloc() 有什么区别。</h3><ul>
<li><code>kmalloc()</code> 是在<strong>内核空间</strong>中使用的内存分配函数，主要用于为内核模块或驱动程序分配内存，直接从操作系统的<strong>内核内存池</strong>中分配内存，这部分内存通常是预先保留给内核的，不会被用户空间的应用程序直接访问。</li>
<li><code>malloc()</code> 是在<strong>用户空间</strong>中使用的内存分配函数，用于应用程序分配内存，分配的内存来自于用户空间的堆区，这部分内存是由操作系统管理，供所有用户程序共享使用。</li>
</ul>
<h3 id="60、在已申请的内存中构造对象如何实现？"><a href="#60、在已申请的内存中构造对象如何实现？" class="headerlink" title="60、在已申请的内存中构造对象如何实现？"></a>60、在已申请的内存中构造对象如何实现？</h3><p>使用<code>placement new</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在buffer指定的地址上构造MyClass对象</span></span><br><span class="line">MyClass* pMyClass = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动调用析构函数</span></span><br><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造和析构</strong>：使用 placement new 构造对象后，必须手动调用该对象的析构函数来确保正确的资源释放。因为普通的 delete 操作符会尝试释放内存，这在使用 placement new 时是不适用的。</li>
<li><strong>对齐要求</strong>：需要确保传递给 placement new 的内存地址满足对象的对齐要求。</li>
</ul>
<h3 id="61、new-、operator-new-和-placement-new-区别"><a href="#61、new-、operator-new-和-placement-new-区别" class="headerlink" title="61、new 、operator new 和 placement new 区别"></a>61、new 、operator new 和 placement new 区别</h3><p>（1）<code>new</code>：<strong>不能被重载</strong>，其行为总是一致的。它<strong>先调用 operator new 分配内存，然后调用构造函数初始化那段内存</strong>。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载 operator new，而不是 new。<strong>如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。</strong></p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。****同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：<strong>只是 operator new 重载的一个标准、全局的版本</strong>。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h3 id="62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？"><a href="#62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？" class="headerlink" title="62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？"></a>62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？</h3><ul>
<li><strong>在分配内存时</strong>：<code>new</code> 和 <code>new[]</code> 操作符在堆上分配内存，并返回指向已分配内存的指针。但是，这两个操作符在内部处理不同。<strong>在分配数组时，new[] 操作符通常会分配额外的内存来存储数组的大小，以便在删除时正确调用每个元素的析构函数（如果是对象数组）</strong>。</li>
<li><strong>在释放内存时</strong>：<code>delete</code> 和 <code>delete[]</code> 操作符通过不同的机制释放内存。<code>delete</code> 释放单个对象，并调用该对象的析构函数。<code>delete[]</code> 则释放一个数组，调用数组中每个元素的析构函数，并释放分配的内存。</li>
</ul>
<p>简而言之，编译器本身并不会通过指针变量来区分其指向的是单个元素还是数组，而是通过我们使用的 <code>delete</code> 或 <code>delete[]</code> 关键字来决定如何处理指针指向的内存。</p>
<h3 id="【-】63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？"><a href="#【-】63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？" class="headerlink" title="【*】63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？"></a>【*】63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？</h3><p>频繁调用 <code>new</code>&#x2F;<code>malloc</code> 和 <code>delete</code>&#x2F;<code>free</code> 可能导致内存分配和释放的开销增加，从而影响系统性能。针对这种情况，可以考虑以下优化策略：</p>
<ol>
<li><strong>内存池管理</strong>：实现自定义的内存池，预先分配一定大小的内存块，而不是每次调用 <code>new</code>&#x2F;<code>malloc</code> 时都向系统请求内存。这样可以减少系统调用次数和内存碎片化。内存池可以是固定大小的块，也可以是根据需要动态增长或缩减的块。它们可以通过链表或者数组来管理。</li>
<li><strong>重用机制</strong>：尽可能重用已分配的内存块。在需要释放内存时，不立即释放，而是放入一个空闲链表或者空闲对象池中，以便下次分配时能够快速重用。对于频繁分配相同大小的内存，可以采用内存池的方式进行管理，避免反复请求和释放系统内存。</li>
<li><strong>内存分配策略优化</strong>：对于需要频繁分配和释放的小对象，可以考虑使用更高效的分配策略，如 <code>std::allocator</code> 或者专门优化的内存分配器（如 tcmalloc 或 jemalloc）。这些分配器通常比标准库的 <code>malloc</code> 和 <code>free</code> 实现更加高效，能够降低内存碎片化和系统调用次数。</li>
<li><strong>内存分配的时机和位置</strong>：在程序设计阶段，合理规划和设计内存的分配和释放时机，尽量避免频繁的动态内存分配和释放。可以考虑在初始化阶段预分配一部分内存，减少后续的动态内存操作频率。</li>
</ol>
<h3 id="64、内存分配的过程是怎样的？"><a href="#64、内存分配的过程是怎样的？" class="headerlink" title="64、内存分配的过程是怎样的？"></a>64、内存分配的过程是怎样的？</h3><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。当<strong>应用程序第一次读写这块虚拟内存</strong>时，CPU在访问时会发现这个虚拟内存没有映射到物理内存， 就会产生<strong>缺页中断</strong>，进程从用户态切换到内核态，通过缺页中断的处理函数将虚拟地址映射到一段空闲的物理内存上。</p>
<h3 id="65、内存紧张-没有空闲物理内存时有哪些操作？"><a href="#65、内存紧张-没有空闲物理内存时有哪些操作？" class="headerlink" title="65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？"></a>65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？</h3><p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，内核触发 <strong>OOM （Out of Memory）机制</strong>。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406302002710.png" alt="img"></p>
<h3 id="66、哪些内存可以被回收？"><a href="#66、哪些内存可以被回收？" class="headerlink" title="66、哪些内存可以被回收？"></a>66、哪些内存可以被回收？</h3><p>主要有<strong>文件页和匿名页</strong>两类内存可以被回收。</p>
<ul>
<li><strong>文件页</strong>（File-backed  Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。根据是否被修改并写入磁盘分为干净页和脏页，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着活跃内存页链表和不活跃内存页链表两个双向链表，越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<blockquote>
<ul>
<li><strong>active_list</strong> 是活跃内存页链表，存放最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，存放很少被访问（非活跃）的内存页。</li>
</ul>
</blockquote>
<h3 id="67、针对回收内存页导致的性能影响，有哪些解决方式？"><a href="#67、针对回收内存页导致的性能影响，有哪些解决方式？" class="headerlink" title="67、针对回收内存页导致的性能影响，有哪些解决方式？"></a>67、针对回收内存页导致的性能影响，有哪些解决方式？</h3><ol>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，调整文件页和匿名页的回收倾向，尽量倾向于回收文件页；</strong></p>
<p>从文件页和匿名页的回收操作来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页回收是不会发生磁盘 I&#x2F;O 的，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p>
<blockquote>
<p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。其数值范围是 0-100，数值越大，越倾向于回收匿名页；数值越小，越倾向于回收文件页。</p>
<p>一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p>
</blockquote>
</li>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes，调整 kswapd 内核线程异步回收内存的时机；</strong></p>
<blockquote>
<p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。针对这个问题，解决的办法是通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</p>
<p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</p>
</blockquote>
</li>
<li><p><strong>设置  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode，调整 NUMA 架构下内存回收策略，建议设置为  0，这样在回收本地内存之前，会在其他 Node 寻找空闲内存，从而避免在系统还有很多空闲内存的情况下，因本地 Node  的本地内存不足，发生频繁直接内存回收导致性能下降的问题。</strong></p>
</li>
</ol>
<h3 id="68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？"><a href="#68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？" class="headerlink" title="68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？"></a>68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</h3><ul>
<li>在 <code>32</code> 位操作系统，因为进程理论上最大能申请 <code>3GB</code> 大小的虚拟内存，所以直接申请 <code>8GB</code> 内存，会申请失败。</li>
<li>在 <code>64</code> 位操作系统，因为进程理论上最大能申请 <code>128TB</code> 大小的虚拟内存，即使物理内存只有 <code>4GB</code>，申请 <code>8GB</code> 内存也是没问题，因为申请的内存是虚拟内存。<strong>如果这块虚拟内存被访问了</strong>，要看系统有没有 Swap 分区：<ul>
<li>如果没有 <code>Swap</code> 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 <code>OOM</code>（内存溢出）；</li>
<li>如果有 <code>Swap</code> 分区，即使物理内存只有 <code>4GB</code>，程序也能正常使用 <code>8GB</code> 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<h3 id="【-】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"><a href="#【-】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？" class="headerlink" title="【*】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"></a>【*】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？</h3><ol>
<li><p><strong>进栈过程</strong></p>
<ol>
<li>将当前函数的返回地址和栈帧指针 ebp 压入栈中，<strong>保存调用者的环境</strong>；</li>
<li>将栈指针 esp 的值赋给栈帧指针 ebp，<strong>设置被调用函数的栈帧</strong>；</li>
<li>将栈指针（<code>esp</code>）的值赋给栈帧指针（<code>ebp</code>），形成新的栈帧；</li>
<li>为被调用函数的局部变量和临时变量预留空间，调整栈指针（<code>esp</code>）。</li>
<li>将实参按照调用约定的顺序压入栈中。</li>
</ol>
</li>
<li><p><strong>执行函数</strong></p>
<ul>
<li><p>被调用函数开始执行，其局部变量和临时变量使用新栈帧中的空间；</p>
</li>
<li><p>函数执行过程中，<code>ebp</code> 用于访问局部变量，<code>esp</code> 随着栈操作不断变化。</p>
</li>
</ul>
</li>
<li><p><strong>退栈过程</strong></p>
<ol>
<li>函数执行完毕后，将栈指针（<code>esp</code>）恢复到调用函数的栈帧起始位置，通常是通过<code>mov esp, ebp</code>实现；</li>
<li>将调用者的栈帧指针（<code>ebp</code>）恢复，通常是通过<code>pop ebp</code>实现；</li>
<li>从栈中弹出返回地址，通常是通过<code>ret</code>指令实现，<code>ret</code>指令会弹出栈顶的地址到程序计数器（<code>eip</code>），从而跳转回调用函数的下一条指令。</li>
</ol>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_main:</span><br><span class="line">    push ebp            ; 保存调用者的栈帧指针</span><br><span class="line">    mov ebp, esp        ; 设置新的栈帧指针</span><br><span class="line">    sub esp, 8          ; 为局部变量预留空间</span><br><span class="line">    push 2              ; 将实参2压入栈</span><br><span class="line">    push 1              ; 将实参1压入栈</span><br><span class="line">    call _foo           ; 调用foo函数</span><br><span class="line">    add esp, 8          ; 调用后清理参数空间</span><br><span class="line">    mov esp, ebp        ; 恢复调用者的栈帧指针</span><br><span class="line">    pop ebp             ; 弹出调用者的栈帧指针</span><br><span class="line">    ret                 ; 返回调用者</span><br><span class="line"></span><br><span class="line">_foo:</span><br><span class="line">    push ebp            ; 保存foo函数的栈帧指针</span><br><span class="line">    mov ebp, esp        ; 设置新的栈帧指针</span><br><span class="line">    sub esp, 4          ; 为局部变量预留空间</span><br><span class="line">    mov eax, [ebp+8]    ; 将第一个参数加载到eax</span><br><span class="line">    mov edx, [ebp+12]   ; 将第二个参数加载到edx</span><br><span class="line">    add eax, edx        ; 计算a + b</span><br><span class="line">    mov [ebp-4], eax    ; 将结果保存到局部变量c</span><br><span class="line">    mov esp, ebp        ; 恢复foo函数的栈帧指针</span><br><span class="line">    pop ebp             ; 弹出foo函数的栈帧指针</span><br><span class="line">    ret                 ; 返回调用者</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主函数调用子函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556491.png" alt="在这里插入图片描述"></p>
<p>子函数返回主函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556054.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="70、分段为什么会产生内存碎片的问题？"><a href="#70、分段为什么会产生内存碎片的问题？" class="headerlink" title="70、分段为什么会产生内存碎片的问题？"></a>70、分段为什么会产生内存碎片的问题？</h3><ol>
<li>当程序动态分配内存时，如果<strong>请求的内存大小比当前空闲块大，但分配的内存不是连续的</strong>，就会在已有的空闲块中留下未被利用的空间。</li>
<li>当程序释放内存时，如果<strong>释放的内存顺序不是按照申请的顺序释放</strong>，会导致内存空闲块的分布变得不连续。这样在后续再次分配内存时，可能<strong>无法利用之前释放的碎片空间，从而导致更多的碎片产生</strong>。</li>
<li>某些内存分配算法（如首次适应、最佳适应）会根据当前的空闲内存块选择最合适的块分配给请求的内存大小。如果空闲块的分布不合理或者已分配的内存块大小和释放的大小不匹配，就容易产生碎片。</li>
</ol>
<h3 id="【-】71、分段为什么会导致内存交换效率低的问题？"><a href="#【-】71、分段为什么会导致内存交换效率低的问题？" class="headerlink" title="【*】71、分段为什么会导致内存交换效率低的问题？"></a>【*】71、分段为什么会导致内存交换效率低的问题？</h3><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片时就不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。因为硬盘的访问速度要比内存慢太多了，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页（<code>Paging</code>）。</p>
<h3 id="72、Swap-分区"><a href="#72、Swap-分区" class="headerlink" title="72、Swap 分区"></a>72、Swap 分区</h3><p>Swap 就是<strong>把一块磁盘空间或者本地文件当成内存来使用</strong>，它包含<strong>换出和换入</strong>两个过程：</p>
<ul>
<li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li>
<li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</li>
</ul>
<p>Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：</p>
<ul>
<li><strong>内存不足</strong>：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。</li>
<li><strong>内存闲置</strong>：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，也是负责交换闲置内存的主要进程，它会在空闲内存低于一定水位时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</li>
</ul>
<h3 id="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h3><p>分页机制将内存划分为一个个固定大小的页面，彼此间紧密排列，因此和分段机制相比它不会产生外部内存碎片。但要注意由于内存分页机制的最小分配单位是一页，因此即使程序大小不足一页，也会至少分配一个完整的页。因此分页机制会出现内部碎片的现象。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，并暂时写在硬盘上，称为<strong>换出</strong>。一旦需要的时候，再加载进来，称为<strong>换入</strong>。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h3 id="74、页表是什么，页多大，为什么是-4KB？"><a href="#74、页表是什么，页多大，为什么是-4KB？" class="headerlink" title="74、页表是什么，页多大，为什么是 4KB？"></a>74、页表是什么，页多大，为什么是 4KB？</h3><p>页表是操作系统中用于实现虚拟内存管理的一种数据结构，它用于将虚拟地址映射到物理地址。这种机制允许计算机的操作系统为每个运行的程序提供一种看似连续的内存地址空间，即使物理内存是分散存储的。</p>
<p>在多数现代操作系统中，标准的页面大小是 <code>4KB</code>（4096字节）。Linux 会以页面为单位对内存进行管理，每次执行内存分配时都至少分配一个页面。<strong>过小的页面大小会带来较大的页表项</strong>，增加寻址时 TLB的查找速度和额外开销；<strong>过大的页面大小会浪费内存空间，造成内部碎片</strong>，降低内存的利用率；上个世纪在设计内存页大小时充分考虑了上述的两个因素，最终选择了 <code>4KB</code> 的内存页作为操作系统最常见的页大小，这个大小也就沿用至今。</p>
<h3 id="75、分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#75、分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="75、分页机制下，虚拟地址和物理地址是如何映射的？"></a>75、分页机制下，虚拟地址和物理地址是如何映射的？</h3><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的，<strong>内存管理单元</strong> （MMU）完成<strong>将虚拟地址转换成物理地址</strong>的工作。当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，<strong>进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</strong>。</p>
<p>对于一个内存地址转换，包含以下 3 个步骤：</p>
<ul>
<li>把虚拟内存地址<strong>切分</strong>成页号和偏移量；</li>
<li>根据<strong>页号</strong>，从<strong>页表</strong>里面查询对应的<strong>物理页号</strong>；</li>
<li>用物理页号<strong>加上</strong>前面的偏移量，就得到了物理内存地址。</li>
</ul>
<blockquote>
<p><strong>64 位虚拟地址格式</strong>：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位。</p>
<p><strong>32 位虚拟地址格式</strong>：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位。</p>
</blockquote>
<h3 id="76、为什么会产生多级页表？"><a href="#76、为什么会产生多级页表？" class="headerlink" title="76、为什么会产生多级页表？"></a>76、为什么会产生多级页表？</h3><p>对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 <strong>100 多万个</strong>「页表项」，并且每个页表项是占用 <strong>4 字节</strong>大小的，于是<strong>相当于每个页表需占用 4MB 大小的空间</strong>。因此把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</p>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。利用这一特性，可以<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，于是在 CPU 芯片中，加入了一个<strong>专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB</strong>（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<h3 id="77、缺页中断什么时候发生？"><a href="#77、缺页中断什么时候发生？" class="headerlink" title="77、缺页中断什么时候发生？"></a>77、缺页中断什么时候发生？</h3><ol>
<li>当<strong>程序要访问的页面不在物理内存中</strong>时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存；</li>
<li>当<strong>程序尝试进行一个违反内存规则的操作</strong>时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</li>
</ol>
<h3 id="【-】78、常见的缺页中断算法-页面置换算法有哪些？"><a href="#【-】78、常见的缺页中断算法-页面置换算法有哪些？" class="headerlink" title="【*】78、常见的缺页中断算法&#x2F;页面置换算法有哪些？"></a>【*】78、常见的缺页中断算法&#x2F;页面置换算法有哪些？</h3><ol>
<li><p>最佳页面置换算法（<em>OPT</em>）：最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
</li>
<li><p>先进先出置换算法（<em>FIFO</em>）：<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>
</li>
<li><p>最近最久未使用的置换算法（<em>LRU</em>）：发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
</li>
<li><p>时钟页面置换算法（<em>Lock</em>）：该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
</li>
<li><p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li><p>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</p>
</li>
<li><p>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。</p>
</li>
</ul>
</li>
<li><p>最不常用置换算法（<em>LFU</em>）：<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
</li>
</ol>
<h3 id="79、写时拷贝在操作系统中有哪些应用？"><a href="#79、写时拷贝在操作系统中有哪些应用？" class="headerlink" title="79、写时拷贝在操作系统中有哪些应用？"></a>79、写时拷贝在操作系统中有哪些应用？</h3><ol>
<li><strong>内存管理</strong>：<ul>
<li><strong>分页系统</strong>：在许多操作系统中，写时拷贝技术常用于内存管理。当进程执行 fork 操作创建子进程时，操作系统并不立即为子进程复制父进程的整个地址空间。相反，它让<strong>父子进程共享同一物理内存页面</strong>，<strong>只有当其中一个进程尝试修改这些共享页面时，操作系统才会复制这些页面（COW），从而实现了资源的有效利用和快速的进程创建。</strong></li>
<li><strong>虚拟内存系统</strong>：在虚拟内存系统中，写时拷贝技术可以减少不必要的数据复制，提高内存使用效率，<strong>只有在需要写入时才进行物理内存的分配和数据复制</strong>。</li>
</ul>
</li>
<li><strong>文件系统</strong>：<ul>
<li><strong>快照功能</strong>：在支持快照的文件系统（如 ZFS 或 Btrfs ）中，写时拷贝用于实现文件系统的版本控制。当文件系统状态需要保存为历史快照时，原始数据保持不变，任何对数据的修改都通过复制修改前的数据块来实现，从而快速创建快照并节省空间。</li>
</ul>
</li>
</ol>
<h2 id="三、编译程序相关"><a href="#三、编译程序相关" class="headerlink" title="三、编译程序相关"></a>三、编译程序相关</h2><h3 id="80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。"><a href="#80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。" class="headerlink" title="80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。"></a>80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。</h3><blockquote>
<p><strong>预处理、编译、汇编、链接</strong>，最后生成可执行文件。</p>
</blockquote>
<ol>
<li><p><strong>预处理阶段</strong>：对伪指令和特殊符号进行处理，将<code>.c</code>文件转为<code>.i</code>文件；</p>
<ol>
<li>处理包含指令 <code>#include</code>；</li>
<li>进行宏展开；</li>
<li>进行条件编译，如 <code>#if</code>、<code>#endif</code>、<code>#ifdef</code> 等；</li>
<li>处理 <code>#include</code> 预编译指令；</li>
<li>删除所有的注释 <code>//</code> 和 <code>/**/</code>；</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，编译器需要使用它们；</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息。</li>
</ol>
</li>
<li><p><strong>编译阶段</strong>：将编译文件转换成汇编代码，生成相应的汇编代码<code>.s</code>文件；</p>
</li>
<li><p><strong>汇编阶段</strong>：将汇编文件转化成机器码，将 <code>.s</code> 文件转为 <code>.o</code> 文件，即可重定位目标文件</p>
</li>
<li><p><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>，静态链接和动态链接的最大区别就是链接的时机不一样，静态链接是在形成可执行文件之前，动态链接是在程序执行时。</p>
<ol>
<li><strong>主要工作</strong>：<ul>
<li>符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</li>
<li>地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</li>
<li>库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</li>
</ul>
</li>
<li><strong>静态链接</strong><ul>
<li>源文件中的函数和数据预处理、编译、汇编形成目标文件，而静态链接库就是多个目标文件的集合。使用静态链接库时，链接器直接从库中复制这些函数和数据，并将它们和应用程序的其他模块组合起来，创建最终的可执行文件；链接是以目标文件为单位的，若多个函数都放在了一个目标文件中，可能很多没有的函数也会被一起链接进入了输出结果中。</li>
<li>缺点：<ul>
<li>每一个可执行文件中对所有需要的目标文件都需要一份副本，如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本</li>
<li>更新困难，每当库函数的代码发生改动，需要重新进行编译、连接形成可执行程序</li>
</ul>
</li>
<li>优点：可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度更快</li>
</ul>
</li>
<li><strong>动态链接</strong><ul>
<li>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接那样运行前就把所有程序模块都链接成一个单独的可执行文件。</li>
<li>动态链接的过程：假定程序 p1.o 和 p2.o 都依赖于库 lib.o，并且假定先运行 p1.o，系统首先会加载 p1.o，发现p1.o 用到了 lib.o，于是将 lib.o 加载到内存；当运行 p2.o 时，发现 p2.o 依赖于 lib.o，而此时 lib.o 已经加载到内存中了，因此不需要重新加载，此时会将已经存在的 lib.o 映射到 p2.o 的虚拟地址空间中，从而进行链接，形成可执行文件。</li>
<li>优点：<ul>
<li>即使多个程序依赖于同一个库，在执行时也共享同一份副本；</li>
<li>更新时只需要替换原来的目标文件，而无需将所有程序都重新链接一遍，当程序下次运行时，新版本的目标文件会自动被加载到内存中并连接起来，完成了程序的更新。</li>
</ul>
</li>
<li>缺点：由于链接过程从编译阶段推迟到了程序运行时，所以运行速度相对于静态链接更慢。</li>
<li><strong>动态链接如何实现重定位的：</strong>在形成可执行文件时，发现引用了一个外部的函数，此时会检查动态链接库，发现函数名时一个动态链接符号，此时在可执行程序就不对这个符号进行重定位，就把这个过程留到装载时在进行</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="81、在-terminal-输入-main-out-是怎么运行起来的？"><a href="#81、在-terminal-输入-main-out-是怎么运行起来的？" class="headerlink" title="81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？"></a>81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？</h3><p>在终端输入 <code>./main.out</code> 实际上是在运行名为 <code>main.out</code> 的可执行文件。这个过程涉及了操作系统的执行文件路径解析和进程创建：</p>
<ol>
<li><strong>路径解析</strong>: 终端会根据当前工作目录（或者通过绝对路径指定的位置）找到 <code>main.out</code> 可执行文件的位置。</li>
<li><strong>权限检查</strong>: 操作系统会检查当前用户是否有权限执行这个文件。如果没有权限，会提示权限不足的错误。</li>
<li><strong>进程创建</strong>: 如果权限允许，操作系统会为 <code>main.out</code> 创建一个新的进程，并加载到内存中执行。这个过程包括但不限于：<ul>
<li>将程序代码和静态数据加载到内存。</li>
<li>为程序分配堆空间和栈空间。</li>
<li>设置程序的初始状态，如传递命令行参数、环境变量等。</li>
<li>开始执行程序的 <code>main</code> 函数或者入口函数。</li>
</ul>
</li>
<li><strong>程序执行</strong>: <code>main.out</code> 开始执行，根据程序中的逻辑进行各种操作，直至程序结束或者被终止。</li>
<li><strong>退出</strong>: 程序执行完毕后，操作系统会回收分配给该程序的资源，并返回到终端或者调用者。</li>
</ol>
<h3 id="82、为什么需要有链接的过程？"><a href="#82、为什么需要有链接的过程？" class="headerlink" title="82、为什么需要有链接的过程？"></a>82、为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现<strong>符号解析、地址分配和库依赖管理</strong>等工作。</p>
<h3 id="83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？"><a href="#83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？" class="headerlink" title="83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？"></a>83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？</h3><p>在使用动态库时，链接器会将<strong>动态库的相关信息</strong>，包括动态库的<strong>名字</strong>、<strong>符号表</strong>以及<strong>可重定位信息</strong>存储到相应的<strong>可执行文件</strong>中。在可执行文件运行时，链接器会根据这些信息找到对应的动态库，从而找到 A.dll 引用的 B.dll 的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？"><a href="#84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？" class="headerlink" title="84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？"></a>84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？</h3><p>在汇编后，A.cpp 生成了 A.o 文件，B.cpp 生成了 B.o 的文件，A.o 和 B.o 文件都有着自己的符号表。在链接的过程，链接器会<strong>根据两者的符号表来做符号决议，判断是否能够找到引用的外部的符号，如果找到外部唯一的符号，就会进行重定位操作来修正这一符号的地址，从而完成调用</strong>。</p>
<h3 id="【-】85、函数调用中堆和栈的变化情况是怎样的？"><a href="#【-】85、函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="【*】85、函数调用中堆和栈的变化情况是怎样的？"></a>【*】85、函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是<strong>栈（stack）</strong>的变化，而不直接影响<strong>堆（heap）</strong>的变化。</p>
<ul>
<li><strong>入栈</strong>：<ol>
<li>参数，顺序为从右到左依次压入；</li>
<li>当前函数的返回地址；</li>
<li>局部变量；</li>
<li>栈指针 esp 赋值给基址指针 ebp，建立栈帧。</li>
</ol>
</li>
<li><strong>函数退栈</strong>：<ol>
<li>局部变量；</li>
<li>基址指针 ebp 赋值给 栈指针 esp，恢复函数调用之前的状态。</li>
</ol>
</li>
</ul>
<p>在这个过程中，函数的参数传递通常是通过栈来完成的。对于一般的函数调用，在调用函数前，调用者会将参数压入栈中；而在函数内部，被调用函数通过栈指针（ESP）来访问这些参数。在 x86 架构中，通常采用栈来传递函数参数，参数从右向左依次入栈。</p>
<h3 id="86、代码崩溃怎么解决，常见的原因是什么？"><a href="#86、代码崩溃怎么解决，常见的原因是什么？" class="headerlink" title="86、代码崩溃怎么解决，常见的原因是什么？"></a>86、代码崩溃怎么解决，常见的原因是什么？</h3><p><strong>（1）常见的崩溃原因</strong></p>
<ol>
<li><strong>访问非法内存</strong>，如已释放的内存（悬挂指针）、未初始化的指针或越界访问数组或字符串</li>
<li><strong>资源管理错误</strong>，如内存泄露，或文件或网络句柄未正确关闭</li>
<li><strong>并发错误</strong>：1）竞态条件：多个线程或进程争用数据，未正确同步；2）死锁：多个线程或进程相互等待对方持有的资源</li>
<li><strong>栈溢出</strong>：递归调用过深，或大量局部变量分配</li>
<li><strong>除零错误</strong>：整数或浮点数除以零</li>
</ol>
<p><strong>（2）解决方法</strong></p>
<ol>
<li><strong>调试工具</strong>：使用调试器（如 GDB）检查崩溃时的栈跟踪（stack trace）</li>
<li><strong>代码审查</strong></li>
<li><strong>增加日志记录</strong>：在关键操作前后添加日志记录，以追踪崩溃前的程序状态和行为；使用断言检查程序运行时的预期状态</li>
<li><strong>单元测试</strong>：编写和维护单元测试</li>
<li><strong>优化设计</strong>，避免过深的递归调用，考虑使用循环或其他算法策略；为并发操作设计合理的锁策略和线程同步机制</li>
</ol>
<h3 id="87、什么时候会发生段错误？"><a href="#87、什么时候会发生段错误？" class="headerlink" title="87、什么时候会发生段错误？"></a>87、<strong>什么时候会发生段错误？</strong></h3><p>段错误通常发生在<strong>访问非法内存地址</strong>的时候，具体来说分为以下几种情况： </p>
<ol>
<li>使用野指针；</li>
<li>试图修改字符串常量的内容。</li>
</ol>
<h3 id="88、程序崩溃产生-core-dump-一般怎么处理？"><a href="#88、程序崩溃产生-core-dump-一般怎么处理？" class="headerlink" title="88、程序崩溃产生 core dump 一般怎么处理？"></a>88、程序崩溃产生 core dump 一般怎么处理？</h3><p>core dump 是程序由于异常在运行时<strong>异常退出或者终止</strong>，在一定的条件下<strong>生成的一个叫做 core 的文件</strong>，这个 core 文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对其进行分析可以定位到程序异常发生时对应的堆栈调用信息。</p>
<p>一般采用<strong>使用 gdb 命令</strong>对 core 文件进行调试。</p>
<h3 id="【-】89、当程序运行时，如何将其加载到进程地址空间？"><a href="#【-】89、当程序运行时，如何将其加载到进程地址空间？" class="headerlink" title="【*】89、当程序运行时，如何将其加载到进程地址空间？"></a>【*】89、当程序运行时，如何将其加载到进程地址空间？</h3><ol>
<li>从可执行文件中的代码段中找到程序的入口地址；</li>
<li>接着操作系统将虚拟地址转换为对应的物理地址，并在内存中进行执行；</li>
<li>执行完毕后，切换到下一行代码进行类似的操作，直到程序运行完毕。</li>
</ol>
<h3 id="【-】90、执行一个系统调用时，OS-发生的过程，越详细越好"><a href="#【-】90、执行一个系统调用时，OS-发生的过程，越详细越好" class="headerlink" title="【*】90、执行一个系统调用时，OS 发生的过程，越详细越好"></a>【*】90、执行一个系统调用时，OS 发生的过程，越详细越好</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作流程：应用程序 -&gt; 函数库 -&gt; 系统调用（软中断） -&gt; 内核</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断：1.中断号； 2.中断处理程序； 3.中断向量表。</span><br></pre></td></tr></table></figure>

<p>系统调用的流程：</p>
<ol>
<li><p>触发中断：将系统调用号存入寄存器 <code>eax</code>，并执行 <code>int $0x80</code>产生中断；</p>
</li>
<li><p>切换堆栈：从用户态切换到内核态；</p>
</li>
<li><p>执行中断程序：根据中断号 <code>0x80</code> 找到中断处理程序 <code>system_call</code>；再从 <code>eax</code> 中取出系统调用号，找到对应的处理函数；</p>
</li>
<li><p>从中断程序中返回：通过 <code>iret</code> 将返回值返回，并从内核态返回到用户态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.	系统调用号 -&gt; eax</span><br><span class="line">	int 0x80（注意所用的中断都复用一个中断号）</span><br><span class="line"></span><br><span class="line">2.	用户态切换到内核态</span><br><span class="line"></span><br><span class="line">3.	0x80 -&gt; system_call</span><br><span class="line">	eax -&gt; 系统调用号（根据不同的系统调用号来找到对应的系统调用实现） -&gt; 系统调用表 -&gt; 处理函数</span><br><span class="line"></span><br><span class="line">4.	iret 返回值返回</span><br><span class="line">	从内核态返回用户态</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>切换堆栈实际上就是切换中断上下文，包含以下内容：</p>
<ol>
<li>进程状态发生改变；（task_struct)</li>
<li>保存当前运行现场，将 CPU 中存储的用户态指令保存到 *stack 中，并加载内核态的指令。</li>
</ol>
</blockquote>
<h3 id="91、动态链接和静态链接的区别？"><a href="#91、动态链接和静态链接的区别？" class="headerlink" title="91、动态链接和静态链接的区别？"></a>91、动态链接和静态链接的区别？</h3><ol>
<li><p>静态链接</p>
<ol>
<li><p>静态链接时指<strong>所有需要的库代码在编译时就被嵌入到可执行文件中，最终生成的可执行文件中包含了所有的库代码</strong>；</p>
</li>
<li><p>优点是具有<strong>独立性和版本一致性</strong>，可执行文件不依赖于外部库，且所有使用的库版本都是编译时版本，不会因系统库版本变化而导致问题；</p>
</li>
<li><p>缺点是<strong>文件大小过大且更新不便</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram myprogram.c -static</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>动态链接</p>
<ol>
<li>动态链接是指<strong>库代码在运行时被加载，可执行文件中只包含对动态库的引用，库本身是单独的文件</strong>；</li>
<li>优点是<strong>文件大小小、易于更新，且多个程序可以共享同一个动态库</strong>；</li>
<li>缺点是<strong>依赖性强，启动时间增长</strong>，可执行文件依赖于外部库，如果这些库在系统中缺失或版本不兼容，可能会造成问题。同时程序启动时需要加载库，可能会增加启动时间。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301606610.png" alt="image-20240630160655511"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301607955.png" alt="image-20240630160706843"></p>
<h2 id="四、Linux相关"><a href="#四、Linux相关" class="headerlink" title="四、Linux相关"></a>四、Linux相关</h2><h3 id="【-】92、Linux-常用命令（1）"><a href="#【-】92、Linux-常用命令（1）" class="headerlink" title="【*】92、Linux 常用命令（1）"></a>【*】92、Linux 常用命令（1）</h3><ol>
<li><p>切换目录：<code>cd</code></p>
</li>
<li><p>查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
</li>
<li><p>查看CPU利用率：<code>top</code>或<code>htop</code></p>
</li>
<li><p>查看进程状态：<code>ps</code>，其中进程的状态码如下：</p>
<ul>
<li><p>**R (Running)**：进程正在运行或在运行队列中等待</p>
</li>
<li><p>**S (Sleeping)**：进程处于睡眠状态，等待某个事件或资源。</p>
</li>
<li><p>**D (Uninterruptible Sleep)**：进程处于不可中断的睡眠状态，通常是在等待I&#x2F;O操作</p>
</li>
<li><p>**T (Stopped)**：进程已停止运行，通常是因为它正在被调试或已经收到停止信号</p>
</li>
<li><p>**Z (Zombie)**：进程已完成执行，但仍在进程表中等待父进程读取其退出状态</p>
</li>
<li><p>**I (Idle)**：这是一个空闲的内核线程，这个状态在某些版本的ps输出中可能不会显示</p>
</li>
</ul>
</li>
<li><p>查询网络状态：<code>ifconfig</code>、<code>netstat -r # 显示路由表</code></p>
</li>
<li><p>查看磁盘：<code>df -h</code>、<code>lsblk</code></p>
</li>
<li><p>查看是哪个进程的内存占用最大：<code>top</code>+<code>M</code>键、<code>ps aux --sort=-%mem | head -10</code></p>
</li>
<li><p>查找文件：<code>find</code>、<code>locate</code></p>
</li>
<li><p>查找文件内容：<code>grep -r &quot;hello&quot; /path/to/directory</code></p>
</li>
<li><p>查找系统命令的位置：<code>which ls</code></p>
</li>
</ol>
<h3 id="93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？"><a href="#93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？"></a>93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li><strong>文件描述符 0（标准输入）</strong>：指向标准输入设备，通常是终端（键盘）。</li>
<li><strong>文件描述符 1（标准输出）</strong>：指向标准输出设备，通常是终端（屏幕）。</li>
<li><strong>文件描述符 2（标准错误）</strong>：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="94、Linux-系统中的中断为什么分为上下两个部分？"><a href="#94、Linux-系统中的中断为什么分为上下两个部分？" class="headerlink" title="94、Linux 系统中的中断为什么分为上下两个部分？"></a>94、Linux 系统中的中断为什么分为上下两个部分？</h3><p>在 Linux 系统中，中断处理通常被分为上半部（Top Half）和下半部（Bottom Half）：</p>
<ol>
<li><strong>上半部</strong>：上半部是<strong>中断处理的第一阶段</strong>，它在 CPU 接收到中断信号后立即执行。<strong>在这一阶段中，中断和调度器通常被禁用，以避免在处理中断时发生新的中断，从而保证处理的原子性</strong>。上半部的代码通常包含<strong>处理中断的关键代码</strong>，这部分代码的执行时间应尽可能短，以快速释放CPU资源，处理更多的中断或其他任务。</li>
<li><strong>下半部</strong>：下半部处理的是<strong>中断处理的后续部分</strong>，通常在上半部完成后，通过<strong>添加工作项到工作队列中</strong>来延后执行。<strong>在下半部执行时，中断通常是被允许的</strong>，这样可以在处理较长时间的任务时不阻塞其他中断的处理。下半部负责完成<strong>数据处理、复制等</strong>操作，这些操作不需要立即完成，可以稍后处理。</li>
</ol>
<p>这种分割方法的主要优点是能够快速响应中断，同时又不会因为长时间的数据处理而阻塞 CPU，影响系统的整体性能。通过这种方式，Linux 系统能够在保证响应速度的同时，也能有效地处理大量的数据。</p>
<h3 id="95、Linux-用户态如何进入内核态？"><a href="#95、Linux-用户态如何进入内核态？" class="headerlink" title="95、Linux 用户态如何进入内核态？"></a>95、Linux 用户态如何进入内核态？</h3><ol>
<li><strong>系统调用（System Call）</strong>：<strong>系统调用</strong>是最常见的从用户态切换到内核态的方式。程序在需要执行诸如文件操作、网络通信、进程控制等操作时，会通过系统调用请求操作系统提供服务。Linux 提供了大量的系统调用，例如<code>read()</code>, <code>write()</code>, <code>open()</code>, <code>fork()</code>等。系统调用通过软件中断（通常是中断指令<code>int 0x80</code>或<code>syscall</code>指令）来实现，此时处理器从用户态切换到内核态，并跳转到预定义的内核入口点执行相应的内核代码。</li>
<li><strong>异常（Exception）</strong>：当程序执行出现错误时（如除零、访问非法内存等），会触发异常，处理器切换到内核态，调动<strong>异常处理程序</strong>来响应和处理这些错误事件。</li>
<li><strong>中断（Interrupt）</strong>：当外部设备（如键盘、鼠标、网络接口等）需要处理时，它们会向处理器发送中断信号。此时正在执行的用户程序被挂起，处理器切换到内核态，调动<strong>中断处理函数</strong>来响应和处理这些外部事件。</li>
</ol>
<h3 id="96、如何用-gbd-调试发现线程阻塞？"><a href="#96、如何用-gbd-调试发现线程阻塞？" class="headerlink" title="96、如何用 gbd 调试发现线程阻塞？"></a>96、如何用 gbd 调试发现线程阻塞？</h3><ol>
<li><p><strong>启动GDB并附加到进程</strong></p>
<p>从 GDB 启动程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./your_program</span><br><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>

<p> 附加到已经运行的程序：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -p [pid]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出所有线程</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切换线程</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread [thread-id]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查线程的栈帧</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查锁的状态。</strong>如果怀疑是死锁或资源竞争引起的阻塞，可以检查锁的状态。</p>
</li>
</ol>
<h3 id="97、gdb-查看所有线程线程栈的命令是什么？"><a href="#97、gdb-查看所有线程线程栈的命令是什么？" class="headerlink" title="97、gdb 查看所有线程线程栈的命令是什么？"></a>97、gdb 查看所有线程线程栈的命令是什么？</h3><ol>
<li>查看所有线程： <code>info threads</code></li>
<li>查看所有线程的栈信息： <code>thread apply all bt</code></li>
</ol>
<h3 id="98、gdb-查看内存地址的命令是什么？"><a href="#98、gdb-查看内存地址的命令是什么？" class="headerlink" title="98、gdb 查看内存地址的命令是什么？"></a>98、gdb 查看内存地址的命令是什么？</h3><p><code>x/NFU address</code></p>
<ul>
<li><code>N</code> 表示要检查的单元格的数量。</li>
<li><code>F</code> 表示显示格式，例如 <code>x</code>（十六进制）、<code>d</code>（十进制）、<code>u</code>（无符号十进制）、<code>t</code>（二进制）、<code>a</code>（地址）、<code>i</code>（机器指令）、<code>c</code>（字符）等。</li>
<li><code>U</code> 表示单位大小，例如 <code>b</code>（字节）、<code>h</code>（半字，2字节）、<code>w</code>（字，4字节）、<code>g</code>（双字，8字节）。</li>
</ul>
<h2 id="五、处理器相关"><a href="#五、处理器相关" class="headerlink" title="五、处理器相关"></a>五、处理器相关</h2><h3 id="99、浮点数在计算机中怎么存储？"><a href="#99、浮点数在计算机中怎么存储？" class="headerlink" title="99、浮点数在计算机中怎么存储？"></a>99、浮点数在计算机中怎么存储？</h3><p>浮点数在计算机中的存储通常采用IEEE 754标准，这是一种广泛使用的浮点数表示方法，具体如下：</p>
<ol>
<li><strong>符号位（Sign）</strong>：用一个位来表示数值的正负，0表示正数，1表示负数。</li>
<li><strong>指数位（Exponent）</strong>：用来表示数值的指数部分，以二进制补码表示。指数部分确定了浮点数的大小范围。</li>
<li><strong>尾数位（Fraction&#x2F;Mantissa）</strong>：也称为尾数或者系数，用来表示浮点数的小数部分。通常为带有隐含的整数1的小数分数。</li>
</ol>
<p>根据IEEE 754标准，浮点数可以分为单精度（32位）和双精度（64位）两种格式：</p>
<ul>
<li><strong>单精度浮点数（float）</strong>：由32位组成，其中1位符号位，8位指数位，23位尾数位。</li>
<li><strong>双精度浮点数（double）</strong>：由64位组成，其中1位符号位，11位指数位，52位尾数位。</li>
</ul>
<h3 id="100、怎么判断两个浮点数是否相等？"><a href="#100、怎么判断两个浮点数是否相等？" class="headerlink" title="100、怎么判断两个浮点数是否相等？"></a>100、怎么判断两个浮点数是否相等？</h3><p>相减，并与预先设定的精度进行比较。不能采用 <code>==</code> 来判断。</p>
<p><strong>-为什么？</strong></p>
<p>因为浮点数在计算机内部是以<strong>近似值</strong>存储的，可能会因为舍入误差等问题导致两个理论上相等的浮点数在实际存储时并不完全相等。</p>
<h3 id="101、什么是大小端？如何区分？网络通信一般是什么字节序？"><a href="#101、什么是大小端？如何区分？网络通信一般是什么字节序？" class="headerlink" title="101、什么是大小端？如何区分？网络通信一般是什么字节序？"></a>101、什么是大小端？如何区分？网络通信一般是什么字节序？</h3><ol>
<li><p>大端字节序是指高位字节存储在内存的低地址端，低位字节存储在内存的高地址端；小端字节序则与之相反。</p>
</li>
<li><p>区分的方法如下：</p>
<p>（1）通过检查整数的首个字节来确定字节序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）C++20 中提供了一个标准库函数进行检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_endianness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::endian::native == std::endian::big) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Big-endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::endian::native == std::endian::little) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Little-endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unknown endianness&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_endianness</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络通信一般是大端字节序，即无论发送和接收的系统是大端还是小端，数据在通过网络传输时都必须转换为网络字节序。</p>
</li>
</ol>
<h3 id="102、什么是-qps-和-tps-，如何计算？"><a href="#102、什么是-qps-和-tps-，如何计算？" class="headerlink" title="102、什么是 qps 和 tps ，如何计算？"></a>102、什么是 qps 和 tps ，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和 Web 服务器的性能。QPS 可以通过<strong>将总查询数除以时间（秒）</strong>来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。<strong>一个事务是指一个完整的业务操作，可能包含多个查询和更新</strong>。TPS 是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS 的计算方法与 QPS 类似，<strong>将总事务数除以时间（秒）</strong>。</p>
<h3 id="103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？"><a href="#103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？" class="headerlink" title="103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？"></a>103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？</h3><p>（1）<strong>对于 CPU 密集型应用</strong>，CPU 是性能瓶颈。如果 CPU 利用率已经达到 100%，这意味着 CPU 资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的 CPU 资源。这可能导致上下文切换增加，反而降低了程序的效率和 QPS。</p>
<p>（2）<strong>对于 I&#x2F;O 密集型应用</strong>，主要的瓶颈在于 I&#x2F;O 操作，<strong>如磁盘读写或网络通信等</strong>。即使 CPU 利用率很高，增加线程数仍然可能提高 QPS，因为当一部分线程在等待 I&#x2F;O 操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用 CPU 在等待 I&#x2F;O 时的空闲周期，提高 QPS。</p>
<p>（3）混合型应用同时包含 CPU 密集型和 I&#x2F;O 密集型的操作。在这种情况下，是否增加线程以提高 QPS 取决于应用中 CPU 密集型和 I&#x2F;O 密集型操作的比例。如果 I&#x2F;O 操作占主导，增加线程可能有助于提高 QPS；但如果 CPU 密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="104、什么是-CPU-密集型应用和-I-O-密集型应用？"><a href="#104、什么是-CPU-密集型应用和-I-O-密集型应用？" class="headerlink" title="104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？"></a>104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？</h3><p>（1）CPU 密集型应用是指那些<strong>需要进行大量计算，消耗大量 CPU 资源的应用</strong>。这类应用的特点是 CPU 使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的 CPU 周期来完成。CPU 密集型应用的性能很大程度上依赖于 CPU 的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO 密集型应用是指那些<strong>主要时间花费在输入输出操作上</strong>，而不是 CPU 计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU 使用率不高，但是需要等待 IO 操作的完成，因此对 IO 性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web 服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h3 id="105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？"><a href="#105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？" class="headerlink" title="105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？"></a>105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？</h3><p>（1）在 IO 密集型应用中，IO 操作（如文件读写、网络数据传输等）往往是性能瓶颈。<strong>通过异步 IO 或使用专门的线程&#x2F;进程处理 IO 操作，主业务逻辑不需要等待 IO 操作的完成，从而减少等待时间，提高整体应用的响应速度和吞吐量</strong>。</p>
<p>（2）当 IO 操作与业务逻辑分开后，<strong>更易于对系统进行扩展</strong>。例如，可以根据需要增加处理 IO 的线程或进程，或者改用更高效的 IO 处理模式（如使用更高级的异步 IO 库），而不需要重大修改应用的业务逻辑部分。</p>
<p>（4）分离 IO 和业务逻辑可以<strong>使测试变得更加简单。可以独立地对 IO 部分和业务逻辑部分进行测试</strong>，例如使用模拟的 IO 操作来测试业务逻辑，确保业务逻辑的正确性而不受 IO 影响。</p>
<h3 id="106、CPU-流水线技术是什么？"><a href="#106、CPU-流水线技术是什么？" class="headerlink" title="106、CPU 流水线技术是什么？"></a>106、CPU 流水线技术是什么？</h3><p>CPU 流水线技术是一种将指令<strong>分解为多步骤</strong>并<strong>让这些步骤并行执行</strong>的技术，从而提高 CPU 的执行效率。<strong>流水线技术通过将指令执行过程分解为取指令、译码、执行、访存和写回等阶段</strong>，每个阶段由不同的硬件单元处理，使得<strong>多条指令能够重叠执行</strong>，提高了处理速度。</p>
<h3 id="107、流水线技术中的分支预测的实现和意义？"><a href="#107、流水线技术中的分支预测的实现和意义？" class="headerlink" title="107、流水线技术中的分支预测的实现和意义？"></a>107、流水线技术中的分支预测的实现和意义？</h3><p>分支预测是流水线技术中用来<strong>处理指令跳转（如条件分支）带来的中断问题，从而提高程序执行的效率</strong>。现代 CPU 使用复杂的算法来预测程序中的分支跳转是否会发生，以及跳转到哪里。常见的分支预测技术包括<strong>静态分支预测</strong>（如始终预测跳转或不跳转）和<strong>动态分支预测</strong>（如基于历史信息的预测）。</p>
<h3 id="【-】108、内核和应用进行数据交互的方法有哪些？"><a href="#【-】108、内核和应用进行数据交互的方法有哪些？" class="headerlink" title="【*】108、内核和应用进行数据交互的方法有哪些？"></a>【*】108、内核和应用进行数据交互的方法有哪些？</h3><ol>
<li><strong>系统调用</strong> (System Calls):<ul>
<li>系统调用是应用程序与操作系统内核之间进行交互的主要方式。应用程序通过系统调用请求内核提供服务，如文件操作、进程控制、网络通信等。系统调用提供了一种安全的机制来执行硬件操作或访问内核级资源。</li>
</ul>
</li>
<li><strong>中断和异常</strong> (Interrupts and Exceptions):<ul>
<li>中断是外部设备或条件触发的，用于通知内核需要处理某些事件。异常则是程序执行错误时的一种特殊类型的中断，如除零错误或访问违规。</li>
<li>应用程序可以通过处理这些中断和异常来与内核交互，响应外部事件或错误。</li>
</ul>
</li>
</ol>
<h3 id="109、系统调用是否会引起进程或线程的切换呢？"><a href="#109、系统调用是否会引起进程或线程的切换呢？" class="headerlink" title="109、系统调用是否会引起进程或线程的切换呢？"></a>109、系统调用是否会引起进程或线程的切换呢？</h3><p>不一定。</p>
<ol>
<li><p>如果使用<strong>阻塞的 I&#x2F;O 且 I&#x2F;O 未就绪</strong>，将进行线程或进程的切换，会从运行态进入阻塞态；</p>
</li>
<li><p>如果使用<strong>非阻塞的 I&#x2F;O</strong>，此时不会进行线程或进程的切换。</p>
</li>
</ol>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, O_NONBLOCK);  <span class="comment">// 设置I/O非阻塞</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="110、内核的调度方式是什么？"><a href="#110、内核的调度方式是什么？" class="headerlink" title="110、内核的调度方式是什么？"></a>110、内核的调度方式是什么？</h3><p>在 Linux 操作系统中，内核的调度方式是指如何管理和调度系统中的进程和线程，以优化性能和响应时间。Linux 内核使用多种调度策略和算法，主要包括以下几种：</p>
<ol>
<li><strong>完全公平调度器（Completely Fair Scheduler, CFS）</strong></li>
<li><strong>实时调度器</strong>，Linux 提供了两种实时调度策略：<code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</li>
<li><strong>Deadline 调度器（SCHED_DEADLINE）</strong>，这是一种较新的调度策略，用于确保任务在指定的截止时间之前完成。</li>
<li><strong>Cgroups 和任务组</strong>，Linux 还支持通过控制组（cgroups）对进程进行分组管理，这允许系统管理员根据需要对不同组的资源使用进行限制和监控。</li>
</ol>
<h3 id="【-】111、为什么要设计用户态和内核态两种状态？"><a href="#【-】111、为什么要设计用户态和内核态两种状态？" class="headerlink" title="【*】111、为什么要设计用户态和内核态两种状态？"></a>【*】111、为什么要设计用户态和内核态两种状态？</h3><p>这样做是为了<strong>保护操作系统的核心部分不被用户程序直接访问和修改</strong>，从而增加系统的稳定性和安全性。</p>
<p>（1）内核态主要允许操作系统访问<strong>受保护的硬件资源和内存区域</strong>，而用户态的控制程序则限制执行一些会影响系统稳定性和安全性的操作。</p>
<p>（2）如果用户态程序崩溃，它通常不会影响运行在内核态的系统核心部分，因此整个操作系统可以继续稳定运行。</p>
<p>（3）同时用户态程序也可能因为一些错误而尝试执行非法操作，此时操作系统可以拦截这些操作，避免对核心部分造成影响。</p>
<h3 id="112、单片机启动程序，在执行-main-之前的是什么"><a href="#112、单片机启动程序，在执行-main-之前的是什么" class="headerlink" title="112、单片机启动程序，在执行 main 之前的是什么"></a>112、单片机启动程序，在执行 main 之前的是什么</h3><p>在单片机启动程序中，执行main函数之前的过程主要包括以下几个步骤：</p>
<ol>
<li><strong>硬件设置</strong>：单片机上电后，首先进行的是硬件的初始化，包括设置堆栈指针（SP）和程序计数器（PC）。</li>
<li><strong>启动文件执行</strong>：接下来，单片机会执行启动文件，通常是名为 <code>startup_xxxxx.s</code> 的汇编语言文件。这个文件负责设置单片机的初始环境和配置，为 main 函数的执行做准备。</li>
<li><strong>初始化代码</strong>：在启动文件执行后，可能还会有一些初始化代码，这些代码用于初始化单片机的硬件和软件环境，比如设置时钟、配置中断等。</li>
<li><strong>跳转到main函数</strong>：所有的初始化和设置完成后，单片机最终会跳转到 main 函数开始执行用户的程序。</li>
</ol>
<p>这个过程确保了单片机在执行用户代码之前，硬件和系统环境已经被正确地设置和初始化，从而可以正确地运行用户程序。</p>
<h3 id="113、怎么在-main-函数执行之前打印字符串？"><a href="#113、怎么在-main-函数执行之前打印字符串？" class="headerlink" title="113、怎么在 main 函数执行之前打印字符串？"></a>113、怎么在 main 函数执行之前打印字符串？</h3><p>使用全局对象的构造函数。全局对象的构造函数在程序开始执行之前被调用，因此可以在这里进行一些初始化操作，包括打印字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalPrinter</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造函数中打印字符串</span></span><br><span class="line">    <span class="built_in">GlobalPrinter</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Printed before main starts!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局对象，其构造函数会在 main 函数之前执行</span></span><br><span class="line">GlobalPrinter printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GlobalPrinter</code> 结构体是一个全局对象，其构造函数在程序启动时执行，因此会在 <code>main</code> 函数执行之前打印 <code>&quot;Printed before main starts!&quot;</code>。</p>
<h3 id="114、CPU-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？"><a href="#114、CPU-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？" class="headerlink" title="114、CPU 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？"></a>114、CPU 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？</h3><p>当 CPU 执行 load 指令从内存中获取数据时，通常会经过以下几个主要阶段和模块：</p>
<ol>
<li><strong>地址计算</strong>：CPU 根据 load 指令中的内存地址计算要访问的物理地址。这个地址通常是通过将逻辑地址（由程序中指定的地址）转换为物理地址来完成的。</li>
<li><strong>地址总线传输</strong>：CPU 使用地址总线将计算得到的物理地址发送到内存控制器（Memory Controller）。</li>
<li><strong>内存寻址</strong>：内存控制器接收到地址后，根据地址在物理内存中定位要访问的数据块。</li>
<li><strong>数据传输</strong>：内存控制器根据地址访问内存中的数据，并通过数据总线将数据传输回 CPU。</li>
<li><strong>数据接收</strong>：CPU 接收到数据，并将其存储到指定的寄存器或者目的地。</li>
</ol>
<h3 id="115、arm-和-x86-比较明显的区别是什么？"><a href="#115、arm-和-x86-比较明显的区别是什么？" class="headerlink" title="115、arm 和 x86 比较明显的区别是什么？"></a>115、arm 和 x86 比较明显的区别是什么？</h3><p><strong>指令集架构：</strong></p>
<ul>
<li><strong>x86 架构</strong>：主要用于<strong>个人电脑和服务器</strong>，采用<strong>复杂的指令集（CISC）</strong>，例如 Intel 的 x86 和 x86-64（即64位扩展）架构。x86 架构的特点是指令集较为复杂，包含大量的指令和寄存器，能够执行复杂的操作，但功耗较高。</li>
<li><strong>ARM 架构</strong>：最初设计<strong>用于低功耗和嵌入式系统</strong>，采用<strong>精简指令集（RISC）</strong>。ARM 架构的特点是指令集简洁高效，适合于低功耗和嵌入式设备，如智能手机、平板电脑、嵌入式系统等。</li>
</ul>
<h3 id="【-】116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？"><a href="#【-】116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？" class="headerlink" title="【*】116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？"></a>【*】116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？</h3><ol>
<li><p><strong>观察系统资源使用情况</strong>：使用命令 <code>top</code> 或 <code>htop</code> 查看当前系统的 CPU 使用率、内存使用情况、进程状态以及各个进程的资源消耗情况。特别关注是否有某个进程消耗过多的 CPU 或内存。</p>
</li>
<li><p><strong>检查系统负载情况</strong>：使用 <code>uptime</code> 命令或者查看 <code>/proc/loadavg</code> 文件，检查系统的负载情况。如果负载过高（load average 高于 CPU 核心数），说明系统可能存在过多的并发任务或者进程阻塞。</p>
</li>
<li><p><strong>查看日志文件</strong>：检查系统日志文件（如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>）以及特定服务的日志（如 Apache、MySQL 等），寻找异常或者错误信息。日志文件通常会记录系统的各种事件和错误情况。</p>
</li>
<li><p><strong>检测磁盘使用情况</strong>：使用 <code>df</code> 命令查看磁盘分区的使用情况，尤其是是否出现磁盘空间不足或者磁盘 I&#x2F;O 瓶颈的情况。</p>
</li>
<li><p><strong>网络流量分析</strong>：使用 <code>netstat</code> 或者 <code>iftop</code> 查看网络连接和流量情况，检查是否有异常的网络活动或者网络流量过高。</p>
</li>
<li><p><strong>检查硬件问题</strong>：如果排查软件问题后仍未找到原因，可能需要考虑硬件问题。通过检查硬件状态和日志（如 <code>/var/log/dmesg</code>）来排除硬件故障的可能性。</p>
</li>
</ol>
<h2 id="六、Linux-命令相关"><a href="#六、Linux-命令相关" class="headerlink" title="六、Linux 命令相关"></a>六、Linux 命令相关</h2><h3 id="117、哪些状态的进程无法被-kill？"><a href="#117、哪些状态的进程无法被-kill？" class="headerlink" title="117、哪些状态的进程无法被 kill？"></a>117、哪些状态的进程无法被 kill？</h3><ol>
<li><strong>内核线程（Kernel Threads）</strong>：内核线程是在内核空间中执行的线程，通常由操作系统内核创建和管理。<strong>这些线程处于内核态而非用户态，因此无法被 kill。</strong></li>
<li><strong>僵尸进程（Zombie Processes）</strong>：僵尸进程是已经结束但是父进程尚未对其进行处理的子进程，这种进程处于僵尸状态。虽然它们已经结束了执行，但是它们的进程描述符仍然存在于系统中，直到父进程调用 wait 或 waitpid 等系统调用来获取它们的退出状态。*<em>在僵尸状态下，进程通常是无法通过kill命令来终止的。</em></li>
<li><strong>被内核保护的进程</strong>：一些特殊的进程可能受到内核的保护，例如一些关键的系统服务或者核心进程。<strong>这些进程通常由操作系统内核管理，并且可能受到权限限制，无法被普通用户通过kill命令终止。</strong></li>
</ol>
<h3 id="118、kill-是怎么实现终止进程的？"><a href="#118、kill-是怎么实现终止进程的？" class="headerlink" title="118、kill 是怎么实现终止进程的？"></a>118、kill 是怎么实现终止进程的？</h3><p>当用户使用 kill 命令时，会<strong>向进程发送 SIGKILL 信号</strong>，操作系统内核会首先<strong>验证</strong>当前用户是否具有<strong>足够的权限</strong>来发送信号给目标进程。如果具有足够的权限，则内核会查找目标进程的<strong>进程描述符</strong>，并向其发送指定的信号。</p>
<p>接收到信号的进程会<strong>根据信号的类型采取不同的行动</strong>。对于 SIGKILL 信号，目标进程会被立即终止，无法进行信号处理或者捕获。<strong>此外，进程终止时，内核会对其进行一系列清理工作</strong>，包括<strong>释放</strong>该进程所占用的<strong>资源</strong>、<strong>解除</strong>与其他进程的<strong>关联</strong>等。</p>
<h3 id="【-】119、Linux-常用命令（2）"><a href="#【-】119、Linux-常用命令（2）" class="headerlink" title="【*】119、Linux 常用命令（2）"></a>【*】119、Linux 常用命令（2）</h3><h4 id="（1）查看哪个进程的内存占用最大？"><a href="#（1）查看哪个进程的内存占用最大？" class="headerlink" title="（1）查看哪个进程的内存占用最大？"></a>（1）查看哪个进程的内存占用最大？</h4><ol>
<li><p><code>top</code>+<code>M</code>键</p>
</li>
<li><p><code>htop</code></p>
</li>
</ol>
<h4 id="（2）查看进程打开了什么端口？"><a href="#（2）查看进程打开了什么端口？" class="headerlink" title="（2）查看进程打开了什么端口？"></a>（2）查看进程打开了什么端口？</h4><p> <code>netstat -tulnp</code> ，列出当前系统中所有正在监听的 TCP 和 UDP 端口以及对应的进程信息。</p>
<ul>
<li><code>-t</code>：显示 TCP 协议的连接</li>
<li><code>-u</code>：显示 UDP 协议的连接</li>
<li><code>-l</code>：显示监听中的套接字（sockets），即正在监听的服务器端口</li>
<li><code>-n</code>：以数字形式显示地址和端口号，而不是尝试解析服务名称和主机名</li>
<li><code>-p</code>：显示使用套接字的进程 ID（PID）和进程名称。</li>
</ul>
<h4 id="（3）查看进程是否存活？"><a href="#（3）查看进程是否存活？" class="headerlink" title="（3）查看进程是否存活？"></a>（3）查看进程是否存活？</h4><p><code>ps -p &lt;PID&gt;</code>，查看指定 PID 的进程信息，如果返回了进程信息，则表示该进程存活。</p>
<h4 id="（4）查看进程-id-？"><a href="#（4）查看进程-id-？" class="headerlink" title="（4）查看进程 id ？"></a>（4）查看进程 id ？</h4><p> <code>ps aux | grep &lt;进程名&gt;</code> ，查看指定进程名的所有进程，并显示它们的进程 ID。</p>
<h4 id="（5）查看进程状态？"><a href="#（5）查看进程状态？" class="headerlink" title="（5）查看进程状态？"></a>（5）查看进程状态？</h4><p><code>ps</code> ，查看进程的状态。</p>
<p><code>ps aux</code> 命令可以列出系统中所有进程的详细信息，包括状态、PID、CPU 利用率等。</p>
<h4 id="（6）lsof-指令主要是干什么的？"><a href="#（6）lsof-指令主要是干什么的？" class="headerlink" title="（6）lsof 指令主要是干什么的？"></a>（6）lsof 指令主要是干什么的？</h4><p><code>lsof (list open files)</code>主要用于显示当前系统中打开的文件列表，包括文件、目录、网络套接字等。通过 lsof 命令可以查看某个进程打开了哪些文件、网络连接等信息，用于定位进程问题、分析系统资源利用等。</p>
<h4 id="（7）-如何让进程后台运行？"><a href="#（7）-如何让进程后台运行？" class="headerlink" title="（7） 如何让进程后台运行？"></a>（7） 如何让进程后台运行？</h4><ol>
<li><p><strong>使用 &amp; 符号</strong>：</p>
<ul>
<li><p>在命令行中，在命令的末尾加上 <code>&amp;</code> 符号，可以让该命令在后台执行。</p>
</li>
<li><p>例如，要让 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py</span><br></pre></td></tr></table></figure>

<p> 在后台运行，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 nohup 命令</strong>：</p>
<ul>
<li><p><code>nohup</code> 命令用于将程序以忽略挂断信号的方式运行，这样即使终端关闭，程序也会继续在后台运行。</p>
</li>
<li><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="（8）查看一个进程可以打开多少文件描述符？"><a href="#（8）查看一个进程可以打开多少文件描述符？" class="headerlink" title="（8）查看一个进程可以打开多少文件描述符？"></a>（8）查看一个进程可以打开多少文件描述符？</h4><p>在大多数 Linux 系统中，一个进程最多可以同时打开 1024 个文件。</p>
<p>不过，可以通过修改系统配置来增加： </p>
<ul>
<li><code>ulimit -n</code>：查看当前进程的文件描述符限制；</li>
<li><code>ulimit -n 4096</code>：将文件描述符限制增加到 4096。注意的是，文件描述符限制是系统范围的，而不是针对单个进程的。因此，对文件描述符限制的修改将影响到所有正在运行的进程。</li>
</ul>
<h4 id="（9）查看-CPU-核心数？"><a href="#（9）查看-CPU-核心数？" class="headerlink" title="（9）查看 CPU 核心数？"></a>（9）查看 CPU 核心数？</h4><p><strong>方法一</strong>：<code>lscpu</code> 命令，在输出中查找 <code>CPU(s):</code> 字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：读取 <code>/proc/cpuinfo</code> 文件可以，统计 <code>processor</code> 字段的行数，等于逻辑 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo：这个命令用于打印 CPU 信息到标准输出。</span></span><br><span class="line"><span class="comment"># grep &quot;processor&quot;：通过管道 | 将 cat 命令的输出传递给 grep 命令，</span></span><br><span class="line"><span class="comment">#				    然后使用 grep 进行筛选，只保留包含 &quot;processor&quot; 字符串的行，</span></span><br><span class="line"><span class="comment">#					这些行包含了每个 CPU 核心的信息。</span></span><br><span class="line"><span class="comment"># wc -l：</span></span><br><span class="line"><span class="comment">#	wc 命令用于统计文件的行数，参数 -l 表示只统计行数。</span></span><br><span class="line"><span class="comment">#   通过 | 管道将 grep 命令的输出传递给 wc 命令，然后 wc 统计行数。</span></span><br><span class="line"><span class="comment">#	因为每个 CPU 核心的信息占据一行，所以统计出来的行数就是 CPU 的核心数。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>：<code>nproc</code> 命令，直接显示可用的处理器数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nproc</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong>：<code>top</code> 和 <code>htop</code> 命令也可以显示 CPU 信息。在 <code>htop</code> 中，可以在界面顶部看到 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<p><strong>方法五</strong>：<code>dmesg</code> 命令，查看启动日志，可以找到 CPU 信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cpu</span><br></pre></td></tr></table></figure>

<h4 id="（10）如何按照内存使用情况对进程排序查看？"><a href="#（10）如何按照内存使用情况对进程排序查看？" class="headerlink" title="（10）如何按照内存使用情况对进程排序查看？"></a>（10）如何按照内存使用情况对进程排序查看？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure>

<h4 id="（11）查看磁盘状态？"><a href="#（11）查看磁盘状态？" class="headerlink" title="（11）查看磁盘状态？"></a>（11）查看磁盘状态？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">df</span> -sh &lt;目录名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（12）查看日志文件的前一百行？"><a href="#（12）查看日志文件的前一百行？" class="headerlink" title="（12）查看日志文件的前一百行？"></a>（12）查看日志文件的前一百行？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 100 &lt;日志文件&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（13）-ps-aux-，-aux-是干什么的？"><a href="#（13）-ps-aux-，-aux-是干什么的？" class="headerlink" title="（13） ps -aux ， aux 是干什么的？"></a>（13） ps -aux ， aux 是干什么的？</h4><p>在 <code>ps -aux</code> 命令中，<code>aux</code> 是选项，用于指定显示所有进程的详细信息。其中：</p>
<ul>
<li><code>a</code> 选项表示显示所有进程，包括与终端无关的进程。</li>
<li><code>u</code> 选项表示显示用户及与进程相关的详细信息，如用户 ID、CPU 占用率、内存占用等。</li>
<li><code>x</code> 选项表示显示与终端无关的进程。</li>
</ul>
<p>因此，<code>ps -aux</code> 命令用于显示系统中所有进程的详细信息，包括与终端无关的进程。</p>
<h4 id="（14）本地和远程服务器之间传输文件的是什么？"><a href="#（14）本地和远程服务器之间传输文件的是什么？" class="headerlink" title="（14）本地和远程服务器之间传输文件的是什么？"></a>（14）本地和远程服务器之间传输文件的是什么？</h4><p><code>scp</code></p>
<h4 id="（15）查找文件名包含某个关键字的文件"><a href="#（15）查找文件名包含某个关键字的文件" class="headerlink" title="（15）查找文件名包含某个关键字的文件"></a>（15）查找文件名包含某个关键字的文件</h4><p><code>find 目录 -name &quot;特定字符串&quot;</code></p>
<h3 id="120、Linux-包含哪些部分？"><a href="#120、Linux-包含哪些部分？" class="headerlink" title="120、Linux 包含哪些部分？"></a>120、Linux 包含哪些部分？</h3><ol>
<li><strong>内核</strong>，操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。它提供了系统调用接口，允许用户程序与硬件交互；</li>
<li><strong>Shell</strong>，用户与操作系统交互的界面，它可以解释用户输入的命令并将其转换为操作系统能够理解的形式，常见的 Shell 包括 Bash、Zsh、Korn 等；</li>
<li><strong>文件系统</strong>，指文件和目录在存储设备上的组织方式，它提供了对文件和目录的创建、读取、写入和删除等操作。常见的文件系统包括 ext4、NTFS、FAT32 等；</li>
<li><strong>GNU 工具</strong>，一组用于开发和管理 Linux 系统的软件工具，包括编译器、调试器、文本编辑器等。常见的 GNU 工具包括 GCC、GDB、Emacs 等；</li>
<li><strong>图形用户界面 GUI</strong>；</li>
<li><strong>应用程序</strong>。</li>
</ol>
<h3 id="121、操作系统包含哪些部分？"><a href="#121、操作系统包含哪些部分？" class="headerlink" title="121、操作系统包含哪些部分？"></a>121、操作系统包含哪些部分？</h3><ol>
<li><strong>内核（Kernel）</strong>：操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。内核提供了系统调用接口，允许用户程序与硬件交互；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>进程管理（Process Management）</strong>：负责创建、调度和管理进程。进程是程序的执行实例，进程管理器控制着进程的创建、调度、终止等操作，并提供了进程间通信的机制；</li>
<li><strong>内存管理（Memory Management）</strong>：管理计算机的内存资源，包括内存的分配、释放、页面交换等操作。内存管理器负责为进程分配内存空间，并确保不同进程之间的内存地址空间互相隔离；</li>
<li><strong>设备驱动程序（Device Drivers）</strong>：负责与计算机的硬件设备进行通信，控制设备的操作和数据传输。设备驱动程序允许操作系统与硬件设备之间进行交互，以实现对硬件的控制和管理；</li>
<li><strong>用户界面（User Interface）</strong>：提供用户与操作系统交互的界面，包括命令行界面（CLI）和图形用户界面（GUI）。用户界面使用户能够通过输入命令或使用图形化界面来操作计算机；</li>
<li><strong>网络管理（Networking）</strong>：管理计算机与网络之间的通信和连接。网络管理器负责配置网络参数、管理网络接口、处理数据传输等操作，以确保计算机能够与其他设备进行通信。</li>
</ol>
<h2 id="七、文件系统"><a href="#七、文件系统" class="headerlink" title="七、文件系统"></a>七、文件系统</h2><h3 id="122、文件系统的基本组成"><a href="#122、文件系统的基本组成" class="headerlink" title="122、文件系统的基本组成"></a>122、文件系统的基本组成</h3><p>文件系统的基本组成包括以下几个部分：</p>
<ol>
<li><strong>文件和目录</strong>：用于组织和存储数据。</li>
<li><strong>超级块（Superblock）</strong>：存储文件系统的整体信息，如文件系统大小、块大小、空闲块数量等。</li>
<li><strong>inode（索引节点）</strong>：存储文件的元数据（如文件类型、权限、所有者、大小、时间戳等）和数据块指针。</li>
<li><strong>数据块</strong>：实际存储文件数据的区域。</li>
<li><strong>目录结构</strong>：管理文件和目录之间的层次关系。</li>
<li><strong>空闲空间管理</strong>：跟踪文件系统中未使用的空间。</li>
</ol>
<h3 id="【-】123、虚拟文件系统"><a href="#【-】123、虚拟文件系统" class="headerlink" title="【*】123、虚拟文件系统"></a>【*】123、虚拟文件系统</h3><p>虚拟文件系统（VFS）是<strong>操作系统内核中的一个抽象层，旨在为不同的文件系统提供统一的接口</strong>。VFS的主要功能包括：</p>
<ol>
<li><strong>统一接口</strong>：提供标准化的文件操作接口（如打开、关闭、读、写、删除等），无论底层文件系统是什么。</li>
<li><strong>挂载管理</strong>：管理多个文件系统的挂载和卸载。</li>
<li><strong>文件描述符管理</strong>：跟踪每个进程打开的文件。</li>
<li><strong>路径解析</strong>：解析文件路径并将其映射到相应的文件系统。</li>
</ol>
<h3 id="【-】124、文件的存储"><a href="#【-】124、文件的存储" class="headerlink" title="【*】124、文件的存储"></a>【*】124、文件的存储</h3><p>文件的存储涉及将文件数据保存在物理存储设备上的过程，通常包括以下几个步骤：</p>
<ol>
<li><strong>分配 inode</strong>：为新文件分配一个 inode，以存储文件的元数据。</li>
<li><strong>分配数据块</strong>：为文件的数据分配数据块。</li>
<li><strong>更新 inode</strong>：在 inode 中记录数据块的指针。</li>
<li><strong>写入数据</strong>：将文件数据写入分配的数据块。</li>
</ol>
<h3 id="【-】125、空闲空间管理"><a href="#【-】125、空闲空间管理" class="headerlink" title="【*】125、空闲空间管理"></a>【*】125、空闲空间管理</h3><p>空闲空间管理涉及跟踪文件系统中未使用的空间，常用的方法有：</p>
<ol>
<li><strong>位图（Bitmap）</strong>：使用位图来表示每个块的使用情况（0表示空闲，1表示已用）。</li>
<li><strong>链表（Free List）</strong>：使用链表来管理空闲块，每个块包含一个指向下一个空闲块的指针。</li>
<li><strong>空闲空间分区表（Free Space Table）</strong>：记录空闲空间的起始地址和长度。</li>
</ol>
<h3 id="【-】126、目录的存储"><a href="#【-】126、目录的存储" class="headerlink" title="【*】126、目录的存储"></a>【*】126、目录的存储</h3><p>目录的存储涉及将目录及其文件条目保存在文件系统中的过程，常见的方法有：</p>
<ol>
<li><strong>线性列表</strong>：每个目录是一个包含文件名和inode号的线性列表。</li>
<li><strong>B树&#x2F;B+树</strong>：使用树结构（如B树或B+树）来提高查找效率。</li>
<li><strong>哈希表</strong>：使用哈希表来快速定位文件名。</li>
</ol>
<h3 id="127、软链接和硬链接"><a href="#127、软链接和硬链接" class="headerlink" title="127、软链接和硬链接"></a>127、软链接和硬链接</h3><p>软链接（符号链接）和硬链接是UNIX和类UNIX文件系统中用于创建文件引用的两种方式：</p>
<ol>
<li><strong>软链接（Symbolic Link）</strong>：<ul>
<li>是一个指向另一个文件或目录的路径名。</li>
<li>可以跨文件系统。</li>
<li>如果被链接的文件被删除，软链接会指向一个不存在的目标（即“悬挂”链接）。</li>
<li>创建方式：<code>ln -s target link_name</code></li>
</ul>
</li>
<li><strong>硬链接（Hard Link）</strong>：<ul>
<li>是文件的直接引用，多个硬链接可以引用同一个文件。</li>
<li>不可以跨文件系统。</li>
<li>删除一个硬链接不会影响其他引用相同文件的硬链接，文件只有在所有硬链接都删除后才会被删除。</li>
<li>创建方式：<code>ln target link_name</code></li>
</ul>
</li>
</ol>
<h3 id="128、文件I-O"><a href="#128、文件I-O" class="headerlink" title="128、文件I&#x2F;O"></a>128、文件I&#x2F;O</h3><p>文件 I&#x2F;O（输入&#x2F;输出）是操作系统与文件系统交互的核心机制，涉及文件的打开、读写、关闭等操作。以下是文件 I&#x2F;O 的基本步骤：</p>
<ol>
<li><p><strong>打开文件</strong>：</p>
<ul>
<li><p>使用<code>open</code>或<code>fopen</code>函数打开文件，返回一个文件描述符或文件指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY); <span class="comment">// 以只读方式打开文件</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);   <span class="comment">// 以只读方式打开文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>读写文件</strong>：</p>
<ul>
<li><p>使用<code>read</code>和<code>write</code>函数进行文件的读取和写入操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="type">ssize_t</span> bytesRead = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer)); <span class="comment">// 读取文件内容到缓冲区</span></span><br><span class="line"><span class="type">ssize_t</span> bytesWritten = <span class="built_in">write</span>(fd, buffer, bytesRead);  <span class="comment">// 将缓冲区内容写入文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关闭文件</strong>：</p>
<ul>
<li><p>使用<code>close</code>或<code>fclose</code>函数关闭文件，释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(fd);    <span class="comment">// 关闭文件描述符</span></span><br><span class="line"><span class="built_in">fclose</span>(fp);   <span class="comment">// 关闭文件指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="129、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#129、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="129、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>129、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h3><ol>
<li>若此时还未调用 fflush()，即还没有调用 write() 接口，此时数据<strong>一定丢失</strong>；</li>
<li>若已调用了 write()，只要系统不重启或关闭，数据<strong>不会丢失</strong>，因为数据已经到达内核区；</li>
<li>假设进程崩溃的同时系统也关闭了：<ol>
<li>假设关闭系统前调用 write()：1）若使用直接磁盘 I&#x2F;O，数据<strong>不会丢失</strong>；2）若使用缓存文件 I&#x2F;O，则<strong>会丢失</strong>；</li>
<li>假设没来得及调用 write()， 那么数据<strong>必定丢失</strong>。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407201117479.png" alt="image-20240720111707650"></p>
<h2 id="八、设备管理"><a href="#八、设备管理" class="headerlink" title="八、设备管理"></a>八、设备管理</h2><h3 id="【-暂时不背-】130、键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#【-暂时不背-】130、键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="【&#x3D;暂时不背&#x3D;】130、键盘敲入 A 字母时，操作系统期间发生了什么？"></a>【&#x3D;暂时不背&#x3D;】130、键盘敲入 A 字母时，操作系统期间发生了什么？</h3><h2 id="九、网络系统"><a href="#九、网络系统" class="headerlink" title="九、网络系统"></a>九、网络系统</h2><h3 id="【-暂时不背-】131、什么是零拷贝？"><a href="#【-暂时不背-】131、什么是零拷贝？" class="headerlink" title="【&#x3D;暂时不背&#x3D;】131、什么是零拷贝？"></a>【&#x3D;暂时不背&#x3D;】131、什么是零拷贝？</h3><p>零拷贝时一种 I&#x2F;O 操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。</p>
<p>常见的零拷贝技术包括：</p>
<ol>
<li><strong>mmap</strong>：将文件映射到进程的地址空间，直接访问文件数据。</li>
<li><strong>sendfile</strong>：直接将文件数据从内核缓冲区发送到网络。</li>
<li><strong>DMA（Direct Memory Access）</strong>：直接内存访问技术，允许设备直接与内存交换数据。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407201023067.png" alt="image-20240720102356911" style="zoom: 33%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407201022761.png" alt="image-20240720102216495" style="zoom: 30%;" /><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407201023970.png" alt="image-20240720102306832" style="zoom: 30%;" /></p>
<h3 id="【-等网络编程学完再总结-】132、I-O-多路复用：select-poll-epoll"><a href="#【-等网络编程学完再总结-】132、I-O-多路复用：select-poll-epoll" class="headerlink" title="【&#x3D;等网络编程学完再总结&#x3D;】132、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>【&#x3D;等网络编程学完再总结&#x3D;】132、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h3><h3 id="【-等网络编程学完再总结-】133、高性能网络模式：Reactor-和-Proactor"><a href="#【-等网络编程学完再总结-】133、高性能网络模式：Reactor-和-Proactor" class="headerlink" title="【&#x3D;等网络编程学完再总结&#x3D;】133、高性能网络模式：Reactor 和 Proactor"></a>【&#x3D;等网络编程学完再总结&#x3D;】133、高性能网络模式：Reactor 和 Proactor</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/12/1%20C++/%E5%86%85%E5%AD%98/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/12/1%20C++/%E5%86%85%E5%AD%98/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-12 14:29:34" itemprop="dateCreated datePublished" datetime="2024-06-12T14:29:34+08:00">2024-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 11:17:01" itemprop="dateModified" datetime="2024-07-16T11:17:01+08:00">2024-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%86%85%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">内存</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、shared-ptr-weak-ptr"><a href="#一、shared-ptr-weak-ptr" class="headerlink" title="一、shared_ptr &amp; weak_ptr"></a>一、shared_ptr &amp; weak_ptr</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ithiker/article/details/51532484">C++ 智能指针（shared_ptr&#x2F;weak_ptr）源码分析</a></p>
<h2 id="1、类关系图"><a href="#1、类关系图" class="headerlink" title="1、类关系图"></a>1、类关系图</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121430079.png" alt="img"></p>
<p>shared_ptr内部包含：</p>
<ul>
<li>1）指向被管理对象(managed object)T的指针</li>
<li>2）__shared_count对象，其内部包含：<ul>
<li>a. 指向管理对象(manager object)的基类指针。</li>
</ul>
</li>
</ul>
<p>管理对象(manager object)内部包含：</p>
<ul>
<li>1）具有原子属性(_Atomic_word)的use_count&#x2F;weak_count</li>
<li>2）指向被管理对象(managed object)T的指针</li>
<li>3）用来销毁被管理对象的deleter</li>
</ul>
<p>被管理对象和管理对象的划分如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436387.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436029.png" alt="img"></p>
<p>可以看出，shared_ptr与weak_ptr的差异主要是由__shared_ptr与__weak_ptr体现出来的，而__shared_ptr与__weak_ptr的差异则主要是由__shared_count与__weak_count体现出来。</p>
<h2 id="2、详细分析"><a href="#2、详细分析" class="headerlink" title="2、详细分析"></a>2、详细分析</h2><h3 id="（1）shared-ptr的构造函数"><a href="#（1）shared-ptr的构造函数" class="headerlink" title="（1）shared_ptr的构造函数"></a>（1）shared_ptr的构造函数</h3><p>在创建一个<code>shared_ptr</code>的时候需要通过被管理对象的地址来初始化<code>shared_ptr</code>, <code>shared_ptr</code>在内部会构建一个<code>__shared_count</code>对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt; <span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">: _M_ptr(__p), _M_refcount(__p) &#123;</span><br><span class="line">    <span class="comment">// 静态断言，确保 _Tp1* 可以转换为 _Tp*，用于类型安全检查</span></span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// 确保 _Tp1 类型是完整的</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> _IsComplete[<span class="built_in">sizeof</span>(_Tp1)];</span><br><span class="line">    <span class="comment">// 启用 shared_from_this 的辅助功能，允许被管理对象在不知道其自身被管理的情况下创建其他 shared_ptr 实例</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>explicit __shared_ptr(_Tp1* __p)</code>：显式构造函数，接受一个 <code>_Tp1*</code> 类型的指针 <code>__p</code>，该指针通常是通过 <code>new</code> 操作符分配的。</li>
<li><code>: _M_ptr(__p), _M_refcount(__p)</code>：初始化列表，负责初始化 <code>__shared_ptr</code> 的成员变量。<ul>
<li><code>_M_ptr</code> 是一个<strong>指向被管理对象的指针</strong>，初始化为 <code>__p</code>。</li>
<li><code>_M_refcount</code> 是一个<strong>引用计数控制块</strong>，通常包含引用计数和自定义删除器等信息，也被初始化为 <code>__p</code>。</li>
</ul>
</li>
</ul>
<p>由<code>__shared_count</code>对象的构造函数可知，创建<code>shared_ptr</code>的时候也动态的创建了一个管理对象<code>_Sp_counted_base_impl</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">__shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">   &#123;</span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;</span><br><span class="line">	  _M_pi = <span class="keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(__p, _Sp_deleter&lt;_Tp&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">	__throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>shared_ptr</code>内部包含一个指向被管理对象的指针<code>_M_ptr</code>， <code>_Sp_counted_base_impl</code>内部也含有一个指向被管理对象的指针<code>_M_ptr</code>， 它们是不是重复多余了呢？</p>
</blockquote>
<p>实际上不多余，它们有各自的功能。首先给出结论：</p>
<blockquote>
<p><code>__shared_ptr</code>直接包含的裸指针是为了实现一般指针的<code>-&gt;</code>和<code>*</code>等操作；通过<code>__shared_count</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</p>
<p>换句话说，<code>__shared_count</code>内部的<code>use_count</code>主要用来标记被管理对象的生命周期，<code>weak_count</code>主要用来标记管理对象的生命周期。</p>
<p>当一个<code>shared_ptr</code>超出作用域被销毁时，它会调用其<code>_share_count</code>的<code>_M_release()</code>对<code>use_count</code>和<code>weak_count</code>进行自减并判断是否需要释放管理对象和被管理对象，这是<code>RAII</code>原理的核心体现。</p>
</blockquote>
<p>这首先要从<code>shared_ptr</code>的拷贝构造或者赋值构造说起。当一个<code>shared_ptr</code>对象<code>sp2</code>是由<code>sp1</code>拷贝构造或者赋值构造得来的时候，实际上<strong>构造完成后<code>sp1</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针与<code>sp2</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针是相等的</strong>，也就是说当多个<code>shared_ptr</code>对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象。</p>
<p>这可以从下面的<code>__share_ptr</code>的构造函数和<code>__shared_count</code>的构造函数清楚地看出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"> __shared_ptr(<span class="type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)</span><br><span class="line"> : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) <span class="comment">// never throws</span></span><br><span class="line">&#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">__shared_count&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != _M_pi)  <span class="comment">// 避免自我赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">            __tmp-&gt;_M_add_ref_copy();  <span class="comment">// 增加目标控制块的引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)  </span><br><span class="line">            _M_pi-&gt;_M_release();  <span class="comment">// 减少当前控制块的引用计数</span></span><br><span class="line">        _M_pi = __tmp;   <span class="comment">// 更新当前实例的控制块指针 _M_pi，使其指向目标控制块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对<code>if (_M_pi != 0)</code>，考虑以下两种情况：</p>
<ul>
<li><pre><code class="c++">std::shared_ptr&lt;int&gt; sp1(new int(10));
std::shared_ptr&lt;int&gt; sp2;

// sp2 此时未初始化，_M_pi == 0
sp2 = sp1;  // 调用赋值运算符
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp1(new int(10));  // sp1指向new int(10)，其引用计数为1</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp2(new int(11));  // sp2指向new int(11)，其引用计数为1</span><br><span class="line">  </span><br><span class="line">  // sp2已初始化，_M_pi != 0</span><br><span class="line">  sp2 = sp1;  // 调用赋值运算符，注意此处sp2指向的new int(11)引用计数减1，因此sp2和其指向的对象均被析构</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>针对<code>_M_add_ref_copy()</code>和<code>_M_release()</code>做进一步分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span> _M_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    <span class="comment">// 用于告知数据竞赛检测工具（如 ThreadSanitizer），在这行代码之前发生了内存同步事件</span></span><br><span class="line">    <span class="comment">// 确保线程间正确通信</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少引用计数，并检查是否是最后一个引用</span></span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)  <span class="comment">// 减少引用计数 _M_use_count，并返回减少前的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的引用计数减少操作已经完成</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">      </span><br><span class="line">        _M_dispose();  <span class="comment">// 释放对象资源</span></span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="comment">// 确保在 _M_dispose() 和 _M_destroy() 之间有一个内存屏障，</span></span><br><span class="line">        <span class="comment">// 以确保所有 _M_dispose() 的效果对调用 _M_destroy() 的线程可见</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        <span class="comment">// 通知数据竞赛检测工具弱引用计数的操作即将开始</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少弱引用计数，并检查是否是最后一个弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的弱引用计数减少操作已经完成</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">                        </span><br><span class="line">            _M_destroy();  <span class="comment">// 释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="comment">// Called when _M_use_count drops to zero, to release the resources</span></span><br><span class="line"><span class="comment">// managed by *this.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() = <span class="number">0</span>; <span class="comment">// nothrow</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Called when _M_weak_count drops to zero.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_destroy() <span class="comment">// nothrow</span></span><br><span class="line">&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base_impl*************//</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() <span class="comment">// nothrow</span></span><br><span class="line">&#123; _M_del(_M_ptr); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）weak-ptr对应的-weak-count的拷贝构造函数"><a href="#（2）weak-ptr对应的-weak-count的拷贝构造函数" class="headerlink" title="（2）weak_ptr对应的__weak_count的拷贝构造函数"></a>（2）weak_ptr对应的__weak_count的拷贝构造函数</h3><ul>
<li><code>__weak_count</code>相关的赋值拷贝以及析构函数均只会影响到<code>weak_count</code>的值，对<code>use_count</code>没有影响；当<code>weak_count</code>为0时，释放管理对象。也就是说<code>__weak_ptr</code>不影响被管理对象的生命周期。同时由于<code>__weak_ptr</code>没有像<code>__shared_ptr</code>那样实现<code>*</code>，<code>-&gt;</code>等常见指针相关操作符，<code>__weak_ptr</code>不能直接操作被管理对象；</li>
<li><code>__weak_count</code>自身间的赋值以及<code>__shared_count</code>对<code>__weak_count</code>的赋值时，它们都具有同样的指向管理对象的指针；也就是说当多个<code>__weak_ptr</code>和<code>__shared_ptr</code>指向同一个被管理对象时，它们共享同一个管理对象，这就保证了可以通过<code>__weak_ptr</code>可以判断<code>__shared_ptr</code>指向的被管理对象是否存在以及获取到被管理对象的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> _M_weak_add_ref() <span class="comment">// nothrow</span></span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_weak_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	<span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// See _M_release(),</span></span><br><span class="line">	    <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">	&#125;</span><br><span class="line">	_M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">  </span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __weak_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">      __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">      _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~__weak_count() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）-shared-ptr与-weak-ptr管理同一对象"><a href="#（3）-shared-ptr与-weak-ptr管理同一对象" class="headerlink" title="（3）__shared_ptr与__weak_ptr管理同一对象"></a>（3）__shared_ptr与__weak_ptr管理同一对象</h3><p>关系图如下所示：</p>
<p>其中<code>weak_ptr</code>不能直接操作被管理对象，但其仍然持有指向被管理对象的指针（用来初始化内部的<code>__weak_count</code>对象），<code>weak_ptr</code>与被管理对象用虚线联接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121521900.png" alt="img"></p>
<h3 id="（4）shared-ptr的两个“大坑”"><a href="#（4）shared-ptr的两个“大坑”" class="headerlink" title="（4）shared_ptr的两个“大坑”"></a>（4）shared_ptr的两个“大坑”</h3><h4 id="A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f"><a href="#A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f" class="headerlink" title="A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?"></a>A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?</h4><blockquote>
<p><code>shared_ptr</code>能够管理对象的生命周期，负责对象资源释放，其前提条件是所有<code>shared_ptr</code>共用同一个管理对象。如果<strong>多个<code>shared_ptr</code>使用多个管理对象来管理同一个被管理对象</strong>，这些管理对象在<code>use_count</code>为<code>0</code>时均会释放被管理对象，将会造成多个管理对象多次释放被管理对象，造成<code>twice delete</code>的堆错误。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Thing * t1 = <span class="keyword">new</span> Thing;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">delete</span> t1; <span class="comment">// done with the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***** Use shared_ptr***************************//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>; <span class="comment">// create manager object A for the Thing</span></span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when t1 goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp_for_this</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">//  create manager object B for the Thing</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_for_this);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when sp_for_this and other shared_ptr goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++引入了<code>enable_shared_from_this</code>，利用<code>weak_ptr</code>的特性解决了这一问题。</p>
<p>其基本思想是：通过<code>M</code>继承模板类<code>enable_shared_from_this</code>，这样对象<code>M</code>内部将会有一个<code>__weak_ptr</code>指针<code>_M_weak_this</code>，在第一次创建指向<code>M</code>的<code>shared_ptr</code>时，通过模板特化，将会初始化<code>_M_weak_this</code>。这样<code>M</code>内部也会产生一个指向自身的<code>weak_ptr</code>，并且该<code>weak_ptr</code>内部的管理对象与Pt的管理对象是相同的（这可以从<code>weak_ptr</code>内部的<code>_M_assign</code>函数看出）。</p>
<p>这样，在<code>M</code>内部，当需要传递指向<code>M</code>的智能指针时，可以通过继承而来的<code>shared_from_this</code>方法获取到指向<code>M</code>的智能指针而不会发生内存泄漏。上面示例中改写后的正确代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Thing&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// The following starts a manager object for the Thing and also</span></span><br><span class="line">	<span class="comment">// initializes the weak_ptr member that is now part of the Thing and share same manager object.</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get a shared_ptr from the weak_ptr in this object</span></span><br><span class="line">	shared_ptr&lt;Thing&gt; sp_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"><a href="#B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作" class="headerlink" title="B. 在采用shared_ptr&lt;M&gt; p(new M)形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"></a>B. 在采用<code>shared_ptr&lt;M&gt; p(new M)</code>形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作</h4><p>如果频繁的需要创建指向多个不同对象的智能指针，可以采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;)</code>的方式，采用这种方式<strong>系统将会分配一大块内存同时存放管理对象和被管理对象</strong>，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现<code>new</code>操作符，符合<code>&quot;no naked new!&quot;</code>的编程倡导。</p>
<p>当然这也有缺点，如果所有指向该对象的智能指针都销毁了，尽管对象的析构函数会被调用，析构被管理对象，但是<strong>如果还有<code>weak_ptr</code>指向该块对象所在的内存，存放管理对象的部分内存仍将不会被释放</strong>，因而导致在所有其他<code>weak_ptr</code>销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用。</p>
<h1 id="二、unique-ptr"><a href="#二、unique-ptr" class="headerlink" title="二、unique_ptr"></a>二、unique_ptr</h1><p><code>unique_ptr</code>是智能指针的一种，他<strong>只可移动不可复制</strong>，即一个指针的所有权只能由一个智能指针所占有。</p>
<p><code>unique_ptr</code>内部靠一个<code>tuple</code>来维护<code>raw pointer</code>和<code>deleter</code>。<code>unique_ptr</code>相当于一个对<code>RAII</code>的封装，他在栈上有一个指针，指针指向堆中实际分配的内存，当栈上指针生命周期结束时，自动调用<code>deleter</code>去释放堆上内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="comment">// default_delete是默认析构器，默认析构器中使用delete运算符实现对象的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用__uniq_ptr_impl管理要管理的heap对象</span></span><br><span class="line">    <span class="comment">// _Tp为管理对象类型，_Dp为析构器</span></span><br><span class="line">    __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer    = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">    <span class="keyword">using</span> element_type  = _Tp;</span><br><span class="line">    <span class="keyword">using</span> deleter_type  = _Dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1、-uniq-ptr-impl"><a href="#1、-uniq-ptr-impl" class="headerlink" title="1、__uniq_ptr_impl"></a>1、__uniq_ptr_impl</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> _Ptr</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> type = _Up*;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// pointer实际上就是_Tp*</span></span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 使用tuple管理指针和析构器，通过get&lt;0&gt;获取_Tp*，get&lt;1&gt;获取析构器</span></span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 先通过_M_t()获取指针，再赋值</span></span><br><span class="line">    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">    <span class="comment">// 自定义析构器</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">    __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d) : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line">    <span class="comment">// 获取所管理的对象</span></span><br><span class="line">    pointer&amp;   _M_ptr() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    <span class="comment">// 获取析构器</span></span><br><span class="line">    _Dp&amp;       _M_deleter() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、构造函数和析构函数"><a href="#2、构造函数和析构函数" class="headerlink" title="2、构造函数和析构函数"></a>2、构造函数和析构函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，显式创建一个空的unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _M_t() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p构造一个unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span> : _M_t(__p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p和自定义析构器__d构造一个unique_ptr对象</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p,</span><br><span class="line">    <span class="keyword">typename</span> conditional&lt;is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">      deleter_type, <span class="type">const</span> deleter_type&amp;&gt;::type __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable copy from lvalue.不允许复制，体现专属所有权语义</span></span><br><span class="line"><span class="comment">// 使用了C++11特性delete</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor.体现专属所有权语义和只移型别</span></span><br><span class="line"><span class="comment">// 只允许使用移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 如果复制一个unique_ptr对象，会将源unique_ptr对象管理的资源release掉</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 只是使用的类型是可以隐式转换的其他unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = _Require&lt;</span><br><span class="line">         __safe_conversion_up&lt;_Up, _Ep&gt;,</span><br><span class="line">   <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,</span><br><span class="line">      is_same&lt;_Ep, _Dp&gt;,</span><br><span class="line">      is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>()))</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assignment，也可以说明是专属所有权语义和只移型别</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// __u.release()释放并返回源unique_ptr对象管理的资源</span></span><br><span class="line">    <span class="comment">// reset是将__u.release()返回的资源赋给目标（当前）unique_ptr对象</span></span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">    <span class="built_in">get_deleter</span>() = std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，调用析构器析构掉管理的资源，并将__ptr指向nullptr</span></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">get_deleter</span>()(__ptr);</span><br><span class="line">    __ptr = <span class="built_in">pointer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_deleter()(__ptr);的解读</span></span><br><span class="line"><span class="comment">// get_deleter()返回的是析构器，默认的析构器为struct default_delete&lt;_Tp&gt;</span></span><br><span class="line"><span class="comment">// struct default_delete&lt;_Tp&gt;有一个operator()操作符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以get_deleter()(__ptr);实际上就是delete __ptr;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、成员函数"><a href="#3、成员函数" class="headerlink" title="3、成员函数"></a>3、成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以像raw pointer一样，解引用</span></span><br><span class="line"><span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_assert(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像raw pointer一样获取保存的指针，调用get方法</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _GLIBCXX_DEBUG_PEDASSERT(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对所管理资源的所有权</span></span><br><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer __p = <span class="built_in">get</span>();</span><br><span class="line">    _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置所管理的资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != <span class="built_in">pointer</span>() <span class="built_in">get_deleter</span>()(__p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、unique-ptr的使用"><a href="#4、unique-ptr的使用" class="headerlink" title="4、unique_ptr的使用"></a>4、unique_ptr的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span> &#123;&#125;; <span class="comment">// 待管理对象</span></span><br><span class="line"><span class="comment">// 默认的析构器struct default_delete&lt;_Tp&gt;实际上是一个仿函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们就可以定义一个lambd作为析构器</span></span><br><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pInvestment); <span class="comment">// 做一些删除前的工作</span></span><br><span class="line">                    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="comment">// 使用decltype推到出自定义析构器的类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">((<span class="keyword">new</span> Investment), delInvmt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果要自定义析构器，就必须使用构造函数，而无法通过C++14提供的make_unique函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span></span><br><span class="line">&#123;</span><br><span class="line">  ~<span class="built_in">Investment</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;called ~Investment()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ivmt = [](Investment* pInvestment)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;user-defined delete...&quot;</span> &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">delete</span> pInvestment;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="comment">// 包在括号中，方便观察结果</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(ivmt)</span>&gt; <span class="title">pInvestment</span><span class="params">((<span class="keyword">new</span> Investment), ivmt)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">user-defined <span class="keyword">delete</span>...</span><br><span class="line">called ~<span class="built_in">Investment</span>()...</span><br></pre></td></tr></table></figure>

<p>另外<code>unique_ptr</code>不允许以赋值语法将一个<code>raw pointer</code>当作初值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unipue_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>); <span class="comment">// error</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>不能使用普通的拷贝或者赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>; <span class="comment">// pInt1现在为左值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt1)</span></span>;      <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用移动语义，使用move将左值转为右值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(std::move(pInt1))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; pInt2;</span><br><span class="line">pInt2 = pInt1; <span class="comment">// error</span></span><br><span class="line">pInt2 = std::<span class="built_in">move</span>(pInt1);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/11/1%20C++/STL/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/11/1%20C++/STL/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">常用STL容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-11 15:54:29" itemprop="dateCreated datePublished" datetime="2024-06-11T15:54:29+08:00">2024-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 11:12:12" itemprop="dateModified" datetime="2024-07-16T11:12:12+08:00">2024-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><h3 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">e</span><span class="params">(n, <span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; f&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">g</span><span class="params">(arr, arr+m)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">h</span><span class="params">(g.begin(), g.end())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    <span class="comment">// 1. 下标访问</span></span><br><span class="line">    a.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 迭代器访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator s;</span><br><span class="line">    s = a.begin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(s+i));  <span class="comment">// 常用STL容器中，仅vector和string支持a.begin()+i这种写法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (s=a.begin(); s!=a.end(); s++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用内置函数</span></span><br><span class="line">    a.reverse(<span class="number">100</span>);		<span class="comment">// 预分配100个元素的内存，注意reserve操作只是预分配内存，并不会改变Vector的大小</span></span><br><span class="line">    a.push_back(<span class="number">4</span>);		<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.emplace_back(<span class="number">1</span>);  <span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.pop_back();		<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = a.size();             <span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.resize(<span class="number">3</span>);</span><br><span class="line">    a.resize(<span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 扩容，且新增元素初始化为10</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> first = a.front();</span><br><span class="line">    <span class="type">int</span> last = a.back();</span><br><span class="line"></span><br><span class="line">    a.insert(a.begin(), <span class="number">0</span>);   			<span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    a.erase(a.begin());          		<span class="comment">// erase()有两种方法，时间复杂度都为O(N)</span></span><br><span class="line">    a.erase(a.begin(), a.end()<span class="number">-1</span>);  	<span class="comment">// erase(first,last)删除[first, last)内的所有元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> is_empty = a.empty();</span><br><span class="line">    a.clear();        <span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// algorithm常用函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">    sort(a.begin(),a.end());  				<span class="comment">// 对[a.begin(), a.end())进行从大到小排序</span></span><br><span class="line">    reverse(a.begin(),a.end());  			<span class="comment">// 对[a.begin(), a.end())进行倒置，但不排序</span></span><br><span class="line">    copy(a.begin(),a.end(),b.begin()+<span class="number">1</span>); 	<span class="comment">// 把[a.begin(), a.end())的元素复制到b中</span></span><br><span class="line">    find(a.begin(),a.end(),<span class="number">10</span>);  			<span class="comment">// 在[a.begin(), a.end())的元素中查找10。并返回其位置（迭代器）</span></span><br><span class="line">    count(a.begin(), a.end(),<span class="number">10</span>);    		<span class="comment">// 在[a.begin(), a.end())的元素中查找10的个数，并返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现"><a href="#2、内部实现" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p>vector 的底层是一个动态数组，包含三个迭代器：start、finish 和 end_of_storage。</p>
<ul>
<li>start 和 finish 之间是已经被使用的空间范围；</li>
<li>end_of_storage 是整块连续空间（包括备用空间）的尾部。</li>
</ul>
<p>当<code>push_banck()</code>时发现空间容量不够，会自动申请另一片更大的空间（1.5或2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【3、vector的扩容机制】。当释放或者删除（<code>vec.clear()</code>）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。因此，对vector的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111938752.png" alt="在这里插入图片描述"></p>
<p>vector 维护的是一个连续的线性空间，所以不论其元素类型为何，普通指针都可以作为 vector 的迭代器而满足所以必要条件，如 operator*，operator-&gt;，operator++，operator–，普通指针天生就具备。vector 支持随机存取，而普通指针正有这样的能力。所以底层直接将指针封装成了 iterator。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111939776.png" alt="在这里插入图片描述"></p>
<h3 id="3、vector-的扩容机制"><a href="#3、vector-的扩容机制" class="headerlink" title="3、vector 的扩容机制"></a>3、vector 的扩容机制</h3><h4 id="（1）扩容机制原理"><a href="#（1）扩容机制原理" class="headerlink" title="（1）扩容机制原理"></a>（1）扩容机制原理</h4><p>当向 vector 中插入元素时，如果元素有效个数 size 与空间容量 capacity 相等时，vector 内部会触发扩容机制：</p>
<ol>
<li>开辟新空间；</li>
<li>拷贝元素；</li>
<li>释放旧空间。</li>
</ol>
<h4 id="（2）如何避免动态扩容，导致效率降低"><a href="#（2）如何避免动态扩容，导致效率降低" class="headerlink" title="（2）如何避免动态扩容，导致效率降低"></a>（2）如何避免动态扩容，导致效率降低</h4><p>如果要避免扩容而导致程序效率过低问题，其实非常简单：<strong>如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。</strong>如果插入之前进行 reserve，只要空间给足，则插入时不会扩容，如果没有 reserve，则会边插入边扩容，效率极其低下。</p>
<h4 id="（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍"><a href="#（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍" class="headerlink" title="（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍"></a>（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍</h4><p>扩容原理为：申请新空间，拷贝元素，释放旧空间。<strong>理想的分配方案是在第N次扩容时能复用之前N-1次释放的空间。</strong>如果按照2倍方式扩容，第i次扩容空间大小如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947980.png" alt="在这里插入图片描述"><br>可以看到，每次扩容时，前面释放的空间都不能使用。比如：第4次扩容时，前2次空间已经释放，第3次空间还没有释放(开辟新空间、拷贝元素、释放旧空间)，即前面释放的空间只有1 + 2 &#x3D; 3，假设第3次空间已经释放才只有1+2+4&#x3D;7，而第四次需要8个空间，因此无法使用之前已释放的空间，但是<strong>按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了</strong>。<strong>如果倍数超过2倍(包含2倍)方式扩容会存在以下问题</strong>：</p>
<ul>
<li>空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用；</li>
<li>无法使用到前面已释放的内存。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947476.png" alt="在这里插入图片描述"></p>
<ul>
<li>使用2倍（k&#x3D;2）扩容机制扩容时，每次扩容后的新内存大小必定大于前面的总和；</li>
<li>而使用1.5倍（k&#x3D;1.5）扩容时，在几次扩展以后，可以重用之前的内存空间了。</li>
</ul>
<p>因为 STL 标准并没有严格说明需要按何种方式进行扩容，因此不同的实现厂商都是按照自己的方式扩容的，即：<strong>Linux 下是按照2倍的方式扩容的，而 vs 下是按照1.5倍的方式扩容的</strong>。</p>
<h4 id="（4）Windows-和-Linux-的扩容底层原理"><a href="#（4）Windows-和-Linux-的扩容底层原理" class="headerlink" title="（4）Windows 和 Linux 的扩容底层原理"></a>（4）Windows 和 Linux 的扩容底层原理</h4><ol>
<li><p>Windows 扩容底层</p>
<p>Windows 中堆管理系统会对释放的堆块进行合并，因此 vs 下的 vector 扩容机制选择使用1.5倍的方式扩容，这样多次扩容之后就可以使用之前已经释放的空间。</p>
</li>
<li><p>Linux 的扩容底层</p>
</li>
</ol>
<img src="https://img-blog.csdnimg.cn/4f12d834bac147ee9bcba58e5521a961.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qOu5piO5biu5aSn5LqO6buR6JmO5biu,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:80%;" />

<ul>
<li>Linux 下主要使用 glibc 的 ptmalloc 来进行用户空间申请的<ul>
<li>如果 malloc 的空间小于<code>128KB</code>，其内部通过<code>brk()</code>来扩张；</li>
<li>如果大于<code>128KB</code>且<code>arena</code>中没有足够的空间时，通过<code>mmap()</code>将内存映射到进程地址空间。</li>
</ul>
</li>
<li>Linux 中引入<strong>伙伴系统</strong>（所谓的伙伴系统就是 STL 中通过链表来实现的内存池）为内核提供了一种用于分配连续页的高效的分配策略，实现对固定分区和动态分区方式的折中：固定分区存在内部碎片；动态分区存在外部碎片，而且动态分区回收时的合并以及分配时的切片是比较耗时的。<ul>
<li>伙伴系统是将整个内存区域构建成基本大小<code>basicSize</code>的1倍、2倍、4倍、8倍、16倍等，即要求内存空间分区链均对应2的整次幂倍大小的空间；</li>
<li>在分配和释放空间时，可以通过<code>log2(request/basicSize)</code>向上取整的哈希算法快速找到对应内存块。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111952632.png" alt="img"></p>
<h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><h3 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list4</span><span class="params">(list2.begin(), list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : list2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    list1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    list1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    list1.<span class="built_in">pop_back</span>();</span><br><span class="line">    list1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    list2.<span class="built_in">reverse</span>();	<span class="comment">// 反转列表</span></span><br><span class="line">    list2.<span class="built_in">sort</span>();		<span class="comment">// 排序列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// algorithm</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 求和</span></span><br><span class="line">    std::for_each(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;  <span class="comment">// 遍历</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">10</span>);  <span class="comment">// 计算元素个数</span></span><br><span class="line">    list2.<span class="built_in">remove</span>(<span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础"><a href="#2、理论基础" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>由于 list 拥有一片不连续的内存空间，且 STL list 是一个双向链表，因此其提供的迭代器是 Bidirectional Iterators。对于 list 来说，其插入操作和接合操作不会使得原迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;  <span class="comment">// 缺省使用 alloc 作为空间配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* list_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  <span class="comment">// 专属空间配置器，每次配置一个节点大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><h3 id="1、基本用法-2"><a href="#1、基本用法-2" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化方式1：默认构造</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式2：用元素初始化</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式3：使用fill构造</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式4：使用范围构造</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque4</span><span class="params">(deque2.begin(), deque2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    deque1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    deque1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    deque1.<span class="built_in">pop_back</span>();</span><br><span class="line">    deque1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转双端队列</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序双端队列</span></span><br><span class="line">    std::<span class="built_in">sort</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用算法函数</span></span><br><span class="line">    <span class="comment">// std::find</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != deque2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::accumulate</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素的和：&quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::for_each</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    std::for_each(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::count</span></span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2中包含10的个数：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::remove</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(new_end, deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终的deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础-1"><a href="#2、理论基础-1" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>deque 是双向开口的连续线性空间。</p>
<blockquote>
<p>deque 和 vector 的差别：</p>
<ol>
<li>deque 允许于常数时间内对起头端进行元素的插入或移除操作；</li>
<li>deque 没有所谓容量（capacity）的概念，因为它是<strong>动态地以分段连续空间组合而成</strong>，随时可以增加一段新的空间并链接起来。</li>
<li>deque 虽然也提供 RamdomAccessIterator，但其迭代器并非普通指针，复杂度较高，因此除非必要，应尽量使用 vector 而非 deque。对 deque 进行的排序操作，可以先将 deque 完成复制到一个 vector 中，排序后再复制回 deque。</li>
</ol>
</blockquote>
<p>deque 的迭代器包含两个任务：</p>
<ol>
<li><p>指出分段连续空间（即缓冲区）在哪里；</p>
</li>
<li><p>判断自己是否已经处于所在缓冲区的边缘，若是，则一旦前进或后退时就必须跳跃至下一个或上一个缓冲区:</p>
<ol>
<li><p><strong>最后一个缓冲区只剩下一个备用空间</strong>，则调用 <code>push_back_aux()</code>新建并跳跃至下一个缓冲区；</p>
</li>
<li><p><strong>第一个缓冲区没有备用空间</strong>，则调用 <code>push_front_aux()</code>新建并跳跃至上一个缓冲区。</p>
<blockquote>
<p>由于前端插入操作涉及到现有缓冲区前面的空间，因此需要确保当前缓冲区完全没有空间时，再进行新的缓冲区分配和跳跃操作。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>deque 采用一个 “map”（并非 STL 中的 map 容器）来指向其分段连续空间（缓冲区）。map 中的每一个元素 node 为一个指针，指向其对应的缓冲区。对于 deque 来说，主要维护 3 个指针：</p>
<ol>
<li>指向 map 的指针；</li>
<li>start：指向第一缓冲区的第一个元素；</li>
<li>finish：指向最后缓冲区的最后一个元素。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720123.png" alt="image-20240620172003136" style="zoom: 25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720621.png" alt="image-20240620172045147" style="zoom: 25%;" />

<h2 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h2><h3 id="1、基本用法-3"><a href="#1、基本用法-3" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();			<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();			<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();			<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);		<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h3 id="2、理论相关"><a href="#2、理论相关" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><p>STL 中 stack 往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>栈的底层实现可以是 vector、deque或list 等， 主要就是数组和链表的底层实现。常用的 SGI STL ，如果没有指定底层实现的话，<strong>默认是以 deque 为缺省情况下栈的底层结构</strong>。此外，SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />

<blockquote>
<p>三个最为普遍的 STL 版本：</p>
<ol>
<li>HP STL 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由 P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++ 编译器所采用，不是开源的。</li>
<li>SGI STL 由 Silicon Graphics Computer Systems 公司参照HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><h3 id="1、基本用法-4"><a href="#1、基本用法-4" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();		<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();		<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);		<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();		<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();		<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();		<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h2><h3 id="1、基本用法-5"><a href="#1、基本用法-5" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><h4 id="（1）声明"><a href="#（1）声明" class="headerlink" title="（1）声明"></a>（1）声明</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：优先队列中的元素类型；</li>
<li><code>Container</code>：底层容器的类型；</li>
<li><code>Compare</code>：比较函数对象，决定了优先队列的排序方式。</li>
</ul>
<h4 id="（2）基本操作"><a href="#（2）基本操作" class="headerlink" title="（2）基本操作"></a>（2）基本操作</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">top</span>();	<span class="comment">// 返回q的第一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）排序实现"><a href="#（3）排序实现" class="headerlink" title="（3）排序实现"></a>（3）排序实现</h4><ol>
<li><p><code>less</code>和<code>greater</code>优先队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// less&lt;int&gt;:14 12 10 8 6（大顶堆）</span></span><br><span class="line"><span class="comment">// greater&lt;int&gt;:6 8 10 12 14（小顶堆）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义仿函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareByAge</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age;  <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、理论相关-1"><a href="#2、理论相关-1" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>优先级队列（<code>priority_queue</code>）是C++标准库中的一个<strong>容器适配器（container adapter）</strong>，其中的元素按照一定的优先级进行排序，每次取出的元素都是优先级最高的。其底层实现通常使用堆<strong>（heap）</strong>数据结构。</p>
<p>定义在<code>&lt;queue&gt;</code>头文件中。</p>
<p>默认情况下，<code>priority_queue</code>使用<code>std::less</code>作为比较函数，即元素的优先级按照从大到小的顺序排列。</p>
<h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h4><ul>
<li><strong>优先级排序</strong>：priority_queue中的元素按照一定的优先级进行排序。默认情况下，元素的优先级按照从大到小的顺序排列，也可以通过自定义的比较函数来指定不同的排序方式。</li>
<li><strong>自动排序</strong>：在插入元素时，priority_queue会根据元素的优先级自动进行排序。每次插入新元素时，都会将新元素放置在正确的位置上。</li>
<li><strong>取出优先级最高元素</strong>：priority_queue提供了一种方便的方式来取出优先级最高的元素。使用top()函数可以访问优先级最高的元素，而使用pop()函数可以将该元素从队列中移除。</li>
<li><strong>底层实现采用堆</strong>：priority_queue通常使用堆（heap）数据结构来实现。堆是一种具有特定性质的二叉树，可以高效地插入新元素和取出优先级最高的元素。</li>
<li><strong>动态大小</strong>：priority_queue的大小可以根据需要进行动态调整。可以随时插入新元素和删除已有元素，并在必要时自动重新排序。</li>
</ul>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="std-unordered-set"><a href="#std-unordered-set" class="headerlink" title="std::unordered_set"></a>std::unordered_set</h2><h3 id="1、基本用法-6"><a href="#1、基本用法-6" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 获取或设置允许的最大装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前bucket的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复插入，不会有任何效果</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is the set empty ? &quot;</span> &lt;&lt; mySet.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">find</span>(<span class="number">2</span>) != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found 2 in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历集合</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in mySet: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing 2, size of mySet: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Before add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0</span><br><span class="line">Bucket count: 1</span><br><span class="line"></span><br><span class="line">Is the <span class="built_in">set</span> empty ? 0</span><br><span class="line">Found 2 <span class="keyword">in</span> the <span class="built_in">set</span>.</span><br><span class="line">Elements <span class="keyword">in</span> mySet: 3 2 1 </span><br><span class="line">After erasing 2, size of mySet: 2</span><br><span class="line"></span><br><span class="line">After add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0.153846</span><br><span class="line">Bucket count: 13</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-1"><a href="#2、内部实现-1" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_set</code> 的内部实现基于哈希表，哈希表是一个数组，数组的每个元素称为一个 <code>bucket</code>。这点和 <code>std::unordered_map</code> 是一样的。</p>
<p>同样的，每个 <code>bucket</code> 维护一个链表（或其他容器，例如小型向量），用于解决哈希冲突（即不同元素的哈希值相同的情况）。</p>
<ul>
<li>哈希函数：<code>std::unordered_set</code>通过哈希函数将元素映射到一个 <code>bucket</code>。哈希函数的质量决定了元素在哈希表中的分布，影响容器的性能。</li>
<li>哈希冲突：当两个元素的哈希值相同时，它们会被存储在同一个 <code>bucket</code> 的链表中，这种情况称为哈希冲突。<code>std::unordered_set</code>通过链地址法来解决哈希冲突。</li>
<li>装载因子和重哈希：装载因子是<code>元素数量 / bucket数量</code>。当装载因子超过某个阈值时（默认为<code>1.0</code>），<code>std::unordered_set</code>会进行重哈希操作，即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的高效性。</li>
</ul>
<p>适用场景</p>
<ul>
<li>需要快速查找的场景：当需要存储一组唯一元素，并且频繁地进行查找操作时；</li>
<li>不关心元素顺序：<code>std::unordered_set</code>不保证元素的顺序；</li>
<li>大量数据的去重：当需要从大量数据中去除重复项时。</li>
</ul>
<h2 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h2><h3 id="1、基本用法-7"><a href="#1、基本用法-7" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    map.<span class="built_in">insert</span>(&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    map[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;apple has &quot;</span> &lt;&lt; map[<span class="string">&quot;apple&quot;</span>] &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用find查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> search = map.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found banana, count = &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Banana not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    map.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The map has &quot;</span> &lt;&lt; map.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apple has 5 units.</span><br><span class="line">Found banana, count = 3</span><br><span class="line">banana has 3 units.</span><br><span class="line">apple has 5 units.</span><br><span class="line">The map has 1 elements.</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-2"><a href="#2、内部实现-2" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_map</code>内部使用哈希表实现，因此它支持平均常数时间复杂度的查找、插入和删除操作，而<code>std::map</code>使用红黑树实现，提供对数时间复杂度的操作。</p>
<p><code>std::unordered_map</code>内部主要是通过一个动态数组（通常称为 <code>bucket</code> 数组）来维护元素，每个数组元素（或称为 <code>bucket</code>）包含一个指向链表（或其他形式的容器，如小型向量）的指针。</p>
<p>这些链表用于存储具有相同哈希值的元素（键值对）。当发生哈希冲突时（即不同的键产生相同的哈希值），<code>std::unordered_map</code>会将具有相同哈希值的元素存储在同一个 <code>bucket</code> 的链表中。</p>
<ul>
<li>哈希函数：<code>std::unordered_map</code>使用一个哈希函数将键映射到 bucket 的索引。哈希函数的质量直接影响到容器的性能，理想情况下，哈希函数应该将键均匀分布到所有的 <code>buckets</code> 上，以减少哈希冲突。</li>
<li>哈希表：内部数据结构，通常是一个动态数组，其中的每个元素指向一个链表（或其他容器），用于解决哈希冲突。</li>
<li>键值对：存储在链表中的元素，每个元素包含一个键和一个值。</li>
<li>装载因子：<code>std::unordered_map</code>的装载因子是一个浮点数，定义为<code>元素个数 / bucket数量</code>。当装载因子超过特定阈值（默认为<code>1.0</code>）时，哈希表会进行重新哈希（<code>rehashing</code>），即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的效率。</li>
</ul>
<p>适用场景</p>
<ul>
<li><p><strong>需要快速查找的场景；</strong></p>
</li>
<li><p><strong>不关心元素顺序的场景；</strong></p>
</li>
<li><p><strong>键值对存储。</strong></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/11/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/11/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="post-title-link" itemprop="url">时间&空间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-11 14:30:41" itemprop="dateCreated datePublished" datetime="2024-06-11T14:30:41+08:00">2024-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 11:16:09" itemprop="dateModified" datetime="2024-07-16T11:16:09+08:00">2024-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>883</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;     <span class="comment">// for循环语句执行 n+1 次</span></span><br><span class="line">  x++;                         <span class="comment">// x++;语句执行 n 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>2n+1</code>，因此取其最大阶，其时间复杂度就是<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;   <span class="comment">// 该for循环语句执行 n*(n+1) 次</span></span><br><span class="line">    x++;                       <span class="comment">// 该x++;语句执行 n*n 次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>n+1+n*(n+1)+n*n</code>，因此取其最大阶，其时间复杂度就是<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=j; k++) &#123;</span><br><span class="line">            x++;                     <span class="comment">// 该x++;语句执行 A 次（见下方注释）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(n^3)</code>。</p>
<blockquote>
<p>A</p>
<p>对于这三个<code>for</code>循环语句，从下往上分析：</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>     x++;<br>  }<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 执行`j`次；</span><br><span class="line"></span><br><span class="line">&gt;+ ```c++</span><br><span class="line"> for (int j=1; j&lt;=i; j++) &#123; </span><br><span class="line">     for (int k=1; k&lt;=j; k++) &#123; </span><br><span class="line">         x++; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111459800.png" alt="image-20240611145906766" style="zoom:67%;" />次；</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int i&#x3D;1; i&lt;&#x3D;n; i++) {<br>     for (int j&#x3D;1; j&lt;&#x3D;i; j++) {<br>         for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>             x++;<br>         }<br>     }<br>  }</p>
<p>执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111500830.png" alt="image-20240611150038794" style="zoom: 67%;" />次。</p>
<p>综上所述，<code>x++;</code>语句执行的次数如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111457129.png" alt="image-20240611145732091" style="zoom:67%;" />
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i=i*<span class="number">2</span>) &#123;</span><br><span class="line">    x++;                         <span class="comment">// 该x++;语句执行 B 次（见下方注释）</span></span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(log2n)</code>。</p>
<blockquote>
<p>B</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111455603.png" alt="image-20240611145554310" style="zoom: 67%;" />

<p>所以，对于<code>for</code>循环语句来说，其执行了<code>k+1</code>次；但对于<code>x++;</code>语句来说，只执行了<code>k</code>次。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111527560.png" alt="image-20240611152735504" style="zoom:67%;" />
</blockquote>
<h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111529670.png" alt="image-20240611152906551"></p>
<h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）时间复杂度</p>
<p><code>int left = 0, right = nums.size() - 1;</code>的时间复杂度为<code>O(1)</code>。</p>
<p>接下来看<code>while (left &lt;= right)</code>这个while循环最多会执行几次。</p>
<p>由于<code>int mid = left + (right - left) / 2;</code>，因此每一次会将搜索空间（<code>S</code>）折半，如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111544858.png" alt="image-20240611154411802" style="zoom: 80%;" />

<p>（2）空间复杂度</p>
<p>空间复杂度主要看算法使用的额外空间量（不包括输入数据本身）。</p>
<ol>
<li><strong>变量声明</strong>：<ul>
<li><code>int left</code>, <code>int right</code>, <code>int mid</code> 都是常数空间<code>O(1)</code>。</li>
</ul>
</li>
<li><strong>没有递归或额外的数据结构</strong>：<ul>
<li>算法不需要额外的数组、栈或队列等辅助数据结构。</li>
</ul>
</li>
</ol>
<p>综上，整个算法的空间复杂度是 <code>O(1)</code>。</p>
<h2 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (sum &gt;= target) &#123;</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>注意此处的时间复杂度不是O(n^2)！分析如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[r++]; <span class="comment">// 这个操作会执行 n 次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">        sum -= nums[l++]; <span class="comment">// 最坏情况下，内层 while 循环会执行 n 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然嵌套了两层循环，但是由于整个过程中，<code>nums</code>中的每个元素最多会被<code>l</code>和<code>r</code>各访问一次，也即被操作两次，因此时间复杂度是<code>2n</code>，也即<code>O(n)</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">256k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:32</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
